{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>iters</code>","text":"<p>Composable external iteration.</p> <p>If you have found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you will quickly run into iterators. Iterators are heavily used in idiomatic Python code, so becoming familiar with them is essential.</p>"},{"location":"#installing","title":"Installing","text":"<p>Python 3.7 or above is required.</p>"},{"location":"#pip","title":"pip","text":"<p>Installing the library with <code>pip</code> is quite simple:</p> <pre><code>$ pip install iters\n</code></pre> <p>Alternatively, the library can be installed from source:</p> <pre><code>$ git clone https://github.com/nekitdev/iters.git\n$ cd iters\n$ python -m pip install .\n</code></pre>"},{"location":"#poetry","title":"poetry","text":"<p>You can add <code>iters</code> as a dependency with the following command:</p> <pre><code>$ poetry add iters\n</code></pre> <p>Or by directly specifying it in the configuration like so:</p> <pre><code>[tool.poetry.dependencies]\niters = \"^0.13.0\"\n</code></pre> <p>Alternatively, you can add it directly from the source:</p> <pre><code>[tool.poetry.dependencies.iters]\ngit = \"https://github.com/nekitdev/iters.git\"\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#simple","title":"Simple","text":"<p>Squaring only even numbers in some sequence:</p> <pre><code>from iters import iter\n\n\ndef is_even(value: int) -&gt; bool:\n    return not value % 2\n\n\ndef square(value: int) -&gt; int:\n    return value * value\n\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nresult = iter(numbers).filter(is_even).map(square).list()\n\nprint(result)  # [0, 4, 16, 36, 64]\n</code></pre>"},{"location":"#asynchronous","title":"Asynchronous","text":"<p>Asynchronous iteration is fully supported by <code>iters</code>, and its API is similar to its synchronous counterpart.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>You can find the documentation here.</p>"},{"location":"#support","title":"Support","text":"<p>If you need support with the library, you can send an email or refer to the official Discord server.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>You can find the changelog here.</p>"},{"location":"#security-policy","title":"Security Policy","text":"<p>You can find the Security Policy of <code>iters</code> here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you are interested in contributing to <code>iters</code>, make sure to take a look at the Contributing Guide, as well as the Code of Conduct.</p>"},{"location":"#license","title":"License","text":"<p><code>iters</code> is licensed under the MIT License terms. See License for details.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#0130-2023-05-21","title":"0.13.0 (2023-05-21)","text":""},{"location":"changelog/#internal","title":"Internal","text":"<ul> <li>Migrated to using <code>typing-aliases</code> library.</li> </ul>"},{"location":"changelog/#0120-2023-05-10","title":"0.12.0 (2023-05-10)","text":""},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>This release contains lots of breaking changes. Please refer to the API documentation.</li> </ul>"},{"location":"changelog/#0110-2023-01-29","title":"0.11.0 (2023-01-29)","text":""},{"location":"changelog/#internal_1","title":"Internal","text":"<ul> <li><code>async-extensions</code> is now used instead of reimplementing <code>collect_iterable</code> functionality.</li> </ul>"},{"location":"changelog/#0100-2023-01-08","title":"0.10.0 (2023-01-08)","text":""},{"location":"changelog/#internal_2","title":"Internal","text":"<ul> <li>Marked the internals of the <code>OrderedSet[Q]</code> private.</li> </ul>"},{"location":"changelog/#090-2023-01-07","title":"0.9.0 (2023-01-07)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Added <code>collect_iter</code> method for <code>AsyncIter[T]</code> and <code>Iter[T]</code>.</li> </ul>"},{"location":"changelog/#080-2022-12-22","title":"0.8.0 (2022-12-22)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Added <code>into_iter</code> method for <code>AsyncIter[T]</code>.</li> <li>Added <code>into_async_iter</code> method for <code>Iter[T]</code>.</li> </ul>"},{"location":"changelog/#070-2022-12-20","title":"0.7.0 (2022-12-20)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Added <code>OrderedSet[Q]</code> type within the <code>iters.ordered_set</code> module.</li> <li>Added <code>ordered_set</code> method to <code>Iter[T]</code> and <code>AsyncIter[T]</code>.</li> </ul>"},{"location":"changelog/#060-2022-11-08","title":"0.6.0 (2022-11-08)","text":""},{"location":"changelog/#internal_3","title":"Internal","text":"<ul> <li>Migrated to using <code>named</code> and   <code>solus</code> packages instead of   reimplementing their functionality. (#18)</li> </ul>"},{"location":"changelog/#050-2022-10-11","title":"0.5.0 (2022-10-11)","text":""},{"location":"changelog/#changes_1","title":"Changes","text":"<ul> <li>Functions taking <code>Predicate[T]</code> have been updated to accept <code>Optional[Predicate[T]]</code>.   Passing <code>None</code> as an argument is identical to passing <code>bool</code>.</li> </ul> <p>There are three functions which do not accept <code>None</code>, though:   - <code>drop_while</code>   - <code>skip_while</code>   - <code>take_while</code></p> <p>This choice is motivated by the fact that it does not make much sense to <code>do_while(None)</code>.</p>"},{"location":"changelog/#040-2022-10-08","title":"0.4.0 (2022-10-08)","text":""},{"location":"changelog/#changes_2","title":"Changes","text":"<ul> <li>The following functions have been changed:</li> <li><code>async_iter</code> is now an alias of <code>AsyncIter</code>;</li> <li><code>iter</code> is now an alias of <code>Iter</code>;</li> <li><code>reversed</code> is now an alias of <code>iter.reversed</code>.</li> </ul>"},{"location":"changelog/#030-2022-08-17","title":"0.3.0 (2022-08-17)","text":""},{"location":"changelog/#changes_3","title":"Changes","text":"<ul> <li>Changed functions of various arity returning <code>Awaitable[T]</code> to async functions returning <code>T</code>.   (#15)</li> </ul>"},{"location":"changelog/#020-2022-08-15","title":"0.2.0 (2022-08-15)","text":""},{"location":"changelog/#changes_4","title":"Changes","text":"<ul> <li>Added <code>await async_iter</code>, equivalent to <code>await async_iter.list()</code>.</li> </ul>"},{"location":"changelog/#010-2022-08-01","title":"0.1.0 (2022-08-01)","text":"<p>Initial release.</p>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement to conduct@nekit.dev.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://contributor-covenant.org/version/2/1/code_of_conduct.</p> <p>Community Impact Guidelines were inspired by Mozilla's Code of Conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://contributor-covenant.org/faq. Translations are available at https://contributor-covenant.org/translations.</p>"},{"location":"predicates/","title":"Predicates","text":"<p><code>iters</code> defines all <code>predicate</code> arguments as <code>Optional[Predicate[T]]</code> where <code>T</code> is the item type of the iterable.</p> <p>Passing <code>None</code> as the predicate argument is equivalent to passing <code>bool</code>, though most functions are optimized to avoid the overhead of function calls to it.</p>"},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#reporting","title":"Reporting","text":"<p>Thank you for taking the time to responsibly disclose any problems you find.</p> <p>Do not file public issues as they are open for everyone to see!</p> <p>All security vulnerabilities in <code>iters</code> should be reported by email to security@nekit.dev. Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report.</p> <p>You can encrypt your report using our public key: <code>BB2D8194464001E0B9B60EB8741A1EAD20FFDE8A</code>. This key is also available on MIT's Key Server and reproduced below.</p> <p>After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours.</p>"},{"location":"security/#disclosure-policy","title":"Disclosure Policy","text":"<p><code>iters</code> has a 5-step disclosure process:</p> <ol> <li> <p>The security report is received and is assigned a primary handler.    This person will coordinate the fix and release process.</p> </li> <li> <p>The problem is confirmed and a list of all affected versions is determined.</p> </li> <li> <p>Code is audited to find any potential similar problems.</p> </li> <li> <p>Fixes are prepared for all releases which are still under maintenance.    These fixes are not committed to the public repository but rather    held locally pending the announcement.</p> </li> <li> <p>On the embargo date, the changes are pushed to the public repository    and new builds are deployed.</p> </li> </ol> <p>This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner.</p>"},{"location":"security/#security-key","title":"Security Key","text":"<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmQINBGKJEuEBEAC37iPX5u8sN+DZQ8c4Of+85u/hboSqNLp7VtTGgr/d8RCFhGZk\n25ZwqGWeJbhnlPuzT6u96CZFRe3TMHYJR+A2NZBVjAQQjDRGbIGgaS6/9lvMLcRx\nD+hFQNPgwUTfPhSHIan+9EuYK/Bz+jyyIplwTrIBq1Mo0NG+cUNvAB+he22xhBQ7\ny/Xal+sapHfYedqywhYEQUgP94IGURIMiBlAB7nKW+qs7YiQBShBbfxxffMgK6W6\nsNNSybUQDqjj1AWkOBj5uizkA6FLF80xULypbhe1gbqsIt4d1Lj/mxI5zvj84wy5\noQ6QOpYlBUQwl8kqfszYaqKCviflA+riAFMAE8NVL+5BuVN0QSvQb6cRzIV1SL0p\nMCA6s2+plK/9K+JyR5yyjY7FxvatYNLW5LsubmS+YeBdO4l4A7YEElOGMexUb61H\n3ejlb/9UUrZ7hd09Hsi1J6nthrI26o0XBdB8UJ9QAdfoHWka3fgSgopBBcI+S3tU\niWGngFrUhiXcBS+0xHjrk4USKwFyFr8fmL4Y8Yu31ViHRFj6gVjC/PHP0apCnakB\nUEEMHnAQfztodH9o2ew2kew77+q9VblDGpb3BYaiptl4c6h6WBcEULpRfWERfB8H\nSt4L49Ob6CCNpVw9qgsDfNw2fFjUIsT6OGwJxhv9StIFW2JEhgxEvfHr1wARAQAB\ntC9OaWtpdGEgVGlraG9ub3YgKHNlY3VyaXR5KSA8c2VjdXJpdHlAbmVraXQuZGV2\nPokCUgQTAQgAPAIbAwIXgAIeBxYhBLstgZRGQAHgubYOuHQaHq0g/96KBQJiiR6G\nBQsJCAcCAyICAQYVCgkICwIEFgIDAQAKCRB0Gh6tIP/einfmD/9y69eqwjRfdmnW\ns0ph8Rh99JHtgA+zm1akRl+eymiqLuJwmZge7PPFb68Wj4lI6s1M1dIkyRuYMtIM\n3rEcMmGUlcVnPldx/wdcPyhYZDUXnYCK64dsloftrWFWoSr5a/AILyVh/L6Fkf+L\nRU9h3KPMXhLTyK127ZF5WuzpjSJms0hDMDV/idfiDeWn/VGaZz1Wiks4l8R9kisR\nLI3RKNR537f0KFS8jkqlI41Lj9XQTUdqMRp+eqi/zUMM7OZzKQg1ohDsLi4MR6wa\nbXIu7LeAp1M0XlB+MO09KOxR8i19ST89EapAp4gHprbG5hJyV3XHK4txcWHG0YjB\ng5/fOvytljf/ue5YGe5nQUcxucq6i4d6jsB66Gk/4nnKutlMG2ZtVyIZZZActPZ5\nqKI64HQJOpag+ERXwrv0optEhTC7RHOFRuZ4pCKuVjdJE9W7ZpAIAi8yHeVvpgJY\nglo+DqZH1/kLD1u2Jb/8yUuMeCYc3aBlfZswO6IeMFeXbPaMtIHzY5q7blIdKIAb\nYxS5KCYn8VHG6Nz8lFMu2z4jpH4QY9vTaxZnG3Xp23uxbP0pznih4DMiHIACyCBP\nWgRReZTCVU6Z9FvBq8t/hcrwli33lTa5hkuuzqcojn80+1g9st7DOzxVFtR2MoSS\nWkv8ss8apRyeLNZAM5M8v+AiiyVCrLkCDQRiiRLhARAApEJFgvQVDMYpuo754cRK\nWC/17DH1BQ9y78h/0MXmOOf/0MpzJBkPjn4++BdXQGoOCBleHrWmbtmfYLcQFmZ/\neiUzxFDS/pkC7aZUb+YA7JzcwZQP2yOhlMfFK0qCoQKw/45q+AkOUR+Z+VGExkM1\n5+PAcQ+7cQRiyina6/MG7FHAOcvuEwjiyt/0zBm3izeWmXL0Gngisl1jvd8bGn4T\nbK68q2d09NNHdXJ9UDFdGJ+FVIqJCyLyBl0ZfWazSkD/4ZNchdjFcSOzTTMvqWWn\n6i5awbVyMPZkKS88vRVwTtcjk4+hrzaIyNbTw7y55qQxFe0NEoj4SK+iMwCkax19\nnjGQeB8GqmieC+0WYUSt10xXZ6tDf6a9F2cg6zv1ZklOuYU9x8GYwU7zvhrGhvXU\nUn1ZtP/OaHoQsS/+AS7KJtm/NWHGsfjd8vwDirIoZ31D7X52QrN07NQ0H7+uqtDL\nc7BAhsLI1G/r9Kz0+P0nC/6bMWvQWiomB1BSwUTfXLkT0RoKZ3Yub8XMk46N9XKE\nRtTk5x0/rZ40uOg8wzT1GvwYFA4tpavAqLejOftE05lKXAb5tQhYRupZywzXM6HN\nDR7CbP1e26g0p8GAuz1aFny6cN8T3wTHHyYn7aQk7i1BboV8zFpVlF6EmoHNCZtG\nhkl28kYa0Yvu+9mw0SPNiIsAEQEAAYkCNgQYAQgAIBYhBLstgZRGQAHgubYOuHQa\nHq0g/96KBQJiiRLhAhsMAAoJEHQaHq0g/96KeCoP/3i3A629wvjPn7m3y7pTcV8p\nriTlH5OeXhg4jCORgJrgL4PSoeFCITA0u0djtcvctmCrHMsZe0hyH5+X+/B9Bsf6\neFQKWXLidqkxD/M6lnE6t34d17DvaWCP27MsS/f0u0FsLom11TTFgp4wGKZfRBNH\nvX5xuhjoYXYwZwWqCYyEXFTbsUTDce2oaqc7Yw/GmM3fCodLX0/0eYh5u2fiKA57\n7VuUWD74/TkgcEOMa/IZ/jPmJHuHOteaIJR0pYUvLQ1EJh3jI4LhmH8DqxoUrmKy\n8z2VM0iLIiev86EXM+yzqTpRIFnm6Ts+47L18rb9D5IUo68gr5B2bMKPOfvMVzdN\n/vw2RKdCVJ70nh3qqRis5RsJrn/3T8H1CQtuPvsAd/oB86YGWPpWBtpTyI+VBp+x\n+XR434K8D9QXFst73wTCnQwSX6j0sIotQC5GsPJEKky2Wijg3BlxqTxtYjLhwKWg\nx3e63TEw7IgU+lE/ybzWLJ7EndbKsC7stZh+Lyh5b3YHgI3cfJUxjZNFpniKr/Fy\n4EjjLZzFf3QRmNNJ/7VlYLYztGZsOWxRsLk7QfUPSZY4iHUr8aiwfL7IFwnAlzIo\n36HDjJi80UakMlf45UcxRaJwWiaj7G4x3h1D1BZLtMiypiaw/mesrithmfHg+KYu\n1oYi7ft0FnZ67Wnk5+E+\n=VRe2\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"security/#attribution","title":"Attribution","text":"<p>This Security Policy is adapted from Rust's Security Policy.</p>"},{"location":"reference/async_iters/","title":"Async Iterators","text":""},{"location":"reference/async_iters/#iters.async_iters.AsyncIter","title":"<code>AsyncIter</code>","text":"<p>         Bases: <code>AsyncIterator[T]</code></p> Source code in <code>iters/async_iters.py</code> <pre><code>class AsyncIter(AsyncIterator[T]):\n    # internals\n\n    _iterator: AsyncIterator[T]\n\n    def __init__(self, iterable: AnyIterable[T]) -&gt; None:\n        self._iterator = async_iter_any_iter(iterable)\n\n    def _replace(self, iterator: AsyncIterator[T]) -&gt; None:\n        self._iterator = iterator\n\n    # implementation\n\n    @property\n    def iterator(self) -&gt; AsyncIterator[T]:\n\"\"\"The underlying iterator.\"\"\"\n        return self._iterator\n\n    @classmethod\n    def empty(cls) -&gt; AsyncIter[T]:\n        return cls.create(async_empty())\n\n    @classmethod\n    def of(cls, *items: V) -&gt; AsyncIter[V]:\n        return cls.create(async_of(*items))\n\n    @classmethod\n    def once(cls, value: V) -&gt; AsyncIter[V]:\n        return cls.create(async_once(value))\n\n    @classmethod\n    def once_with(cls, function: Nullary[V]) -&gt; AsyncIter[V]:\n        return cls.create(async_once_with(function))\n\n    @classmethod\n    def once_with_await(cls, function: AsyncNullary[V]) -&gt; AsyncIter[V]:\n        return cls.create(async_once_with_await(function))\n\n    @classmethod\n    def repeat(cls, value: V) -&gt; AsyncIter[V]:\n        return cls.create(async_repeat(value))\n\n    @classmethod\n    def repeat_exactly(cls, value: V, count: int) -&gt; AsyncIter[V]:\n        return cls.create(async_repeat(value, count))\n\n    @classmethod\n    def repeat_with(cls, function: Nullary[V]) -&gt; AsyncIter[V]:\n        return cls.create(async_repeat_with(function))\n\n    @classmethod\n    def repeat_with_await(cls, function: AsyncNullary[V]) -&gt; AsyncIter[V]:\n        return cls.create(async_repeat_with_await(function))\n\n    @classmethod\n    def repeat_exactly_with(cls, function: Nullary[V], count: int) -&gt; AsyncIter[V]:\n        return cls.create(async_repeat_with(function, count))\n\n    @classmethod\n    def repeat_exactly_with_await(cls, function: AsyncNullary[V], count: int) -&gt; AsyncIter[V]:\n        return cls.create(async_repeat_with_await(function, count))\n\n    @classmethod\n    def count_from_by(cls, start: int, step: int) -&gt; AsyncIter[int]:\n        return cls.create(async_count(start, step))\n\n    @classmethod\n    def count_from(cls, start: int) -&gt; AsyncIter[int]:\n        return cls.count_from_by(start, DEFAULT_STEP)\n\n    @classmethod\n    def count_by(cls, step: int) -&gt; AsyncIter[int]:\n        return cls.count_from_by(DEFAULT_START, step)\n\n    @classmethod\n    def count(cls) -&gt; AsyncIter[int]:\n        return cls.count_from_by(DEFAULT_START, DEFAULT_STEP)\n\n    @classmethod\n    def iterate(cls, function: Unary[V, V], value: V) -&gt; AsyncIter[V]:\n        return cls.create(async_iterate(function, value))\n\n    @classmethod\n    def iterate_exactly(cls, function: Unary[V, V], value: V, count: int) -&gt; AsyncIter[V]:\n        return cls.create(async_iterate(function, value, count))\n\n    @classmethod\n    def iterate_await(cls, function: AsyncUnary[V, V], value: V) -&gt; AsyncIter[V]:\n        return cls.create(async_iterate_await(function, value))\n\n    @classmethod\n    def iterate_exactly_await(\n        cls, function: AsyncUnary[V, V], value: V, count: int\n    ) -&gt; AsyncIter[V]:\n        return cls.create(async_iterate_await(function, value, count))\n\n    @classmethod\n    def iter_except(cls, function: Nullary[T], *errors: AnyErrorType) -&gt; AsyncIter[T]:\n        return cls.create(async_iter_except(function, *errors))\n\n    @classmethod\n    def iter_except_await(cls, function: AsyncNullary[T], *errors: AnyErrorType) -&gt; AsyncIter[T]:\n        return cls.create(async_iter_except_await(function, *errors))\n\n    @classmethod\n    def iter_with(cls, context_manager: ContextManager[AnyIterable[T]]) -&gt; AsyncIter[T]:\n        return cls.create(async_iter_with(context_manager))\n\n    @classmethod\n    def iter_async_with(\n        cls, async_context_manager: AsyncContextManager[AnyIterable[T]]\n    ) -&gt; AsyncIter[T]:\n        return cls.create(async_iter_async_with(async_context_manager))\n\n    @classmethod\n    def create_chain(cls, *iterables: AnyIterable[T]) -&gt; AsyncIter[T]:\n        return cls.create(async_chain(*iterables))\n\n    @classmethod\n    def create_chain_with(cls, iterable: AnyIterable[AnyIterable[T]]) -&gt; AsyncIter[T]:\n        return cls.create(async_chain_from_iterable(iterable))\n\n    @classmethod\n    def create_combine(cls, *iterables: AnyIterable[T]) -&gt; AsyncIter[T]:\n        return cls.create(async_combine(*iterables))\n\n    @classmethod\n    def create_interleave(cls, *iterables: AnyIterable[T]) -&gt; AsyncIter[T]:\n        return cls.create(async_interleave(*iterables))\n\n    @classmethod\n    def create_interleave_longest(cls, *iterables: AnyIterable[T]) -&gt; AsyncIter[T]:\n        return cls.create(async_interleave_longest(*iterables))\n\n    @overload\n    @classmethod\n    def create_zip(cls) -&gt; AsyncIter[T]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(cls, __iterable_a: AnyIterable[A]) -&gt; AsyncIter[Tuple[A]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls, __iterable_a: AnyIterable[A], __iterable_b: AnyIterable[B]\n    ) -&gt; AsyncIter[Tuple[A, B]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n    ) -&gt; AsyncIter[Tuple[A, B, C]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D, E]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D, E, F]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D, E, F, G]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n        __iterable_h: AnyIterable[H],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D, E, F, G, H]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls,\n        __iterable_a: AnyIterable[Any],\n        __iterable_b: AnyIterable[Any],\n        __iterable_c: AnyIterable[Any],\n        __iterable_d: AnyIterable[Any],\n        __iterable_e: AnyIterable[Any],\n        __iterable_f: AnyIterable[Any],\n        __iterable_g: AnyIterable[Any],\n        __iterable_h: AnyIterable[Any],\n        __iterable_n: AnyIterable[Any],\n        *iterables: AnyIterable[Any],\n    ) -&gt; AsyncIter[DynamicTuple[Any]]:\n        ...\n\n    @no_type_check\n    @classmethod\n    def create_zip(cls, *iterables: AnyIterable[Any]) -&gt; AsyncIter[DynamicTuple[Any]]:\n        return cls.create(async_zip(*iterables))\n\n    @overload\n    @classmethod\n    def create_zip_equal(cls) -&gt; AsyncIter[T]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(cls, __iterable_a: AnyIterable[A]) -&gt; AsyncIter[Tuple[A]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls, __iterable_a: AnyIterable[A], __iterable_b: AnyIterable[B]\n    ) -&gt; AsyncIter[Tuple[A, B]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n    ) -&gt; AsyncIter[Tuple[A, B, C]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D, E]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D, E, F]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D, E, F, G]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n        __iterable_h: AnyIterable[H],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D, E, F, G, H]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls,\n        __iterable_a: AnyIterable[Any],\n        __iterable_b: AnyIterable[Any],\n        __iterable_c: AnyIterable[Any],\n        __iterable_d: AnyIterable[Any],\n        __iterable_e: AnyIterable[Any],\n        __iterable_f: AnyIterable[Any],\n        __iterable_g: AnyIterable[Any],\n        __iterable_h: AnyIterable[Any],\n        __iterable_n: AnyIterable[Any],\n        *iterables: AnyIterable[Any],\n    ) -&gt; AsyncIter[DynamicTuple[Any]]:\n        ...\n\n    @no_type_check\n    @classmethod\n    def create_zip_equal(cls, *iterables: AnyIterable[Any]) -&gt; AsyncIter[DynamicTuple[Any]]:\n        return cls.create(async_zip_equal(*iterables))\n\n    @overload\n    @classmethod\n    def create_zip_longest(cls) -&gt; AsyncIter[T]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(cls, __iterable_a: AnyIterable[A]) -&gt; AsyncIter[Tuple[Option[A]]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls, __iterable_a: AnyIterable[A], __iterable_b: AnyIterable[B]\n    ) -&gt; AsyncIter[Tuple[Option[A], Option[B]]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n    ) -&gt; AsyncIter[Tuple[Option[A], Option[B], Option[C]]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n    ) -&gt; AsyncIter[Tuple[Option[A], Option[B], Option[C], Option[D]]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n    ) -&gt; AsyncIter[Tuple[Option[A], Option[B], Option[C], Option[D], Option[E]]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n    ) -&gt; AsyncIter[Tuple[Option[A], Option[B], Option[C], Option[D], Option[E], Option[F]]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n    ) -&gt; AsyncIter[\n        Tuple[\n            Option[A],\n            Option[B],\n            Option[C],\n            Option[D],\n            Option[E],\n            Option[F],\n            Option[G],\n        ]\n    ]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n        __iterable_h: AnyIterable[H],\n    ) -&gt; AsyncIter[\n        Tuple[\n            Option[A],\n            Option[B],\n            Option[C],\n            Option[D],\n            Option[E],\n            Option[F],\n            Option[G],\n            Option[H],\n        ]\n    ]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls,\n        __iterable_a: AnyIterable[Any],\n        __iterable_b: AnyIterable[Any],\n        __iterable_c: AnyIterable[Any],\n        __iterable_d: AnyIterable[Any],\n        __iterable_e: AnyIterable[Any],\n        __iterable_f: AnyIterable[Any],\n        __iterable_g: AnyIterable[Any],\n        __iterable_h: AnyIterable[Any],\n        __iterable_n: AnyIterable[Any],\n        *iterables: AnyIterable[Any],\n    ) -&gt; AsyncIter[DynamicTuple[Option[Any]]]:\n        ...\n\n    @no_type_check\n    @classmethod\n    def create_zip_longest(\n        cls, *iterables: AnyIterable[Any]\n    ) -&gt; AsyncIter[DynamicTuple[Option[Any]]]:\n        return cls.create(async_zip_longest(*iterables))\n\n    @overload\n    @classmethod\n    def create_cartesian_product(cls) -&gt; AsyncIter[EmptyTuple]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(cls, __iterable_a: AnyIterable[A]) -&gt; AsyncIter[Tuple[A]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls, __iterable_a: AnyIterable[A], __iterable_b: AnyIterable[B]\n    ) -&gt; AsyncIter[Tuple[A, B]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n    ) -&gt; AsyncIter[Tuple[A, B, C]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D, E]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D, E, F]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D, E, F, G]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n        __iterable_h: AnyIterable[H],\n    ) -&gt; AsyncIter[Tuple[A, B, C, D, E, F, G, H]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls,\n        __iterable_a: AnyIterable[Any],\n        __iterable_b: AnyIterable[Any],\n        __iterable_c: AnyIterable[Any],\n        __iterable_d: AnyIterable[Any],\n        __iterable_e: AnyIterable[Any],\n        __iterable_f: AnyIterable[Any],\n        __iterable_g: AnyIterable[Any],\n        __iterable_h: AnyIterable[Any],\n        __iterable_n: AnyIterable[Any],\n        *iterables: AnyIterable[Any],\n    ) -&gt; AsyncIter[DynamicTuple[Any]]:\n        ...\n\n    @no_type_check\n    @classmethod\n    def create_cartesian_product(cls, *iterables: AnyIterable[Any]) -&gt; AsyncIter[DynamicTuple[Any]]:\n        return cls.create(async_cartesian_product(*iterables))\n\n    @classmethod\n    def reversed(cls, reversible: Reversible[T]) -&gt; AsyncIter[T]:\n        return cls.create(async_reversed(reversible))\n\n    @classmethod\n    def function(cls, function: Nullary[T], sentinel: V) -&gt; AsyncIter[T]:\n        return cls.create(async_iter_function(function, sentinel))\n\n    @classmethod\n    def function_await(cls, function: AsyncNullary[T], sentinel: V) -&gt; AsyncIter[T]:\n        return cls.create(async_iter_function_await(function, sentinel))\n\n    @classmethod\n    def create(cls, iterable: AnyIterable[U]) -&gt; AsyncIter[U]:\n        return cls(iterable)  # type: ignore\n\n    @classmethod\n    def create_tuple(cls, iterables: DynamicTuple[AnyIterable[U]]) -&gt; DynamicTuple[AsyncIter[U]]:\n        return tuple(map(cls, iterables))  # type: ignore\n\n    @classmethod\n    def create_nested(cls, nested: AnyIterable[AnyIterable[U]]) -&gt; AsyncIter[AsyncIter[U]]:\n        return cls(map(cls, nested))  # type: ignore\n\n    def __aiter__(self) -&gt; AsyncIter[T]:\n        return self\n\n    async def __anext__(self) -&gt; T:\n        return await async_next_unchecked(self.iterator)\n\n    def __await__(self) -&gt; Generator[None, None, List[T]]:\n        return self.list().__await__()\n\n    def unwrap(self) -&gt; AsyncIterator[T]:\n        return self.iterator\n\n    def async_iter(self) -&gt; AsyncIter[T]:\n        return self\n\n    @wrap_future_option\n    async def next(self) -&gt; Option[T]:\n        return wrap_marked(await async_next_unchecked(self.iterator, marker))\n\n    @wrap_future\n    async def compare(self: AsyncIter[ST], other: AnyIterable[ST]) -&gt; Ordering:\n        return await async_compare(self.iterator, other)\n\n    @wrap_future\n    async def compare_by(self, other: AnyIterable[T], key: Unary[T, ST]) -&gt; Ordering:\n        return await async_compare(self.iterator, other, key)\n\n    @wrap_future\n    async def compare_by_await(self, other: AnyIterable[T], key: AsyncUnary[T, ST]) -&gt; Ordering:\n        return await async_compare_await(self.iterator, other, key)\n\n    @wrap_future\n    async def length(self) -&gt; int:\n        return await async_iter_length(self.iterator)\n\n    @wrap_future_option\n    async def first(self) -&gt; Option[T]:\n        return wrap_marked(await async_first(self.iterator, marker))\n\n    @wrap_future_option\n    async def last(self) -&gt; Option[T]:\n        return wrap_marked(await async_last(self.iterator, marker))\n\n    @wrap_future_option\n    async def last_with_tail(self) -&gt; Option[T]:\n        return wrap_marked(await async_last_with_tail(self.iterator, marker))\n\n    def collect(self, function: Unary[AsyncIterable[T], U]) -&gt; U:\n        return function(self.iterator)\n\n    @wrap_future\n    async def collect_await(self, function: AsyncUnary[AsyncIterable[T], U]) -&gt; U:\n        return await function(self.iterator)\n\n    def collect_iter(self, function: Unary[AsyncIterable[T], AnyIterable[U]]) -&gt; AsyncIter[U]:\n        return self.create(self.collect(function))\n\n    @wrap_future\n    async def list(self) -&gt; List[T]:\n        return await async_list(self.iterator)\n\n    @wrap_future\n    async def set(self: AsyncIter[Q]) -&gt; Set[Q]:\n        return await async_set(self.iterator)\n\n    @wrap_future\n    async def ordered_set(self: AsyncIter[Q]) -&gt; OrderedSet[Q]:\n        return await async_ordered_set(self.iterator)\n\n    @wrap_future\n    async def tuple(self) -&gt; DynamicTuple[T]:\n        return await async_tuple(self.iterator)\n\n    @wrap_future\n    async def dict(self: AsyncIter[Tuple[Q, V]]) -&gt; Dict[Q, V]:\n        return await async_dict(self.iterator)\n\n    @wrap_future\n    async def extract(self) -&gt; Iterator[T]:\n        return await async_extract(self.iterator)\n\n    @wrap_future\n    async def join(self: AsyncIter[AnyStr], string: AnyStr) -&gt; AnyStr:\n        return string.join(await self.list())\n\n    @wrap_future\n    async def string(self: AsyncIter[str]) -&gt; str:\n        return await self.join(EMPTY_STRING)\n\n    @wrap_future\n    async def bytes(self: AsyncIter[bytes]) -&gt; bytes:\n        return await self.join(EMPTY_BYTES)\n\n    @wrap_future\n    async def count_dict(self: AsyncIter[Q]) -&gt; Counter[Q]:\n        return await async_count_dict(self.iterator)\n\n    @wrap_future\n    async def count_dict_by(self, key: Unary[T, Q]) -&gt; Counter[Q]:\n        return await async_count_dict(self.iterator, key)\n\n    @wrap_future\n    async def count_dict_by_await(self, key: AsyncUnary[T, Q]) -&gt; Counter[Q]:\n        return await async_count_dict_await(self.iterator, key)\n\n    @wrap_future\n    async def group_dict(self: AsyncIter[Q]) -&gt; Dict[Q, List[Q]]:\n        return await async_group_dict(self.iterator)\n\n    @wrap_future\n    async def group_dict_by(self, key: Unary[T, Q]) -&gt; Dict[Q, List[T]]:\n        return await async_group_dict(self.iterator, key)\n\n    @wrap_future\n    async def group_dict_by_await(self, key: AsyncUnary[T, Q]) -&gt; Dict[Q, List[T]]:\n        return await async_group_dict_await(self.iterator, key)\n\n    def group(self) -&gt; AsyncIter[Tuple[T, AsyncIter[T]]]:\n        return self.create(\n            (group_key, self.create(group_iterator))\n            async for group_key, group_iterator in async_group(self.iterator)\n        )\n\n    def group_by(self, key: Unary[T, U]) -&gt; AsyncIter[Tuple[U, AsyncIter[T]]]:\n        return self.create(\n            (group_key, self.create(group_iterator))\n            async for group_key, group_iterator in async_group(self.iterator, key)\n        )\n\n    def group_by_await(self, key: AsyncUnary[T, U]) -&gt; AsyncIter[Tuple[U, AsyncIter[T]]]:\n        return self.create(\n            (group_key, self.create(group_iterator))\n            async for group_key, group_iterator in async_group_await(self.iterator, key)\n        )\n\n    def group_list(self) -&gt; AsyncIter[Tuple[T, List[T]]]:\n        return self.create(async_group_list(self.iterator))\n\n    def group_list_by(self, key: Unary[T, U]) -&gt; AsyncIter[Tuple[U, List[T]]]:\n        return self.create(async_group_list(self.iterator, key))\n\n    def group_list_by_await(self, key: AsyncUnary[T, U]) -&gt; AsyncIter[Tuple[U, List[T]]]:\n        return self.create(async_group_list_await(self.iterator, key))\n\n    @wrap_future\n    async def all(self) -&gt; bool:\n        return await async_all(self.iterator)\n\n    @wrap_future\n    async def all_by(self, predicate: Predicate[T]) -&gt; bool:\n        return await self.map(predicate).all()\n\n    @wrap_future\n    async def all_by_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n        return await self.map_await(predicate).all()\n\n    @wrap_future\n    async def any(self) -&gt; bool:\n        return await async_any(self.iterator)\n\n    @wrap_future\n    async def any_by(self, predicate: Predicate[T]) -&gt; bool:\n        return await self.map(predicate).any()\n\n    @wrap_future\n    async def any_by_await(self, predicate: AsyncPredicate[T]) -&gt; bool:\n        return await self.map_await(predicate).any()\n\n    @wrap_future\n    async def all_equal(self) -&gt; bool:\n        return await async_all_equal(self.iterator)\n\n    @wrap_future\n    async def all_equal_by(self, key: Unary[T, U]) -&gt; bool:\n        return await async_all_equal(self.iterator, key)\n\n    @wrap_future\n    async def all_equal_by_await(self, key: AsyncUnary[T, U]) -&gt; bool:\n        return await async_all_equal_await(self.iterator, key)\n\n    @wrap_future\n    async def all_unique(self) -&gt; bool:\n        return await async_all_unique(self.iterator)\n\n    @wrap_future\n    async def all_unique_by(self, key: Unary[T, U]) -&gt; bool:\n        return await async_all_unique(self.iterator, key)\n\n    @wrap_future\n    async def all_unique_by_await(self, key: AsyncUnary[T, U]) -&gt; bool:\n        return await async_all_unique_await(self.iterator, key)\n\n    @wrap_future\n    async def all_unique_fast(self: AsyncIter[Q]) -&gt; bool:\n        return await async_all_unique_fast(self.iterator)\n\n    @wrap_future\n    async def all_unique_fast_by(self, key: Unary[T, Q]) -&gt; bool:\n        return await async_all_unique_fast(self.iterator, key)\n\n    @wrap_future\n    async def all_unique_fast_by_await(self, key: AsyncUnary[T, Q]) -&gt; bool:\n        return await async_all_unique_fast_await(self.iterator, key)\n\n    def remove(self, predicate: Optional[Predicate[T]]) -&gt; AsyncIter[T]:\n        return self.create(async_remove(predicate, self.iterator))\n\n    def remove_await(self, predicate: AsyncPredicate[T]) -&gt; AsyncIter[T]:\n        return self.create(async_remove_await(predicate, self.iterator))\n\n    def remove_duplicates(self) -&gt; AsyncIter[T]:\n        return self.create(async_remove_duplicates(self.iterator))\n\n    def remove_duplicates_by(self, key: Unary[T, U]) -&gt; AsyncIter[T]:\n        return self.create(async_remove_duplicates(self.iterator, key))\n\n    def remove_duplicates_by_await(self, key: AsyncUnary[T, U]) -&gt; AsyncIter[T]:\n        return self.create(async_remove_duplicates_await(self.iterator, key))\n\n    def filter(self, predicate: Optional[Predicate[T]]) -&gt; AsyncIter[T]:\n        return self.create(async_filter(predicate, self.iterator))\n\n    def filter_await(self, predicate: AsyncPredicate[T]) -&gt; AsyncIter[T]:\n        return self.create(async_filter_await(predicate, self.iterator))\n\n    def filter_false(self, predicate: Optional[Predicate[T]]) -&gt; AsyncIter[T]:\n        return self.create(async_filter_false(predicate, self.iterator))\n\n    def filter_false_await(self, predicate: AsyncPredicate[T]) -&gt; AsyncIter[T]:\n        return self.create(async_filter_false_await(predicate, self.iterator))\n\n    def filter_except(self, validate: Validate[T], *errors: AnyErrorType) -&gt; AsyncIter[T]:\n        return self.create(async_filter_except(validate, self.iterator, *errors))\n\n    def filter_except_await(\n        self, validate: AsyncValidate[T], *errors: AnyErrorType\n    ) -&gt; AsyncIter[T]:\n        return self.create(async_filter_except_await(validate, self.iterator, *errors))\n\n    def compress(self, selectors: AnySelectors) -&gt; AsyncIter[T]:\n        return self.create(async_compress(self.iterator, selectors))\n\n    def position_all(self, predicate: Optional[Predicate[T]]) -&gt; AsyncIter[int]:\n        return self.create(async_position_all(predicate, self.iterator))\n\n    def position_all_await(self, predicate: AsyncPredicate[T]) -&gt; AsyncIter[int]:\n        return self.create(async_position_all_await(predicate, self.iterator))\n\n    @wrap_future_option\n    async def position(self, predicate: Optional[Predicate[T]]) -&gt; Option[int]:\n        return wrap_marked(await async_position(predicate, self.iterator, marker))\n\n    @wrap_future_option\n    async def position_await(self, predicate: AsyncPredicate[T]) -&gt; Option[int]:\n        return wrap_marked(await async_position_await(predicate, self.iterator, marker))\n\n    def find_all(self, predicate: Optional[Predicate[T]]) -&gt; AsyncIter[T]:\n        return self.create(async_find_all(predicate, self.iterator))\n\n    def find_all_await(self, predicate: AsyncPredicate[T]) -&gt; AsyncIter[T]:\n        return self.create(async_find_all_await(predicate, self.iterator))\n\n    @wrap_future_option\n    async def find(self, predicate: Optional[Predicate[T]]) -&gt; Option[T]:\n        return wrap_marked(await async_find(predicate, self.iterator, marker))  # type: ignore\n\n    @wrap_future_option\n    async def find_await(self, predicate: AsyncPredicate[T]) -&gt; Option[T]:\n        return wrap_marked(await async_find_await(predicate, self.iterator, marker))  # type: ignore\n\n    @wrap_future_option\n    async def find_or_first(self, predicate: Optional[Predicate[T]]) -&gt; Option[T]:\n        return wrap_marked(\n            await async_find_or_first(predicate, self.iterator, marker)  # type: ignore\n        )\n\n    @wrap_future_option\n    async def find_or_first_await(self, predicate: AsyncPredicate[T]) -&gt; Option[T]:\n        return wrap_marked(\n            await async_find_or_first_await(predicate, self.iterator, marker)  # type: ignore\n        )\n\n    @wrap_future_option\n    async def find_or_last(self, predicate: Optional[Predicate[T]]) -&gt; Option[T]:\n        return wrap_marked(\n            await async_find_or_last(predicate, self.iterator, marker)  # type: ignore\n        )\n\n    @wrap_future_option\n    async def find_or_last_await(self, predicate: AsyncPredicate[T]) -&gt; Option[T]:\n        return wrap_marked(\n            await async_find_or_last_await(predicate, self.iterator, marker)  # type: ignore\n        )\n\n    @wrap_future\n    async def contains(self, item: V) -&gt; bool:\n        return await async_contains(item, self.iterator)\n\n    @wrap_future\n    async def contains_identity(self: AsyncIter[V], item: V) -&gt; bool:\n        return await async_contains_identity(item, self.iterator)\n\n    @wrap_future\n    async def reduce(self, function: Binary[T, T, T]) -&gt; T:\n        return await async_reduce(function, self.iterator)\n\n    @wrap_future\n    async def reduce_await(self, function: AsyncBinary[T, T, T]) -&gt; T:\n        return await async_reduce_await(function, self.iterator)\n\n    @wrap_future\n    async def fold(self, initial: V, function: Binary[V, T, V]) -&gt; V:\n        return await async_fold(initial, function, self.iterator)\n\n    @wrap_future\n    async def fold_await(self, initial: V, function: AsyncBinary[V, T, V]) -&gt; V:\n        return await async_fold_await(initial, function, self.iterator)\n\n    @wrap_future\n    async def sum(self: AsyncIter[S]) -&gt; S:\n        return await async_sum(self.iterator)\n\n    @wrap_future\n    async def sum_with(self: AsyncIter[S], initial: S) -&gt; S:\n        return await async_sum(self.iterator, initial)\n\n    @wrap_future\n    async def product(self: AsyncIter[P]) -&gt; P:\n        return await async_product(self.iterator)\n\n    @wrap_future\n    async def product_with(self: AsyncIter[P], initial: P) -&gt; P:\n        return await async_product(self.iterator, initial)\n\n    def accumulate_reduce(self, function: Binary[T, T, T]) -&gt; AsyncIter[T]:\n        return self.create(async_accumulate_reduce(function, self.iterator))\n\n    def accumulate_reduce_await(self, function: AsyncBinary[T, T, T]) -&gt; AsyncIter[T]:\n        return self.create(async_accumulate_reduce_await(function, self.iterator))\n\n    def accumulate_fold(self, initial: V, function: Binary[V, T, V]) -&gt; AsyncIter[V]:\n        return self.create(async_accumulate_fold(initial, function, self.iterator))\n\n    def accumulate_fold_await(self, initial: V, function: AsyncBinary[V, T, V]) -&gt; AsyncIter[V]:\n        return self.create(async_accumulate_fold_await(initial, function, self.iterator))\n\n    def accumulate_sum(self: AsyncIter[S]) -&gt; AsyncIter[S]:\n        return self.create(async_accumulate_sum(self.iterator))\n\n    def accumulate_sum_with(self: AsyncIter[S], initial: S) -&gt; AsyncIter[S]:\n        return self.create(async_accumulate_sum(self.iterator, initial))\n\n    def accumulate_product(self: AsyncIter[P]) -&gt; AsyncIter[P]:\n        return self.create(async_accumulate_product(self.iterator))\n\n    def accumulate_product_with(self: AsyncIter[P], initial: P) -&gt; AsyncIter[P]:\n        return self.create(async_accumulate_product(self.iterator, initial))\n\n    @wrap_future_option\n    async def min(self: AsyncIter[ST]) -&gt; Option[ST]:\n        return wrap_marked(await async_min(self.iterator, default=marker))\n\n    @wrap_future_option\n    async def min_by(self, key: Unary[T, ST]) -&gt; Option[T]:\n        return wrap_marked(await async_min(self.iterator, key=key, default=marker))  # type: ignore\n\n    @wrap_future_option\n    async def min_by_await(self, key: AsyncUnary[T, ST]) -&gt; Option[T]:\n        return wrap_marked(\n            await async_min_await(self.iterator, key=key, default=marker)  # type: ignore\n        )\n\n    @wrap_future_option\n    async def max(self: AsyncIter[ST]) -&gt; Option[ST]:\n        return wrap_marked(await async_max(self.iterator, default=marker))\n\n    @wrap_future_option\n    async def max_by(self, key: Unary[T, ST]) -&gt; Option[T]:\n        return wrap_marked(await async_max(self.iterator, key=key, default=marker))  # type: ignore\n\n    @wrap_future_option\n    async def max_by_await(self, key: AsyncUnary[T, ST]) -&gt; Option[T]:\n        return wrap_marked(\n            await async_max_await(self.iterator, key=key, default=marker)  # type: ignore\n        )\n\n    @wrap_future_option\n    async def min_max(self: AsyncIter[ST]) -&gt; Option[Pair[ST]]:\n        return wrap_marked(await async_min_max(self.iterator, default=marker))\n\n    @wrap_future_option\n    async def min_max_by(self, key: Unary[T, ST]) -&gt; Option[Pair[T]]:\n        return wrap_marked(await async_min_max(self.iterator, key=key, default=marker))\n\n    @wrap_future_option\n    async def min_max_by_await(self, key: AsyncUnary[T, ST]) -&gt; Option[Pair[T]]:\n        return wrap_marked(await async_min_max_await(self.iterator, key=key, default=marker))\n\n    def map(self, function: Unary[T, U]) -&gt; AsyncIter[U]:\n        return self.create(async_map(function, self.iterator))\n\n    def map_await(self, function: AsyncUnary[T, U]) -&gt; AsyncIter[U]:\n        return self.create(async_map_await(function, self.iterator))\n\n    def map_except(self, function: Unary[T, U], *errors: AnyErrorType) -&gt; AsyncIter[U]:\n        return self.create(async_map_except(function, self.iterator, *errors))\n\n    def map_except_await(self, function: AsyncUnary[T, U], *errors: AnyErrorType) -&gt; AsyncIter[U]:\n        return self.create(async_map_except_await(function, self.iterator, *errors))\n\n    def map_concurrent(self, function: AsyncUnary[T, U]) -&gt; AsyncIter[U]:\n        return self.create(async_map_concurrent(function, self.iterator))\n\n    def map_concurrent_bound(self, bound: int, function: AsyncUnary[T, U]) -&gt; AsyncIter[U]:\n        return self.create(async_map_concurrent_bound(bound, function, self.iterator))\n\n    def flat_map(self, function: Unary[T, AnyIterable[U]]) -&gt; AsyncIter[U]:\n        return self.create(async_flat_map(function, self.iterator))\n\n    def flat_map_await(self, function: AsyncUnary[T, AnyIterable[U]]) -&gt; AsyncIter[U]:\n        return self.create(async_flat_map_await(function, self.iterator))\n\n    def filter_map(self, predicate: Optional[Predicate[T]], function: Unary[T, U]) -&gt; AsyncIter[U]:\n        return self.create(async_filter_map(predicate, function, self.iterator))\n\n    def filter_await_map(self, predicate: AsyncPredicate[T], function: Unary[T, U]) -&gt; AsyncIter[U]:\n        return self.create(async_filter_await_map(predicate, function, self.iterator))\n\n    def filter_map_await(\n        self, predicate: Optional[Predicate[T]], function: AsyncUnary[T, U]\n    ) -&gt; AsyncIter[U]:\n        return self.create(async_filter_map_await(predicate, function, self.iterator))\n\n    def filter_await_map_await(\n        self, predicate: AsyncPredicate[T], function: AsyncUnary[T, U]\n    ) -&gt; AsyncIter[U]:\n        return self.create(async_filter_await_map_await(predicate, function, self.iterator))\n\n    def filter_false_map(\n        self, predicate: Optional[Predicate[T]], function: Unary[T, U]\n    ) -&gt; AsyncIter[U]:\n        return self.create(async_filter_false_map(predicate, function, self.iterator))\n\n    def filter_false_await_map(\n        self, predicate: AsyncPredicate[T], function: Unary[T, U]\n    ) -&gt; AsyncIter[U]:\n        return self.create(async_filter_false_await_map(predicate, function, self.iterator))\n\n    def filter_false_map_await(\n        self, predicate: Optional[Predicate[T]], function: AsyncUnary[T, U]\n    ) -&gt; AsyncIter[U]:\n        return self.create(async_filter_false_map_await(predicate, function, self.iterator))\n\n    def filter_false_await_map_await(\n        self, predicate: AsyncPredicate[T], function: AsyncUnary[T, U]\n    ) -&gt; AsyncIter[U]:\n        return self.create(async_filter_false_await_map_await(predicate, function, self.iterator))\n\n    def flatten(self: AsyncIter[AnyIterable[U]]) -&gt; AsyncIter[U]:\n        return self.create(async_flatten(self.iterator))\n\n    def collapse(self: AsyncIter[RecursiveAnyIterable[U]]) -&gt; AsyncIter[U]:\n        return self.create(async_collapse(self.iterator))\n\n    def enumerate(self) -&gt; AsyncIter[Tuple[int, T]]:\n        return self.create(async_enumerate(self.iterator))\n\n    def enumerate_from(self, start: int) -&gt; AsyncIter[Tuple[int, T]]:\n        return self.create(async_enumerate(self.iterator, start))\n\n    @wrap_future\n    async def consume(self) -&gt; None:\n        await async_consume(self.iterator)\n\n    @wrap_future\n    async def for_each(self, function: ForEach[T]) -&gt; None:\n        await async_for_each(function, self.iterator)\n\n    @wrap_future\n    async def for_each_await(self, function: AsyncForEach[T]) -&gt; None:\n        await async_for_each_await(function, self.iterator)\n\n    def append(self: AsyncIter[V], item: V) -&gt; AsyncIter[V]:\n        return self.create(async_append(item, self.iterator))\n\n    def prepend(self: AsyncIter[V], item: V) -&gt; AsyncIter[V]:\n        return self.create(async_prepend(item, self.iterator))\n\n    @wrap_future_option\n    async def at(self, index: int) -&gt; Option[T]:\n        return wrap_marked(await async_at(index, self.iterator, marker))\n\n    @wrap_future_option\n    async def at_or_last(self, index: int) -&gt; Option[T]:\n        return wrap_marked(await async_at_or_last(index, self.iterator, marker))\n\n    @overload\n    def slice(self, __stop: Optional[int]) -&gt; AsyncIter[T]:\n        ...\n\n    @overload\n    def slice(\n        self, __start: Optional[int], __stop: Optional[int], __step: Optional[int] = ...\n    ) -&gt; AsyncIter[T]:\n        ...\n\n    def slice(self, *slice_args: Optional[int]) -&gt; AsyncIter[T]:\n        return self.create(async_iter_slice(self.iterator, *slice_args))\n\n    def drop(self, size: int) -&gt; AsyncIter[T]:\n        return self.create(async_drop(size, self.iterator))\n\n    skip = drop\n\n    def rest(self) -&gt; AsyncIter[T]:\n        return self.create(async_rest(self.iterator))\n\n    def drop_while(self, predicate: Predicate[T]) -&gt; AsyncIter[T]:\n        return self.create(async_drop_while(predicate, self.iterator))\n\n    skip_while = drop_while\n\n    def drop_while_await(self, predicate: AsyncPredicate[T]) -&gt; AsyncIter[T]:\n        return self.create(async_drop_while_await(predicate, self.iterator))\n\n    skip_while_await = drop_while_await\n\n    def take(self, size: int) -&gt; AsyncIter[T]:\n        return self.create(async_take(size, self.iterator))\n\n    def take_while(self, predicate: Predicate[T]) -&gt; AsyncIter[T]:\n        return self.create(async_take_while(predicate, self.iterator))\n\n    def take_while_await(self, predicate: AsyncPredicate[T]) -&gt; AsyncIter[T]:\n        return self.create(async_take_while_await(predicate, self.iterator))\n\n    def step_by(self, step: int) -&gt; AsyncIter[T]:\n        return self.create(async_step_by(step, self.iterator))\n\n    def tail(self, size: int) -&gt; AsyncIter[T]:\n        return self.create(async_tail(size, self.iterator))\n\n    def apply_chain(self, *iterables: AnyIterable[T]) -&gt; AsyncIter[T]:\n        return self.create(async_chain(self.iterator, *iterables))\n\n    chain = mixed_method(create_chain, apply_chain)\n\n    def apply_chain_with(self, iterables: AnyIterable[AnyIterable[T]]) -&gt; AsyncIter[T]:\n        return self.chain(async_chain_from_iterable(iterables))\n\n    chain_with = mixed_method(create_chain_with, apply_chain_with)\n\n    def cycle(self) -&gt; AsyncIter[T]:\n        return self.create(async_cycle(self.iterator))\n\n    def intersperse(self: AsyncIter[V], value: V) -&gt; AsyncIter[V]:\n        return self.create(async_intersperse(value, self.iterator))\n\n    def intersperse_with(self, function: Nullary[T]) -&gt; AsyncIter[T]:\n        return self.create(async_intersperse_with(function, self.iterator))\n\n    def intersperse_with_await(self, function: AsyncNullary[T]) -&gt; AsyncIter[T]:\n        return self.create(async_intersperse_with_await(function, self.iterator))\n\n    def apply_interleave(self, *iterables: AnyIterable[T]) -&gt; AsyncIter[T]:\n        return self.create(async_interleave(self.iterator, *iterables))\n\n    interleave = mixed_method(create_interleave, apply_interleave)\n\n    def apply_interleave_longest(self, *iterables: AnyIterable[T]) -&gt; AsyncIter[T]:\n        return self.create(async_interleave_longest(self.iterator, *iterables))\n\n    interleave_longest = mixed_method(create_interleave_longest, apply_interleave_longest)\n\n    def apply_combine(self, *iterables: AnyIterable[T]) -&gt; AsyncIter[T]:\n        return self.create(async_combine(*iterables))\n\n    combine = mixed_method(create_combine, apply_combine)\n\n    @overload\n    def distribute_unsafe(self, count: Literal[0]) -&gt; EmptyTuple:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[1]) -&gt; Tuple1[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[2]) -&gt; Tuple2[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[3]) -&gt; Tuple3[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[4]) -&gt; Tuple4[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[5]) -&gt; Tuple5[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[6]) -&gt; Tuple6[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[7]) -&gt; Tuple7[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[8]) -&gt; Tuple8[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: int) -&gt; DynamicTuple[AsyncIter[T]]:\n        ...\n\n    def distribute_unsafe(self, count: int) -&gt; DynamicTuple[AsyncIter[T]]:\n        return self.create_tuple(async_distribute_unsafe(count, self.iterator))\n\n    distribute_infinite = distribute_unsafe\n\n    @overload\n    def distribute(self, count: Literal[0]) -&gt; EmptyTuple:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[1]) -&gt; Tuple1[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[2]) -&gt; Tuple2[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[3]) -&gt; Tuple3[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[4]) -&gt; Tuple4[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[5]) -&gt; Tuple5[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[6]) -&gt; Tuple6[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[7]) -&gt; Tuple7[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[8]) -&gt; Tuple8[AsyncIter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: int) -&gt; DynamicTuple[AsyncIter[T]]:\n        ...\n\n    def distribute(self, count: int) -&gt; DynamicTuple[AsyncIter[T]]:\n        return self.create_tuple(async_distribute(count, self.iterator))\n\n    def divide(self, count: int) -&gt; AsyncIter[AsyncIter[T]]:\n        return self.create_nested(async_divide(count, self.iterator))\n\n    def pad(self, value: V) -&gt; AsyncIter[Union[T, V]]:\n        return self.create(async_pad(value, self.iterator))\n\n    def pad_exactly(self, value: V, size: int) -&gt; AsyncIter[Union[T, V]]:\n        return self.create(async_pad(value, self.iterator, size))\n\n    def pad_multiple(self, value: V, size: int) -&gt; AsyncIter[Union[T, V]]:\n        return self.create(async_pad(value, self.iterator, size, multiple=True))\n\n    def pad_none(self) -&gt; AsyncIter[Optional[T]]:\n        return self.pad(None)\n\n    def pad_none_exactly(self, size: int) -&gt; AsyncIter[Optional[T]]:\n        return self.pad_exactly(None, size)\n\n    def pad_none_multiple(self, size: int) -&gt; AsyncIter[Optional[T]]:\n        return self.pad_multiple(None, size)\n\n    def pad_with(self, function: Unary[int, V]) -&gt; AsyncIter[Union[T, V]]:\n        return self.create(async_pad_with(function, self.iterator))\n\n    def pad_exactly_with(self, function: Unary[int, V], size: int) -&gt; AsyncIter[Union[T, V]]:\n        return self.create(async_pad_with(function, self.iterator, size))\n\n    def pad_multiple_with(self, function: Unary[int, V], size: int) -&gt; AsyncIter[Union[T, V]]:\n        return self.create(async_pad_with(function, self.iterator, size, multiple=True))\n\n    def pad_with_await(self, function: AsyncUnary[int, V]) -&gt; AsyncIter[Union[T, V]]:\n        return self.create(async_pad_with_await(function, self.iterator))\n\n    def pad_exactly_with_await(\n        self, function: AsyncUnary[int, V], size: int\n    ) -&gt; AsyncIter[Union[T, V]]:\n        return self.create(async_pad_with_await(function, self.iterator, size))\n\n    def pad_multiple_with_await(\n        self, function: AsyncUnary[int, V], size: int\n    ) -&gt; AsyncIter[Union[T, V]]:\n        return self.create(async_pad_with_await(function, self.iterator, size, multiple=True))\n\n    def chunks(self, size: int) -&gt; AsyncIter[List[T]]:\n        return self.create(async_chunks(size, self.iterator))\n\n    def iter_chunks(self, size: int) -&gt; AsyncIter[AsyncIter[T]]:\n        return self.create_nested(async_iter_chunks(size, self.iterator))\n\n    def iter_chunks_unsafe(self, size: int) -&gt; AsyncIter[AsyncIter[T]]:\n        return self.create_nested(async_iter_chunks_unsafe(size, self.iterator))\n\n    iter_chunks_infinite = iter_chunks_unsafe\n\n    @overload\n    def groups(self, size: Literal[0]) -&gt; AsyncIter[Never]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[1]) -&gt; AsyncIter[Tuple1[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[2]) -&gt; AsyncIter[Tuple2[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[3]) -&gt; AsyncIter[Tuple3[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[4]) -&gt; AsyncIter[Tuple4[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[5]) -&gt; AsyncIter[Tuple5[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[6]) -&gt; AsyncIter[Tuple6[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[7]) -&gt; AsyncIter[Tuple7[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[8]) -&gt; AsyncIter[Tuple8[T]]:\n        ...\n\n    @overload\n    def groups(self, size: int) -&gt; AsyncIter[DynamicTuple[T]]:\n        ...\n\n    def groups(self, size: int) -&gt; AsyncIter[DynamicTuple[T]]:\n        return self.create(async_groups(size, self.iterator))\n\n    @overload\n    def groups_longest(self, size: Literal[0]) -&gt; AsyncIter[Never]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[1]) -&gt; AsyncIter[Tuple1[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[2]) -&gt; AsyncIter[Tuple2[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[3]) -&gt; AsyncIter[Tuple3[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[4]) -&gt; AsyncIter[Tuple4[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[5]) -&gt; AsyncIter[Tuple5[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[6]) -&gt; AsyncIter[Tuple6[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[7]) -&gt; AsyncIter[Tuple7[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[8]) -&gt; AsyncIter[Tuple8[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: int) -&gt; AsyncIter[DynamicTuple[Option[T]]]:\n        ...\n\n    def groups_longest(self, size: int) -&gt; AsyncIter[DynamicTuple[Option[T]]]:\n        return self.create(async_groups_longest(size, self.iterator))\n\n    def pairs(self) -&gt; AsyncIter[Pair[T]]:\n        return self.create(async_pairs(self.iterator))\n\n    def pairs_longest(self) -&gt; AsyncIter[Pair[Option[T]]]:\n        return self.create(async_pairs_longest(self.iterator))\n\n    def iter_windows(self, size: int) -&gt; AsyncIter[AsyncIter[T]]:\n        return self.create_nested(async_iter_windows(size, self.iterator))\n\n    def list_windows(self, size: int) -&gt; AsyncIter[List[T]]:\n        return self.create(async_list_windows(size, self.iterator))\n\n    def pairs_windows(self) -&gt; AsyncIter[Pair[T]]:\n        return self.create(async_pairs_windows(self.iterator))\n\n    @overload\n    def tuple_windows(self, size: Literal[0]) -&gt; AsyncIter[EmptyTuple]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[1]) -&gt; AsyncIter[Tuple1[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[2]) -&gt; AsyncIter[Tuple2[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[3]) -&gt; AsyncIter[Tuple3[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[4]) -&gt; AsyncIter[Tuple4[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[5]) -&gt; AsyncIter[Tuple5[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[6]) -&gt; AsyncIter[Tuple6[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[7]) -&gt; AsyncIter[Tuple7[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[8]) -&gt; AsyncIter[Tuple8[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: int) -&gt; AsyncIter[DynamicTuple[T]]:\n        ...\n\n    def tuple_windows(self, size: int) -&gt; AsyncIter[DynamicTuple[T]]:\n        return self.create(async_tuple_windows(size, self.iterator))\n\n    def set_windows(self: AsyncIter[Q], size: int) -&gt; AsyncIter[Set[Q]]:\n        return self.create(async_set_windows(size, self.iterator))\n\n    @overload\n    def apply_zip(self) -&gt; AsyncIter[Tuple[T]]:\n        ...\n\n    @overload\n    def apply_zip(self, __iterable_a: AnyIterable[A]) -&gt; AsyncIter[Tuple[T, A]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self, __iterable_a: AnyIterable[A], __iterable_b: AnyIterable[B]\n    ) -&gt; AsyncIter[Tuple[T, A, B]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D, E]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D, E, F]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D, E, F, G]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n        __iterable_h: AnyIterable[H],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D, E, F, G, H]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self,\n        __iterable_a: AnyIterable[Any],\n        __iterable_b: AnyIterable[Any],\n        __iterable_c: AnyIterable[Any],\n        __iterable_d: AnyIterable[Any],\n        __iterable_e: AnyIterable[Any],\n        __iterable_f: AnyIterable[Any],\n        __iterable_g: AnyIterable[Any],\n        __iterable_h: AnyIterable[Any],\n        __iterable_n: AnyIterable[Any],\n        *iterables: AnyIterable[Any],\n    ) -&gt; AsyncIter[DynamicTuple[Any]]:\n        ...\n\n    def apply_zip(self, *iterables: AnyIterable[Any]) -&gt; AsyncIter[DynamicTuple[Any]]:\n        return self.create(async_zip(self.iterator, *iterables))\n\n    zip = mixed_method(create_zip, apply_zip)\n\n    @overload\n    def apply_zip_equal(self) -&gt; AsyncIter[Tuple[T]]:\n        ...\n\n    @overload\n    def apply_zip_equal(self, __iterable_a: AnyIterable[A]) -&gt; AsyncIter[Tuple[T, A]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self, __iterable_a: AnyIterable[A], __iterable_b: AnyIterable[B]\n    ) -&gt; AsyncIter[Tuple[T, A, B]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D, E]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D, E, F]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D, E, F, G]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n        __iterable_h: AnyIterable[H],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D, E, F, G, H]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self,\n        __iterable_a: AnyIterable[Any],\n        __iterable_b: AnyIterable[Any],\n        __iterable_c: AnyIterable[Any],\n        __iterable_d: AnyIterable[Any],\n        __iterable_e: AnyIterable[Any],\n        __iterable_f: AnyIterable[Any],\n        __iterable_g: AnyIterable[Any],\n        __iterable_h: AnyIterable[Any],\n        __iterable_n: AnyIterable[Any],\n        *iterables: AnyIterable[Any],\n    ) -&gt; AsyncIter[DynamicTuple[Any]]:\n        ...\n\n    def apply_zip_equal(self, *iterables: AnyIterable[Any]) -&gt; AsyncIter[DynamicTuple[Any]]:\n        return self.create(async_zip_equal(self.iterator, *iterables))\n\n    zip_equal = mixed_method(create_zip_equal, apply_zip_equal)\n\n    @overload\n    def apply_zip_longest(self) -&gt; AsyncIter[Tuple[Option[T]]]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self, __iterable_a: AnyIterable[A]\n    ) -&gt; AsyncIter[Tuple[Option[T], Option[A]]]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self, __iterable_a: AnyIterable[A], __iterable_b: AnyIterable[B]\n    ) -&gt; AsyncIter[Tuple[Option[T], Option[A], Option[B]]]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n    ) -&gt; AsyncIter[Tuple[Option[T], Option[A], Option[B], Option[C]]]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n    ) -&gt; AsyncIter[Tuple[Option[T], Option[A], Option[B], Option[C], Option[D]]]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n    ) -&gt; AsyncIter[Tuple[Option[T], Option[A], Option[B], Option[C], Option[D], Option[E]]]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n    ) -&gt; AsyncIter[\n        Tuple[\n            Option[T],\n            Option[A],\n            Option[B],\n            Option[C],\n            Option[D],\n            Option[E],\n            Option[F],\n        ]\n    ]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n    ) -&gt; AsyncIter[\n        Tuple[\n            Option[T],\n            Option[A],\n            Option[B],\n            Option[C],\n            Option[D],\n            Option[E],\n            Option[F],\n            Option[G],\n        ]\n    ]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n        __iterable_h: AnyIterable[H],\n    ) -&gt; AsyncIter[\n        Tuple[\n            Option[T],\n            Option[A],\n            Option[B],\n            Option[C],\n            Option[D],\n            Option[E],\n            Option[F],\n            Option[G],\n            Option[H],\n        ]\n    ]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self,\n        __iterable_a: AnyIterable[Any],\n        __iterable_b: AnyIterable[Any],\n        __iterable_c: AnyIterable[Any],\n        __iterable_d: AnyIterable[Any],\n        __iterable_e: AnyIterable[Any],\n        __iterable_f: AnyIterable[Any],\n        __iterable_g: AnyIterable[Any],\n        __iterable_h: AnyIterable[Any],\n        __iterable_n: AnyIterable[Any],\n        *iterables: AnyIterable[Any],\n    ) -&gt; AsyncIter[DynamicTuple[Option[Any]]]:\n        ...\n\n    def apply_zip_longest(\n        self, *iterables: AnyIterable[Any]\n    ) -&gt; AsyncIter[DynamicTuple[Option[Any]]]:\n        return self.create(async_zip_longest(self.iterator, *iterables))\n\n    zip_longest = mixed_method(create_zip_longest, apply_zip_longest)\n\n    def transpose(self: AsyncIter[AnyIterable[T]]) -&gt; AsyncIter[DynamicTuple[T]]:\n        return self.create(async_transpose(self.iterator))\n\n    @overload\n    def apply_cartesian_product(self) -&gt; AsyncIter[Tuple[T]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(self, __iterable_a: AnyIterable[A]) -&gt; AsyncIter[Tuple[T, A]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self, __iterable_a: AnyIterable[A], __iterable_b: AnyIterable[B]\n    ) -&gt; AsyncIter[Tuple[T, A, B]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D, E]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D, E, F]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D, E, F, G]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self,\n        __iterable_a: AnyIterable[A],\n        __iterable_b: AnyIterable[B],\n        __iterable_c: AnyIterable[C],\n        __iterable_d: AnyIterable[D],\n        __iterable_e: AnyIterable[E],\n        __iterable_f: AnyIterable[F],\n        __iterable_g: AnyIterable[G],\n        __iterable_h: AnyIterable[H],\n    ) -&gt; AsyncIter[Tuple[T, A, B, C, D, E, F, G, H]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self,\n        __iterable_a: AnyIterable[Any],\n        __iterable_b: AnyIterable[Any],\n        __iterable_c: AnyIterable[Any],\n        __iterable_d: AnyIterable[Any],\n        __iterable_e: AnyIterable[Any],\n        __iterable_f: AnyIterable[Any],\n        __iterable_g: AnyIterable[Any],\n        __iterable_h: AnyIterable[Any],\n        __iterable_n: AnyIterable[Any],\n        *iterables: AnyIterable[Any],\n    ) -&gt; AsyncIter[DynamicTuple[Any]]:\n        ...\n\n    def apply_cartesian_product(self, *iterables: AnyIterable[Any]) -&gt; AsyncIter[DynamicTuple[Any]]:\n        return self.create(async_cartesian_product(self.iterator, *iterables))\n\n    cartesian_product = mixed_method(create_cartesian_product, apply_cartesian_product)\n\n    @overload\n    def cartesian_power(self, power: Literal[0]) -&gt; AsyncIter[EmptyTuple]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[1]) -&gt; AsyncIter[Tuple1[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[2]) -&gt; AsyncIter[Tuple2[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[3]) -&gt; AsyncIter[Tuple3[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[4]) -&gt; AsyncIter[Tuple4[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[5]) -&gt; AsyncIter[Tuple5[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[6]) -&gt; AsyncIter[Tuple6[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[7]) -&gt; AsyncIter[Tuple7[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[8]) -&gt; AsyncIter[Tuple8[T]]:\n        ...\n\n    def cartesian_power(self, power: int) -&gt; AsyncIter[DynamicTuple[T]]:\n        return self.create(async_cartesian_power(power, self.iterator))\n\n    @overload\n    def combinations(self, count: Literal[0]) -&gt; AsyncIter[EmptyTuple]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[1]) -&gt; AsyncIter[Tuple1[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[2]) -&gt; AsyncIter[Tuple2[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[3]) -&gt; AsyncIter[Tuple3[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[4]) -&gt; AsyncIter[Tuple4[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[5]) -&gt; AsyncIter[Tuple5[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[6]) -&gt; AsyncIter[Tuple6[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[7]) -&gt; AsyncIter[Tuple7[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[8]) -&gt; AsyncIter[Tuple8[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: int) -&gt; AsyncIter[DynamicTuple[T]]:\n        ...\n\n    def combinations(self, count: int) -&gt; AsyncIter[DynamicTuple[T]]:\n        return self.create(async_combinations(count, self.iterator))\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[0]) -&gt; AsyncIter[EmptyTuple]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[1]) -&gt; AsyncIter[Tuple1[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[2]) -&gt; AsyncIter[Tuple2[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[3]) -&gt; AsyncIter[Tuple3[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[4]) -&gt; AsyncIter[Tuple4[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[5]) -&gt; AsyncIter[Tuple5[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[6]) -&gt; AsyncIter[Tuple6[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[7]) -&gt; AsyncIter[Tuple7[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[8]) -&gt; AsyncIter[Tuple8[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: int) -&gt; AsyncIter[DynamicTuple[T]]:\n        ...\n\n    def combinations_with_replacement(self, count: int) -&gt; AsyncIter[DynamicTuple[T]]:\n        return self.create(async_combinations_with_replacement(count, self.iterator))\n\n    def permute(self) -&gt; AsyncIter[DynamicTuple[T]]:\n        return self.create(async_permute(self.iterator))\n\n    @overload\n    def permutations(self, count: Literal[0]) -&gt; AsyncIter[EmptyTuple]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[1]) -&gt; AsyncIter[Tuple1[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[2]) -&gt; AsyncIter[Tuple2[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[3]) -&gt; AsyncIter[Tuple3[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[4]) -&gt; AsyncIter[Tuple4[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[5]) -&gt; AsyncIter[Tuple5[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[6]) -&gt; AsyncIter[Tuple6[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[7]) -&gt; AsyncIter[Tuple7[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[8]) -&gt; AsyncIter[Tuple8[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: int) -&gt; AsyncIter[DynamicTuple[T]]:\n        ...\n\n    def permutations(self, count: int) -&gt; AsyncIter[DynamicTuple[T]]:\n        return self.create(async_permutations(count, self.iterator))\n\n    def power_set(self) -&gt; AsyncIter[DynamicTuple[T]]:\n        return self.create(async_power_set(self.iterator))\n\n    def reverse(self) -&gt; AsyncIter[T]:\n        return self.create(async_reverse(self.iterator))\n\n    @wrap_future\n    async def sorted(self: AsyncIter[ST]) -&gt; List[ST]:\n        return await async_sorted(self.iterator)\n\n    @wrap_future\n    async def sorted_by(self, key: Unary[T, ST]) -&gt; List[T]:\n        return await async_sorted(self.iterator, key=key)\n\n    @wrap_future\n    async def sorted_reverse(self: AsyncIter[ST]) -&gt; List[ST]:\n        return await async_sorted(self.iterator, reverse=True)\n\n    @wrap_future\n    async def sorted_reverse_by(self, key: Unary[T, ST]) -&gt; List[T]:\n        return await async_sorted(self.iterator, key=key, reverse=True)\n\n    @wrap_future\n    async def sorted_by_await(self, key: AsyncUnary[T, ST]) -&gt; List[T]:\n        return await async_sorted_await(self.iterator, key=key)\n\n    @wrap_future\n    async def sorted_reverse_by_await(self, key: AsyncUnary[T, ST]) -&gt; List[T]:\n        return await async_sorted_await(self.iterator, key=key, reverse=True)\n\n    def sort(self: AsyncIter[ST]) -&gt; AsyncIter[ST]:\n        return self.create(async_sort(self.iterator))\n\n    def sort_by(self, key: Unary[T, ST]) -&gt; AsyncIter[T]:\n        return self.create(async_sort(self.iterator, key=key))\n\n    def sort_reverse(self: AsyncIter[ST]) -&gt; AsyncIter[ST]:\n        return self.create(async_sort(self.iterator, reverse=True))\n\n    def sort_reverse_by(self, key: Unary[T, ST]) -&gt; AsyncIter[T]:\n        return self.create(async_sort(self.iterator, key=key, reverse=True))\n\n    def sort_by_await(self, key: AsyncUnary[T, ST]) -&gt; AsyncIter[T]:\n        return self.create(async_sort_await(self.iterator, key=key))\n\n    def sort_reverse_by_await(self, key: AsyncUnary[T, ST]) -&gt; AsyncIter[T]:\n        return self.create(async_sort_await(self.iterator, key=key, reverse=True))\n\n    @wrap_future\n    async def is_sorted(self: AsyncIter[LT]) -&gt; bool:\n        return await async_is_sorted(self.iterator)\n\n    @wrap_future\n    async def is_sorted_by(self, key: Unary[T, LT]) -&gt; bool:\n        return await async_is_sorted(self.iterator, key)\n\n    @wrap_future\n    async def is_sorted_reverse(self: AsyncIter[LT]) -&gt; bool:\n        return await async_is_sorted(self.iterator, reverse=True)\n\n    @wrap_future\n    async def is_sorted_reverse_by(self, key: Unary[T, LT]) -&gt; bool:\n        return await async_is_sorted(self.iterator, key, reverse=True)\n\n    @wrap_future\n    async def is_sorted_strict(self: AsyncIter[ST]) -&gt; bool:\n        return await async_is_sorted(self.iterator, strict=True)\n\n    @wrap_future\n    async def is_sorted_strict_by(self, key: Unary[T, ST]) -&gt; bool:\n        return await async_is_sorted(self.iterator, key, strict=True)\n\n    @wrap_future\n    async def is_sorted_reverse_strict(self: AsyncIter[ST]) -&gt; bool:\n        return await async_is_sorted(self.iterator, strict=True, reverse=True)\n\n    @wrap_future\n    async def is_sorted_reverse_strict_by(self, key: Unary[T, ST]) -&gt; bool:\n        return await async_is_sorted(self.iterator, key, strict=True, reverse=True)\n\n    @wrap_future\n    async def is_sorted_by_await(self, key: AsyncUnary[T, LT]) -&gt; bool:\n        return await async_is_sorted_await(self.iterator, key)\n\n    @wrap_future\n    async def is_sorted_reverse_by_await(self, key: AsyncUnary[T, LT]) -&gt; bool:\n        return await async_is_sorted_await(self.iterator, key, reverse=True)\n\n    @wrap_future\n    async def is_sorted_strict_by_await(self, key: AsyncUnary[T, ST]) -&gt; bool:\n        return await async_is_sorted_await(self.iterator, key, strict=True)\n\n    @wrap_future\n    async def is_sorted_reverse_strict_by_await(self, key: AsyncUnary[T, ST]) -&gt; bool:\n        return await async_is_sorted_await(self.iterator, key, strict=True, reverse=True)\n\n    def duplicates_fast(self: AsyncIter[Q]) -&gt; AsyncIter[Q]:\n        return self.create(async_duplicates_fast(self.iterator))\n\n    def duplicates_fast_by(self, key: Unary[T, Q]) -&gt; AsyncIter[T]:\n        return self.create(async_duplicates_fast(self.iterator, key))\n\n    def duplicates_fast_by_await(self, key: AsyncUnary[T, Q]) -&gt; AsyncIter[T]:\n        return self.create(async_duplicates_fast_await(self.iterator, key))\n\n    def duplicates(self) -&gt; AsyncIter[T]:\n        return self.create(async_duplicates(self.iterator))\n\n    def duplicates_by(self, key: Unary[T, V]) -&gt; AsyncIter[T]:\n        return self.create(async_duplicates(self.iterator, key))\n\n    def duplicates_by_await(self, key: AsyncUnary[T, V]) -&gt; AsyncIter[T]:\n        return self.create(async_duplicates_await(self.iterator, key))\n\n    def unique_fast(self: AsyncIter[Q]) -&gt; AsyncIter[Q]:\n        return self.create(async_unique_fast(self.iterator))\n\n    def unique_fast_by(self, key: Unary[T, Q]) -&gt; AsyncIter[T]:\n        return self.create(async_unique_fast(self.iterator, key))\n\n    def unique_fast_by_await(self, key: AsyncUnary[T, Q]) -&gt; AsyncIter[T]:\n        return self.create(async_unique_fast_await(self.iterator, key))\n\n    def unique(self) -&gt; AsyncIter[T]:\n        return self.create(async_unique(self.iterator))\n\n    def unique_by(self, key: Unary[T, V]) -&gt; AsyncIter[T]:\n        return self.create(async_unique(self.iterator, key))\n\n    def unique_by_await(self, key: AsyncUnary[T, V]) -&gt; AsyncIter[T]:\n        return self.create(async_unique_await(self.iterator, key))\n\n    def partition(self, predicate: Optional[Predicate[T]]) -&gt; Pair[AsyncIter[T]]:\n        true, false = async_partition(predicate, self.iterator)\n\n        return (self.create(true), self.create(false))\n\n    def partition_await(self, predicate: AsyncPredicate[T]) -&gt; Pair[AsyncIter[T]]:\n        true, false = async_partition_await(predicate, self.iterator)\n\n        return (self.create(true), self.create(false))\n\n    def partition_unsafe(self, predicate: Optional[Predicate[T]]) -&gt; Pair[AsyncIter[T]]:\n        true, false = async_partition_unsafe(predicate, self.iterator)\n\n        return (self.create(true), self.create(false))\n\n    partition_infinite = partition_unsafe\n\n    def partition_unsafe_await(self, predicate: AsyncPredicate[T]) -&gt; Pair[AsyncIter[T]]:\n        true, false = async_partition_unsafe_await(predicate, self.iterator)\n\n        return (self.create(true), self.create(false))\n\n    partition_infinite_await = partition_unsafe_await\n\n    def copy(self) -&gt; AsyncIter[T]:\n        iterator, result = async_copy(self.iterator)\n\n        self._replace(iterator)\n\n        return self.create(result)\n\n    def copy_unsafe(self) -&gt; AsyncIter[T]:\n        iterator, result = async_copy_unsafe(self.iterator)\n\n        self._replace(iterator)\n\n        return self.create(result)\n\n    copy_infinite = copy_unsafe\n\n    @wrap_future\n    async def spy(self, size: int) -&gt; List[T]:\n        result, iterator = await async_spy(size, self.iterator)\n\n        self._replace(iterator)\n\n        return result\n\n    @wrap_future_option\n    async def peek(self) -&gt; Option[T]:\n        item, iterator = await async_peek(self.iterator, marker)\n\n        self._replace(iterator)\n\n        return wrap_marked(item)\n\n    @wrap_future\n    async def has_next(self) -&gt; bool:\n        result, iterator = await async_has_next(self.iterator)\n\n        self._replace(iterator)\n\n        return result\n\n    @wrap_future\n    async def is_empty(self) -&gt; bool:\n        result, iterator = await async_is_empty(self.iterator)\n\n        self._replace(iterator)\n\n        return result\n\n    def repeat_last(self) -&gt; AsyncIter[T]:\n        return self.create(async_repeat_last(self.iterator))\n\n    def repeat_each(self, count: int) -&gt; AsyncIter[T]:\n        return self.create(async_repeat_each(count, self.iterator))\n\n    def inspect(self, function: Inspect[T]) -&gt; AsyncIter[T]:\n        return self.create(async_inspect(function, self.iterator))\n\n    def inspect_await(self, function: AsyncInspect[T]) -&gt; AsyncIter[T]:\n        return self.create(async_inspect_await(function, self.iterator))\n\n    def wait(self: AsyncIter[Awaitable[U]]) -&gt; AsyncIter[U]:\n        return self.create(async_wait(self.iterator))\n\n    def wait_concurrent(self: AsyncIter[Awaitable[U]]) -&gt; AsyncIter[U]:\n        return self.create(async_wait_concurrent(self.iterator))\n\n    def wait_concurrent_bound(self: AsyncIter[Awaitable[U]], bound: int) -&gt; AsyncIter[U]:\n        return self.create(async_wait_concurrent_bound(bound, self.iterator))\n\n    @wrap_future\n    async def into_iter(self) -&gt; Iter[T]:\n        return iter(await self.extract())\n</code></pre>"},{"location":"reference/async_iters/#iters.async_iters.AsyncIter.iterator","title":"<code>iterator: AsyncIterator[T]</code>  <code>property</code>","text":"<p>The underlying iterator.</p>"},{"location":"reference/async_utils/","title":"Async Utilities","text":""},{"location":"reference/iters/","title":"Iterators","text":""},{"location":"reference/iters/#iters.iters.iter","title":"<code>iter = Iter</code>  <code>module-attribute</code>","text":"<p>An alias of <code>Iter</code>.</p>"},{"location":"reference/iters/#iters.iters.reversed","title":"<code>reversed = iter.reversed</code>  <code>module-attribute</code>","text":"<p>An alias of <code>iter.reversed</code>.</p>"},{"location":"reference/iters/#iters.iters.Iter","title":"<code>Iter</code>","text":"<p>         Bases: <code>Iterator[T]</code></p> <p>Represents iterators.</p> Source code in <code>iters/iters.py</code> <pre><code>class Iter(Iterator[T]):\n\"\"\"Represents iterators.\"\"\"\n\n    # internals\n\n    _iterator: Iterator[T]\n\n    def __init__(self, iterable: Iterable[T]) -&gt; None:\n        self._iterator = standard_iter(iterable)\n\n    def _replace(self, iterator: Iterator[T]) -&gt; None:\n        self._iterator = iterator\n\n    # implementation\n\n    @property\n    def iterator(self) -&gt; Iterator[T]:\n\"\"\"The underlying iterator.\"\"\"\n        return self._iterator\n\n    @classmethod\n    def empty(cls) -&gt; Iter[T]:\n\"\"\"Creates an empty iterator.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; iterator = iter.empty()\n            &gt;&gt;&gt; iterator.next()\n            Null()\n            ```\n\n        Returns:\n            An empty iterator.\n        \"\"\"\n        return cls.create(empty())\n\n    @classmethod\n    def of(cls, *items: V) -&gt; Iter[V]:\n\"\"\"Creates an iterator from `items`.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; iterator = iter.of(13, 42, 69)\n            &gt;&gt;&gt; iterator.next()\n            Some(13)\n            &gt;&gt;&gt; iterator.next()\n            Some(42)\n            &gt;&gt;&gt; iterator.next()\n            Some(69)\n            &gt;&gt;&gt; iterator.next()\n            Null()\n            ```\n\n        Arguments:\n            *items: The items to iterate over.\n\n        Returns:\n            An iterator over `items`.\n        \"\"\"\n        return cls.create(items)\n\n    @classmethod\n    def once(cls, value: V) -&gt; Iter[V]:\n\"\"\"Creates an iterator that yields the `value` exactly once.\n\n        This is commonly used to adapt a single value into a [`chain`][iters.iters.Iter.chain]\n        of other kinds of iteration. Maybe you have an iterator that covers almost everything,\n        but you need an extra special case. Maybe you have a function which works on iterators,\n        but you only need to process one value.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; iterator = iter.once(42)\n            &gt;&gt;&gt; iterator.next()\n            Some(42)\n            &gt;&gt;&gt; iterator.next()\n            Null()\n            ```\n\n        Arguments:\n            value: The value to yield.\n\n        Returns:\n            An [`Iter[V]`][iters.iters.Iter] with `value`.\n        \"\"\"\n        return cls.create(once(value))\n\n    @classmethod\n    def once_with(cls, function: Nullary[V]) -&gt; Iter[V]:\n\"\"\"Creates an iterator that lazily generates an item exactly once\n        by invoking the `function` provided.\n\n        This is commonly used to adapt a single value into a [`chain`][iters.iters.Iter.chain]\n        of other kinds of iteration. Maybe you have an iterator that covers almost everything,\n        but you need an extra special case. Maybe you have a function which works on iterators,\n        but you only need to process one value.\n\n        Unlike [`once`][iters.iters.Iter.once], this function will\n        lazily generate the item on request.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; iterator = iter.once_with(tuple)\n            &gt;&gt;&gt; iterator.next()\n            Some(())\n            &gt;&gt;&gt; iterator.next()\n            Null()\n            ```\n\n        Arguments:\n            function: The value-generating function to use.\n\n        Returns:\n            An [`Iter[V]`][iters.iters.Iter] with the generated `value`.\n        \"\"\"\n        return cls.create(once_with(function))\n\n    @classmethod\n    def repeat(cls, value: V) -&gt; Iter[V]:\n\"\"\"Creates an iterator that endlessly repeats a single `value`.\n\n        This function repeats a single value over and over again.\n\n        Infinite iterators like [`repeat`][iters.iters.Iter.repeat]\n        are often used with adapters like [`take`][iters.iters.Iter.take],\n        in order to make them finite.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; fours = iter.repeat(4)\n            &gt;&gt;&gt; fours.next()\n            Some(4)\n            &gt;&gt;&gt; fours.next()\n            Some(4)\n            &gt;&gt;&gt; fours.next()\n            Some(4)\n            &gt;&gt;&gt; # ad infinitum...\n            ```\n\n        Arguments:\n            value: The value to repeat.\n\n        Returns:\n            An infinite [`Iter[V]`][iters.iters.Iter] with repeated `value`.\n        \"\"\"\n        return cls.create(repeat(value))\n\n    @classmethod\n    def repeat_exactly(cls, value: V, count: int) -&gt; Iter[V]:\n\"\"\"Creates an iterator that repeats a single `value` exactly `count` times.\n\n        This function is a shorthand for [`iter.repeat(value).take(count)`][iters.iters.Iter.take].\n\n        Example:\n            ```python\n            # let's only have four fours\n            iterator = iter.repeat_exactly(4, 4)\n\n            assert iterator.list() == [4, 4, 4, 4]\n            ```\n\n        Arguments:\n            value: The value to repeat.\n            count: The number of times to repeat the `value`.\n\n        Returns:\n            An [`Iter[V]`][iters.iters.Iter] with `value` repeated `count` times.\n        \"\"\"\n        return cls.create(repeat(value, count))\n\n    @classmethod\n    def repeat_with(cls, function: Nullary[V]) -&gt; Iter[V]:\n\"\"\"Creates an iterator that endlessly generates values.\n\n        This function repeats generated values over and over again.\n\n        Infinite iterators like [`repeat_with`][iters.iters.Iter.repeat_with]\n        are often used with adapters like [`take`][iters.iters.Iter.take],\n        in order to make them finite.\n\n        Example:\n            ```python\n            iterator = iter.repeat_with(tuple)\n\n            assert iterator.next().unwrap() == ()\n            assert iterator.next().unwrap() == ()\n            assert iterator.next().unwrap() == ()\n\n            # ... ad infinitum\n            ```\n\n        Arguments:\n            function: The value-generating function to use.\n\n        Returns:\n            An infinite [`Iter[V]`][iters.iters.Iter] with repeated `value` of type `V`.\n        \"\"\"\n        return cls.create(repeat_with(function))\n\n    @classmethod\n    def repeat_exactly_with(cls, function: Nullary[V], count: int) -&gt; Iter[V]:\n\"\"\"Creates an iterator that generates values of type `V` exactly `count` times.\n\n        This function is a shorthand for\n        [`iter.repeat_with(function).take(count)`][iters.iters.Iter.take].\n\n        Example:\n            ```python\n            assert iter.repeat_exactly_with(tuple, 3).tuple() == ((), (), ())  # tuple triple!\n            ```\n\n        Arguments:\n            function: The value-generating function to use.\n            count: The number of times to repeat values.\n\n        Returns:\n            An [`Iter[V]`][iters.iters.Iter] with repeated\n                `value` of type `V` exactly `count` times.\n        \"\"\"\n        return cls.create(repeat_with(function, count))\n\n    @classmethod\n    def count_from_by(cls, start: int, step: int) -&gt; Iter[int]:\n\"\"\"Creates an iterator of evenly spaced (by `step`) values starting from `start`.\n\n        Example:\n            ```python\n            iterator = iter.count_from_by(1, 2)\n\n            assert iterator.next() == 1\n            assert iterator.next() == 3\n            assert iterator.next() == 5\n            assert iterator.next() == 7\n            assert iterator.next() == 9\n            ```\n\n        Arguments:\n            start: The value to start from.\n            step: The value to step by.\n\n        Returns:\n            An [`Iter[int]`][iters.iters.Iter] over evenly spaced values.\n        \"\"\"\n        return cls.create(count(start, step))\n\n    @classmethod\n    def count_from(cls, start: int) -&gt; Iter[int]:\n\"\"\"Creates an iterator of evenly spaced (by `1`) values starting from `start`.\n\n        This is a shorthand for:\n\n        ```python\n        iter.count_from_by(start, 1)\n        ```\n\n        Arguments:\n            start: The value to start from.\n\n        Returns:\n            An [`Iter[int]`][iters.iters.Iter] over evenly spaced values.\n        \"\"\"\n        return cls.count_from_by(start, DEFAULT_STEP)\n\n    @classmethod\n    def count_by(cls, step: int) -&gt; Iter[int]:\n\"\"\"Creates an iterator of evenly spaced (by `step`) values starting from `0`.\n\n        This is a shorthand for:\n\n        ```python\n        iter.count_from_by(0, step)\n        ```\n\n        Arguments:\n            step: The value to step by.\n\n        Returns:\n            An [`Iter[int]`][iters.iters.Iter] over evenly spaced values.\n        \"\"\"\n        return cls.count_from_by(DEFAULT_START, step)\n\n    @classmethod\n    def count(cls) -&gt; Iter[int]:\n\"\"\"Creates an iterator of evenly spaced (by `1`) values starting from `0`.\n\n        This is a shorthand for:\n\n        ```python\n        iter.count_from_by(0, 1)\n        ```\n\n        Returns:\n            An [`Iter[int]`][iters.iters.Iter] over evenly spaced values.\n        \"\"\"\n        return cls.count_from_by(DEFAULT_START, DEFAULT_STEP)\n\n    @classmethod\n    def iterate(cls, function: Unary[V, V], value: V) -&gt; Iter[V]:\n\"\"\"Creates an iterator that iterates function calls endlessly, i.e. `value`,\n        `function(value)`, `function(function(value))`, ...\n\n        Example:\n            ```python\n            zero = 0\n\n            def successor(natural: int) -&gt; int:\n                return natural + 1\n\n            naturals = iter.iterate(successor, zero)\n            ```\n\n        Arguments:\n            function: The function to iterate.\n            value: The value to begin iteration with.\n\n        Returns:\n            An [`Iter[V]`][iters.iters.Iter] over iteration results.\n        \"\"\"\n        return cls.create(iterate(function, value))\n\n    @classmethod\n    def iterate_exactly(cls, function: Unary[V, V], value: V, count: int) -&gt; Iter[V]:\n\"\"\"Creates an iterator that iterates function calls exactly `count` times.\n\n        This is a shorthand for\n        [`iter.iterate(function, value).take(count)`][iters.iters.Iter.take].\n\n        Example:\n            ```python\n            def wrap(item: T) -&gt; List[T]:\n                return [item]\n\n            iter.iterate_exactly(wrap, 13, 5).list() == [\n                13, [13], [[13]], [[[13]]], [[[[13]]]]\n            ]\n            ```\n\n        Arguments:\n            function: The function to iterate.\n            value: The value to begin iteration with.\n            count: The amount of function iterations.\n\n        Returns:\n            An [`Iter[V]`][iters.iters.Iter] over iteration results.\n        \"\"\"\n        return cls.create(iterate(function, value, count))\n\n    @classmethod\n    def iter_except(cls, function: Nullary[T], *errors: AnyErrorType) -&gt; Iter[T]:\n\"\"\"Creates an iterator that repeatedly calls `function` until\n        any of the `errors` is encountered.\n\n        Example:\n            An interesting way to reverse arrays:\n\n            ```python\n            array = [1, 2, 3]\n\n            iter.iter_except(array.pop, IndexError).list() == [3, 2, 1]\n            ```\n\n        Arguments:\n            function: The function to iterate.\n            *errors: The errors to `except`, stopping iteration.\n\n        Returns:\n            An [`Iter[T]`][iters.iters.Iter] over function results.\n        \"\"\"\n        return cls.create(iter_except(function, *errors))\n\n    @classmethod\n    def iter_with(cls, context_manager: ContextManager[Iterable[T]]) -&gt; Iter[T]:\n\"\"\"Creates an iterator over the iterable returned by `context_manager`.\n\n        This is essentially equivalent to:\n\n        ```python\n        def iter_with(context_manager: ContextManager[Iterable[T]]) -&gt; Iterator[T]:\n            with context_manager as iterable:\n                for item in iterable:\n                    yield item\n\n        iterator = iter(iter_with(context_manager))\n        ```\n\n        This function can be used to open and close files, for example;\n        let us consider parsing some file containing integers on every line.\n\n        Example:\n            ```python\n            array = iter.iter_with(open(\"file.in\")).map(int).list()\n            ```\n\n        Arguments:\n            context_manager: The context manager returning an iterable.\n\n        Returns:\n            An [`Iter[T]`][iters.iters.Iter] over items in an iterable.\n        \"\"\"\n        return cls.create(iter_with(context_manager))\n\n    @classmethod\n    def create_chain(cls, *iterables: Iterable[T]) -&gt; Iter[T]:\n\"\"\"Creates an iterator chaining `iterables` together.\n\n        For example, it can be used to chain arrays.\n\n        Example:\n            ```python\n            a = [1, 2, 3]\n            b = [4, 5, 6]\n            c = [7, 8, 9]\n\n            assert iter.create_chain(a, b, c).list() == a + b + c\n            ```\n\n        Arguments:\n            *iterables: Iterables to chain together.\n\n        Returns:\n            An [`Iter[T]`][iters.iters.Iter] over chained iterables.\n        \"\"\"\n        return cls.create(chain(*iterables))\n\n    @classmethod\n    def create_chain_with(cls, iterable: Iterable[Iterable[T]]) -&gt; Iter[T]:\n\"\"\"Creates an iterator chaining iterables in the `iterable` together.\n\n        This function essentially flattens the `iterable` provided.\n\n        Example:\n            ```python\n            matrix = [\n                [1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9],\n            ]\n\n            result = 45\n\n            assert iter.create_chain_with(matrix).sum() == result\n            ```\n\n        Arguments:\n            iterable: The iterable of iterables to chain.\n\n        Returns:\n            An [`Iter[T]`][iters.iters.Iter] over chained iterables.\n        \"\"\"\n        return cls.create(chain_from_iterable(iterable))\n\n    @classmethod\n    def create_combine(cls, *iterables: Iterable[T]) -&gt; Iter[T]:\n\"\"\"Creates an iterator combining `iterables`.\n\n        This method is a slightly different version of\n        [`create_interleave_longest`][iters.iters.Iter.create_interleave_longest].\n\n        Example:\n            ```python\n            a = [1, 2, 3]\n            b = [4, 5, 6]\n            c = [1, 4, 2, 5, 3, 6]\n\n            assert iter.combine(a, b).list() == c\n            ```\n\n        Arguments:\n            *iterables: Iterables to combine.\n\n        Returns:\n            An [`Iter[T]`][iters.iters.Iter] over combined iterables.\n        \"\"\"\n        return cls.create(combine(*iterables))\n\n    @classmethod\n    def create_interleave(cls, *iterables: Iterable[T]) -&gt; Iter[T]:\n\"\"\"Creates an iterator interleaving `iterables`.\n\n        Note:\n            This method stops when the shortest iterable is exhausted.\n\n        Example:\n            ```python\n            a = [1, 2, 3]\n            b = [4, 5, 6, 7, 8, 9]\n            c = [1, 4, 2, 5, 3, 6]\n\n            assert iter.create_interleave(a, b).list() == c\n            ```\n\n        Arguments:\n            *iterables: Iterables to interleave.\n\n        Returns:\n            An [`Iter[T]`][iters.iters.Iter] over interleft iterables.\n        \"\"\"\n        return cls.create(interleave(*iterables))\n\n    @classmethod\n    def create_interleave_longest(cls, *iterables: Iterable[T]) -&gt; Iter[T]:\n\"\"\"Creates an iterator interleaving `iterables`.\n\n        This method is a slightly different version of\n        [`create_combine`][iters.iters.Iter.create_combine].\n\n        Example:\n            ```python\n            a = [1, 2, 3]\n            b = [4, 5, 6, 7, 8, 9]\n            c = [1, 4, 2, 5, 3, 6, 7, 8, 9]\n\n            assert iter.create_interleave_longest(a, b).list() == c\n            ```\n\n        Arguments:\n            *iterables: Iterables to interleave.\n\n        Returns:\n            An [`Iter[T]`][iters.iters.Iter] over interleft iterables.\n        \"\"\"\n        return cls.create(interleave_longest(*iterables))\n\n    @overload\n    @classmethod\n    def create_zip(cls) -&gt; Iter[T]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(cls, __iterable_a: Iterable[A]) -&gt; Iter[Tuple[A]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(cls, __iterable_a: Iterable[A], __iterable_b: Iterable[B]) -&gt; Iter[Tuple[A, B]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls, __iterable_a: Iterable[A], __iterable_b: Iterable[B], __iterable_c: Iterable[C]\n    ) -&gt; Iter[Tuple[A, B, C]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n    ) -&gt; Iter[Tuple[A, B, C, D]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n    ) -&gt; Iter[Tuple[A, B, C, D, E]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n    ) -&gt; Iter[Tuple[A, B, C, D, E, F]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n    ) -&gt; Iter[Tuple[A, B, C, D, E, F, G]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n        __iterable_h: Iterable[H],\n    ) -&gt; Iter[Tuple[A, B, C, D, E, F, G, H]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip(\n        cls,\n        __iterable_a: Iterable[Any],\n        __iterable_b: Iterable[Any],\n        __iterable_c: Iterable[Any],\n        __iterable_d: Iterable[Any],\n        __iterable_e: Iterable[Any],\n        __iterable_f: Iterable[Any],\n        __iterable_g: Iterable[Any],\n        __iterable_h: Iterable[Any],\n        __iterable_n: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -&gt; Iter[DynamicTuple[Any]]:\n        ...\n\n    @no_type_check\n    @classmethod\n    def create_zip(cls, *iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Any]]:\n\"\"\"Zips `iterables` into an iterator of tuples, where\n        the *i*-th tuple contains the *i*-th item from each of the iterables.\n\n        Note:\n            This method stops when the shortest iterable is exhausted.\n\n        Example:\n            ```python\n            x = (1, 2, 3, 4, 5)\n\n            y = \"nekit\"\n\n            iter.create_zip(x, y).list() == [(1, \"n\"), (2, \"e\"), (3, \"k\"), (4, \"i\"), (5, \"t\")]\n            ```\n\n        Arguments:\n            *iterables: Iterables to zip.\n\n        Returns:\n            An [`Iter[Tuple[...]]`][iters.iters.Iter] over zipped tuples.\n        \"\"\"\n        return cls.create(zip(*iterables))\n\n    @overload\n    @classmethod\n    def create_zip_equal(cls) -&gt; Iter[T]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(cls, __iterable_a: Iterable[A]) -&gt; Iter[Tuple[A]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls, __iterable_a: Iterable[A], __iterable_b: Iterable[B]\n    ) -&gt; Iter[Tuple[A, B]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls, __iterable_a: Iterable[A], __iterable_b: Iterable[B], __iterable_c: Iterable[C]\n    ) -&gt; Iter[Tuple[A, B, C]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n    ) -&gt; Iter[Tuple[A, B, C, D]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n    ) -&gt; Iter[Tuple[A, B, C, D, E]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n    ) -&gt; Iter[Tuple[A, B, C, D, E, F]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n    ) -&gt; Iter[Tuple[A, B, C, D, E, F, G]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n        __iterable_h: Iterable[H],\n    ) -&gt; Iter[Tuple[A, B, C, D, E, F, G, H]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_equal(\n        cls,\n        __iterable_a: Iterable[Any],\n        __iterable_b: Iterable[Any],\n        __iterable_c: Iterable[Any],\n        __iterable_d: Iterable[Any],\n        __iterable_e: Iterable[Any],\n        __iterable_f: Iterable[Any],\n        __iterable_g: Iterable[Any],\n        __iterable_h: Iterable[Any],\n        __iterable_n: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -&gt; Iter[DynamicTuple[Any]]:\n        ...\n\n    @no_type_check\n    @classmethod\n    def create_zip_equal(cls, *iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Any]]:\n\"\"\"Zips `iterables` into an iterator of tuples, where\n        the *i*-th tuple contains the *i*-th item from each of the iterables.\n\n        This is the strict version of [`create_zip`][iters.iters.Iter.create_zip].\n\n        Example:\n            ```python\n            x = (1, 2, 3)\n\n            y = \"dev\"\n\n            iter.create_zip_equal(x, y).list() == [(1, \"d\"), (2, \"e\"), (3, \"v\")]\n            ```\n\n        Arguments:\n            *iterables: Iterables to zip.\n\n        Raises:\n            ValueError: Iterables have different lengths.\n\n        Returns:\n            An [`Iter[Tuple[...]]`][iters.iters.Iter] over zipped tuples.\n        \"\"\"\n        return cls.create(zip_equal(*iterables))\n\n    @overload\n    @classmethod\n    def create_zip_longest(cls) -&gt; Iter[T]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(cls, __iterable_a: Iterable[A]) -&gt; Iter[Tuple[Option[A]]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls, __iterable_a: Iterable[A], __iterable_b: Iterable[B]\n    ) -&gt; Iter[Tuple[Option[A], Option[B]]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls, __iterable_a: Iterable[A], __iterable_b: Iterable[B], __iterable_c: Iterable[C]\n    ) -&gt; Iter[Tuple[Option[A], Option[B], Option[C]]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n    ) -&gt; Iter[Tuple[Option[A], Option[B], Option[C], Option[D]]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n    ) -&gt; Iter[Tuple[Option[A], Option[B], Option[C], Option[D], Option[E]]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n    ) -&gt; Iter[Tuple[Option[A], Option[B], Option[C], Option[D], Option[E], Option[F]]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n    ) -&gt; Iter[Tuple[Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G],]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n        __iterable_h: Iterable[H],\n    ) -&gt; Iter[\n        Tuple[\n            Option[A],\n            Option[B],\n            Option[C],\n            Option[D],\n            Option[E],\n            Option[F],\n            Option[G],\n            Option[H],\n        ]\n    ]:\n        ...\n\n    @overload\n    @classmethod\n    def create_zip_longest(\n        cls,\n        __iterable_a: Iterable[Any],\n        __iterable_b: Iterable[Any],\n        __iterable_c: Iterable[Any],\n        __iterable_d: Iterable[Any],\n        __iterable_e: Iterable[Any],\n        __iterable_f: Iterable[Any],\n        __iterable_g: Iterable[Any],\n        __iterable_h: Iterable[Any],\n        __iterable_n: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -&gt; Iter[DynamicTuple[Option[Any]]]:\n        ...\n\n    @no_type_check\n    @classmethod\n    def create_zip_longest(cls, *iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Option[Any]]]:\n\"\"\"Zips `iterables` into an iterator of tuples, where\n        the *i*-th tuple contains the *i*-th item from each of the iterables.\n\n        This is a version of [`create_zip`][iters.iters.Iter.create_zip] that places [`None`][None]\n        in place of a *j*-th item of an *i*-th tuple when a *j*-th iterable is exhausted.\n\n        Example:\n            ```python\n            x = (1, 2, 3, 4)\n\n            y = \"dev\"\n\n            f = \"x\"\n\n            def process(a: Option[int], b: Option[str]) -&gt; Tuple[int, str]:\n                return (a.unwrap_or(0), b.unwrap_or(f))\n\n            assert (\n                iter.create_zip_longest(x, y)\n                .map(unpack_binary(process))\n                .list()\n            ) == [(1, \"d\"), (2, \"e\"), (3, \"v\"), (4, \"x\")]\n            ```\n\n        Arguments:\n            *iterables: Iterables to zip.\n\n        Returns:\n            An [`Iter[Tuple[...]]`][iters.iters.Iter] over zipped tuples.\n        \"\"\"\n        return cls.create(zip_longest(*iterables))\n\n    @overload\n    @classmethod\n    def create_cartesian_product(cls) -&gt; Iter[EmptyTuple]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(cls, __iterable_a: Iterable[A]) -&gt; Iter[Tuple[A]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls, __iterable_a: Iterable[A], __iterable_b: Iterable[B]\n    ) -&gt; Iter[Tuple[A, B]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls, __iterable_a: Iterable[A], __iterable_b: Iterable[B], __iterable_c: Iterable[C]\n    ) -&gt; Iter[Tuple[A, B, C]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n    ) -&gt; Iter[Tuple[A, B, C, D]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n    ) -&gt; Iter[Tuple[A, B, C, D, E]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n    ) -&gt; Iter[Tuple[A, B, C, D, E, F]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n    ) -&gt; Iter[Tuple[A, B, C, D, E, F, G]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n        __iterable_h: Iterable[H],\n    ) -&gt; Iter[Tuple[A, B, C, D, E, F, G, H]]:\n        ...\n\n    @overload\n    @classmethod\n    def create_cartesian_product(\n        cls,\n        __iterable_a: Iterable[Any],\n        __iterable_b: Iterable[Any],\n        __iterable_c: Iterable[Any],\n        __iterable_d: Iterable[Any],\n        __iterable_e: Iterable[Any],\n        __iterable_f: Iterable[Any],\n        __iterable_g: Iterable[Any],\n        __iterable_h: Iterable[Any],\n        __iterable_n: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -&gt; Iter[DynamicTuple[Any]]:\n        ...\n\n    @no_type_check\n    @classmethod\n    def create_cartesian_product(cls, *iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Any]]:\n\"\"\"Creates an iterator over the\n        [*Cartesian product*](https://en.wikipedia.org/wiki/Cartesian_product) of `iterables`.\n\n        Warning:\n            It only makes sense to compute the product of finite iterables.\n\n        Example:\n            ```python\n            a = (1, 2, 3)\n            b = \"xyz\"\n\n            c = [\n                (1, \"x\"), (1, \"y\"), (1, \"z\"),\n                (2, \"x\"), (2, \"y\"), (2, \"z\"),\n                (3, \"x\"), (3, \"y\"), (3, \"z\"),\n            ]\n\n            assert iter.create_cartesian_product(a, b).list() == c\n            ```\n\n        Arguments:\n            *iterables: Iterables to compute the Cartesian product of.\n\n        Returns:\n            An [`Iter[Tuple[...]]`][iters.iters.Iter] over the Cartesian product of iterables.\n        \"\"\"\n        return cls.create(cartesian_product(*iterables))\n\n    @classmethod\n    def reversed(cls, reversible: Reversible[T]) -&gt; Iter[T]:\n\"\"\"Creates an iterator over the reversed `reversible`.\n\n        Example:\n            ```python\n            assert iter.reversed([1, 2, 3]).list() == [3, 2, 1]\n            ```\n\n        Arguments:\n            reversible: The reversible to reverse.\n\n        Returns:\n            An [`Iter[T]`][iters.iters.Iter] over the reversed reversible.\n        \"\"\"\n        return cls.create(standard_reversed(reversible))\n\n    @classmethod\n    def function(cls, function: Nullary[T], sentinel: V) -&gt; Iter[T]:\n\"\"\"Creates an iterator over `function` call results until it returns the `sentinel`.\n\n        Example:\n            ```python\n            EMPTY_BYTES = bytes()\n\n            READ_BINARY = \"rb\"\n\n            CHUNK_SIZE = 65536\n\n            def read_chunk(file: BinaryIO) -&gt; Nullary[bytes]:\n                def reader(size: int = CHUNK_SIZE) -&gt; bytes:\n                    return file.read(size)\n\n                return reader\n\n            with path.open(READ_BINARY) as file:\n                iter.function(read_chunk(file), EMPTY_BYTES).for_each(process_chunk)\n            ```\n\n        Arguments:\n            function: The function to iterate.\n            sentinel: The sentinel to stop at.\n\n        Returns:\n            An [`Iter[T]`][iters.iters.Iter] over function calls until the `sentinel` is met.\n        \"\"\"\n        return cls.create(iter_function(function, sentinel))\n\n    @classmethod\n    def create(cls, iterable: Iterable[U]) -&gt; Iter[U]:\n        return cls(iterable)  # type: ignore\n\n    @classmethod\n    def create_tuple(cls, iterables: DynamicTuple[Iterable[U]]) -&gt; DynamicTuple[Iter[U]]:\n        return tuple(map(cls, iterables))  # type: ignore\n\n    @classmethod\n    def create_nested(cls, nested: Iterable[Iterable[U]]) -&gt; Iter[Iter[U]]:\n        return cls(map(cls, nested))  # type: ignore\n\n    @classmethod\n    def create_option(cls, option: Option[Iterable[U]]) -&gt; Option[Iter[U]]:\n        return option.map(cls)  # type: ignore\n\n    def __iter__(self) -&gt; Iter[T]:\n        return self\n\n    def __next__(self) -&gt; T:\n        return next(self.iterator)\n\n    def unwrap(self) -&gt; Iterator[T]:\n\"\"\"Unwraps the underlying iterator.\n\n        Returns:\n            The underlying iterator.\n        \"\"\"\n        return self.iterator\n\n    def iter(self) -&gt; Iter[T]:\n\"\"\"Simply returns `self`.\n\n        Returns:\n            `self`, the current iterator.\n        \"\"\"\n        return self\n\n    def next(self) -&gt; Option[T]:\n\"\"\"Returns the next item in the iterator.\n\n        Example:\n            ```python\n            value = 42\n\n            iterator = iter.once(value)\n\n            assert iterator.next().unwrap() is value\n            ```\n\n        Returns:\n            The next item.\n        \"\"\"\n        return wrap_marked(next(self.iterator, marker))\n\n    def compare(self: Iter[ST], other: Iterable[ST]) -&gt; Ordering:\n\"\"\"Compares `self` with the `other` iterable.\n\n        Example:\n            ```python\n            array = [1, 2, 3]\n\n            iterator = iter(array)\n\n            assert iterator.compare(array).is_equal()\n            ```\n\n        Arguments:\n            other: The other iterable.\n\n        Returns:\n            The [`Ordering`][iters.types.Ordering] representing the result.\n        \"\"\"\n        return compare(self.iterator, other)\n\n    def compare_by(self, other: Iterable[T], key: Unary[T, ST]) -&gt; Ordering:\n\"\"\"Compares `self` with the `other` iterable using the `key` function.\n\n        Example:\n            ```python\n            array = [13, 34, 42]\n            negative = [-x for x in array]\n\n            iterator = iter(array)\n\n            assert iterator.compare_by(negative, abs).is_equal()\n            ```\n\n        Arguments:\n            other: The other iterable.\n            key: The key function.\n\n        Returns:\n            The [`Ordering`][iters.types.Ordering] representing the result.\n        \"\"\"\n        return compare(self.iterator, other, key)\n\n    def length(self) -&gt; int:\n\"\"\"Computes the length of the iterator.\n\n        Example:\n            ```python\n            assert iter.repeat_exactly(7, 7).length() == 7\n            ```\n\n        Warning:\n            This function exhausts the underlying iterator!\n\n        Returns:\n            The length of the iterator.\n        \"\"\"\n        return iter_length(self.iterator)\n\n    def first(self) -&gt; Option[T]:\n\"\"\"Returns the first item in the iterator.\n\n        Example:\n            ```python\n            value = 69\n\n            iterator = iter.once(value)\n\n            assert iterator.first().unwrap() is value\n            ```\n\n        Returns:\n            The first item.\n        \"\"\"\n        return wrap_marked(first(self.iterator, marker))\n\n    def last(self) -&gt; Option[T]:\n\"\"\"Returns the last item in the iterator.\n\n        Example:\n            ```python\n            value = 69\n\n            iterator = iter.once(value)\n\n            assert iterator.last().unwrap() is value\n            ```\n\n        Returns:\n            The last item.\n        \"\"\"\n        return wrap_marked(last(self.iterator))\n\n    def last_with_tail(self) -&gt; Option[T]:\n\"\"\"Returns the last item in the iterator.\n\n        Note:\n            This method uses the [`tail`][iters.utils.tail] function.\n\n        Example:\n            ```python\n            value = 69\n\n            iterator = iter.once(value)\n\n            assert iterator.last_with_tail().unwrap() is value\n            ```\n\n        Returns:\n            The last item.\n        \"\"\"\n        return wrap_marked(last_with_tail(self.iterator, marker))\n\n    def collect(self, function: Unary[Iterable[T], U]) -&gt; U:\n\"\"\"Collects the iterator with the `function`.\n\n        This is equivalent to:\n\n        ```python\n        function(iterator.unwrap())\n        ```\n\n        Example:\n            ```python\n            array = [1, 2, 3]\n\n            iterator = iter(array)\n\n            assert iterator.collect(list) == array\n            ```\n\n        Arguments:\n            function: The function to use.\n\n        Returns:\n            The result of the `function` call.\n        \"\"\"\n        return function(self.iterator)\n\n    def collect_iter(self, function: Unary[Iterable[T], Iterable[U]]) -&gt; Iter[U]:\n\"\"\"Collects the iterator with the `function`.\n\n        This is equivalent to:\n\n        ```python\n        iterator.create(iterator.collect(function))\n        ```\n\n        Example:\n            ```python\n            from typing import TypeVar\n\n            T = TypeVar(\"T\")\n\n            def identity(item: T) -&gt; T:\n                return item\n\n            array = [13, 25, 34]\n\n            iterator = iter(array).collect_iter(identity)\n\n            assert iterator.list() == array\n            ```\n\n        Arguments:\n            function: The function to use.\n\n        Returns:\n            The result of the `function` call, wrapped back into an iterator.\n        \"\"\"\n        return self.create(self.collect(function))\n\n    def list(self) -&gt; List[T]:\n\"\"\"Collects the iterator into the [`List[T]`][list].\n\n        This is equivalent to:\n\n        ```python\n        list(iterator.unwrap())\n        ```\n\n        Example:\n            ```python\n            array = [1, 2, 3]\n\n            iterator = iter(array)\n\n            assert iterator.list() == array\n            ```\n\n        Returns:\n            The [`List[T]`][list] over the iterator.\n        \"\"\"\n        return list(self.iterator)\n\n    def set(self: Iter[Q]) -&gt; Set[Q]:\n\"\"\"Collects the iterator into the [`Set[Q]`][set].\n\n        Warning:\n            The items of the iterator have to be hashable for this method to work.\n\n        This is equivalent to:\n\n        ```python\n        set(iterator.unwrap())\n        ```\n\n        Example:\n            ```python\n            set = {13, 42, 69}\n\n            iterator = iter(set)\n\n            assert iterator.set() == set\n            ```\n\n        Returns:\n            The [`Set[Q]`][set] over the iterator.\n        \"\"\"\n        return set(self.iterator)\n\n    def ordered_set(self: Iter[Q]) -&gt; OrderedSet[Q]:\n\"\"\"Collects the iterator into the [`OrderedSet[Q]`][iters.ordered_set.OrderedSet].\n\n        Warning:\n            The items of the iterator have to be hashable for this method to work.\n\n        This is equivalent to:\n\n        ```python\n        ordered_set(iterator.unwrap())\n        ```\n\n        Example:\n            ```python\n            ordered_set = OrderedSet([13, 42, 69])\n\n            iterator = iter(ordered_set)\n\n            assert iterator.ordered_set() == ordered_set\n            ```\n\n        Returns:\n            The [`OrderedSet[Q]`][iters.ordered_set.OrderedSet] over the iterator.\n        \"\"\"\n        return ordered_set(self.iterator)\n\n    def tuple(self) -&gt; DynamicTuple[T]:\n\"\"\"Collects the iterator into the [`Tuple[T, ...]`][tuple].\n\n        This is equivalent to:\n\n        ```python\n        tuple(iterator.unwrap())\n        ```\n\n        Example:\n            ```python\n            tuple = (-1, 0, 1)\n\n            iterator = iter(tuple)\n\n            assert iterator.tuple() == tuple\n            ```\n\n        Returns:\n            The [`Tuple[T, ...]`][tuple] over the iterator.\n        \"\"\"\n        return tuple(self.iterator)\n\n    def dict(self: Iter[Tuple[Q, V]]) -&gt; Dict[Q, V]:\n\"\"\"Collects the iterator into the [`Dict[Q, V]`][dict].\n\n        Warning:\n            The first item in each couple has to be hashable for this method to work.\n\n        This is equivalent to:\n\n        ```python\n        dict(iterator.unwrap())\n        ```\n\n        Example:\n            ```python\n            mapping = {13: \"nekit\", 42: \"dev\"}\n\n            iterator = iter(mapping.items())\n\n            assert iterator.dict() == mapping\n            ```\n\n        Returns:\n            The [`Dict[Q, V]`][dict] over the iterator.\n        \"\"\"\n        return dict(self.iterator)\n\n    def join(self: Iter[AnyStr], string: AnyStr) -&gt; AnyStr:\n\"\"\"Joins the iterator using the `string`.\n\n        Warning:\n            The iterator must contain only string items for this method to work.\n\n        This is equivalent to:\n\n        ```python\n        string.join(iterator.unwrap())\n        ```\n\n        Example:\n            ```python\n            result = \"melody, nekit\"\n\n            string = \", \"\n\n            iterator = iter(result.split(string))\n\n            assert iterator.join(string) == result\n            ```\n\n        Returns:\n            The joined [`str`][str] or [`bytes`][bytes] depending on the `string` type.\n        \"\"\"\n        return string.join(self.iterator)\n\n    def string(self: Iter[str]) -&gt; str:\n\"\"\"Joins the iterator into the [`str`][str] string.\n\n        Warning:\n            The iterator must contain only items of type [`str`][str] for this method to work.\n\n        This is equivalent to:\n\n        ```python\n        iterator.join(EMPTY_STRING)\n        ```\n\n        Example:\n            ```python\n            strings = (\"x\", \"y\", \"z\")\n            string = \"xyz\"\n\n            iterator = iter(strings)\n\n            assert iterator.string() == string\n            ```\n\n        Returns:\n            The joined [`str`][str] string.\n        \"\"\"\n        return self.join(EMPTY_STRING)\n\n    def bytes(self: Iter[bytes]) -&gt; bytes:\n\"\"\"Joins the iterator into the [`bytes`][bytes] string.\n\n        Warning:\n            The iterator must contain only items of type [`bytes`][bytes] for this method to work.\n\n        This is equivalent to:\n\n        ```python\n        iterator.join(EMPTY_BYTES)\n        ```\n\n        Returns:\n            The joined [`bytes`][bytes] string.\n        \"\"\"\n        return self.join(EMPTY_BYTES)\n\n    def count_dict(self: Iter[Q]) -&gt; Counter[Q]:\n\"\"\"Collects the iterator into the [`Counter[Q]`][collections.Counter].\n\n        Warning:\n            The items of the iterator have to be hashable for this method to work.\n\n        Example:\n            ```python\n            bits = (0, 1, 1, 0, 1, 1, 1, 0)\n\n            result = [(1, 5), (0, 3)]\n\n            iterator = iter(bits)\n\n            assert iterator.count_dict().most_common() == result\n            ```\n\n        Returns:\n            The [`Counter[Q]`][collections.Counter] over the items of the iterator.\n        \"\"\"\n        return count_dict(self.iterator)\n\n    def count_dict_by(self, key: Unary[T, Q]) -&gt; Counter[Q]:\n\"\"\"Collects the iterator into the [`Counter[Q]`][collections.Counter]\n        by applying the `key` function.\n\n        Example:\n            ```python\n            sets = [{}, {0}, {1}, {0, 1}]\n\n            iterator = iter(sets)\n\n            result = [(1, 2), (2, 1), (0, 1)]\n\n            assert iterator.count_dict_by(len).most_common() == result\n            ```\n\n        Arguments:\n            key: The key function.\n\n        Returns:\n            The [`Counter[Q]`][collections.Counter] over the keys\n                corresponding to the items of the iterator.\n        \"\"\"\n        return count_dict(self.iterator, key)\n\n    def group_dict(self: Iter[Q]) -&gt; Dict[Q, List[Q]]:\n        return group_dict(self.iterator)\n\n    def group_dict_by(self, key: Unary[T, Q]) -&gt; Dict[Q, List[T]]:\n        return group_dict(self.iterator, key)\n\n    def group(self) -&gt; Iter[Tuple[T, Iter[T]]]:\n        return self.create(\n            (group_key, self.create(group_iterator))\n            for group_key, group_iterator in group(self.iterator)\n        )\n\n    def group_by(self, key: Unary[T, U]) -&gt; Iter[Tuple[U, Iter[T]]]:\n        return self.create(\n            (group_key, self.create(group_iterator))\n            for group_key, group_iterator in group(self.iterator, key)\n        )\n\n    def group_list(self) -&gt; Iter[Tuple[T, List[T]]]:\n        return self.create(group_list(self.iterator))\n\n    def group_list_by(self, key: Unary[T, U]) -&gt; Iter[Tuple[U, List[T]]]:\n        return self.create(group_list(self.iterator, key))\n\n    def all(self) -&gt; bool:\n        return all(self.iterator)\n\n    def all_by(self, predicate: Predicate[T]) -&gt; bool:\n        return self.map(predicate).all()\n\n    def any(self) -&gt; bool:\n        return any(self.iterator)\n\n    def any_by(self, predicate: Predicate[T]) -&gt; bool:\n        return self.map(predicate).any()\n\n    def all_equal(self) -&gt; bool:\n        return all_equal(self.iterator)\n\n    def all_equal_by(self, key: Unary[T, U]) -&gt; bool:\n        return all_equal(self.iterator, key)\n\n    def all_unique(self) -&gt; bool:\n        return all_unique(self.iterator)\n\n    def all_unique_by(self, key: Unary[T, U]) -&gt; bool:\n        return all_unique(self.iterator, key)\n\n    def all_unique_fast(self: Iter[Q]) -&gt; bool:\n        return all_unique_fast(self.iterator)\n\n    def all_unique_fast_by(self, key: Unary[T, Q]) -&gt; bool:\n        return all_unique_fast(self.iterator, key)\n\n    def remove(self, predicate: Optional[Predicate[T]]) -&gt; Iter[T]:\n        return self.create(remove(predicate, self.iterator))\n\n    def remove_duplicates(self) -&gt; Iter[T]:\n        return self.create(remove_duplicates(self.iterator))\n\n    def remove_duplicates_by(self, key: Unary[T, U]) -&gt; Iter[T]:\n        return self.create(remove_duplicates(self.iterator, key))\n\n    def filter(self, predicate: Optional[Predicate[T]]) -&gt; Iter[T]:\n        return self.create(filter(predicate, self.iterator))\n\n    def filter_false(self, predicate: Optional[Predicate[T]]) -&gt; Iter[T]:\n        return self.create(filter_false(predicate, self.iterator))\n\n    def filter_except(self, validate: Unary[T, Any], *errors: AnyErrorType) -&gt; Iter[T]:\n        return self.create(filter_except(validate, self.iterator, *errors))\n\n    def compress(self, selectors: Selectors) -&gt; Iter[T]:\n        return self.create(compress(self.iterator, selectors))\n\n    def position_all(self, predicate: Optional[Predicate[T]]) -&gt; Iter[int]:\n        return self.create(position_all(predicate, self.iterator))\n\n    def position(self, predicate: Optional[Predicate[T]]) -&gt; Option[int]:\n        return wrap_marked(position(predicate, self.iterator, marker))\n\n    def find_all(self, predicate: Optional[Predicate[T]]) -&gt; Iter[T]:\n        return self.create(find_all(predicate, self.iterator))\n\n    def find(self, predicate: Optional[Predicate[T]]) -&gt; Option[T]:\n        return wrap_marked(find(predicate, self.iterator, marker))  # type: ignore  # weird\n\n    def find_or_first(self, predicate: Optional[Predicate[T]]) -&gt; Option[T]:\n        return wrap_marked(find_or_first(predicate, self.iterator, marker))  # type: ignore  # weird\n\n    def find_or_last(self, predicate: Optional[Predicate[T]]) -&gt; Option[T]:\n        return wrap_marked(find_or_last(predicate, self.iterator, marker))  # type: ignore  # weird\n\n    def contains(self, item: V) -&gt; bool:\n        return contains(item, self.iterator)\n\n    def contains_identity(self: Iter[V], item: V) -&gt; bool:\n        return contains_identity(item, self.iterator)\n\n    def reduce(self, function: Binary[T, T, T]) -&gt; T:\n        return reduce(function, self.iterator)\n\n    def fold(self, initial: V, function: Binary[V, T, V]) -&gt; V:\n        return fold(initial, function, self.iterator)\n\n    @early_option\n    def sum(self: Iter[S]) -&gt; Option[S]:\n        return Some(self.sum_with(self.next().early()))\n\n    def sum_with(self: Iter[S], initial: S) -&gt; S:\n        return sum(self.iterator, initial)\n\n    @early_option\n    def product(self: Iter[P]) -&gt; Option[P]:\n        return Some(self.product_with(self.next().early()))\n\n    def product_with(self: Iter[P], initial: P) -&gt; P:\n        return product(self.iterator, initial)\n\n    def accumulate_reduce(self, function: Binary[T, T, T]) -&gt; Iter[T]:\n        return self.create(accumulate_reduce(function, self.iterator))\n\n    def accumulate_fold(self, initial: V, function: Binary[V, T, V]) -&gt; Iter[V]:\n        return self.create(accumulate_fold(initial, function, self.iterator))\n\n    def accumulate_sum(self: Iter[S]) -&gt; Iter[S]:\n        return self.create(accumulate_sum(self.iterator))\n\n    def accumulate_sum_with(self: Iter[S], initial: S) -&gt; Iter[S]:\n        return self.create(accumulate_sum(self.iterator, initial))\n\n    def accumulate_product(self: Iter[P]) -&gt; Iter[P]:\n        return self.create(accumulate_product(self.iterator))\n\n    def accumulate_product_with(self: Iter[P], initial: P) -&gt; Iter[P]:\n        return self.create(accumulate_product(self.iterator, initial))\n\n    def min(self: Iter[ST]) -&gt; Option[ST]:\n        return wrap_marked(min(self.iterator, default=marker))\n\n    def min_by(self, key: Unary[T, ST]) -&gt; Option[T]:\n        return wrap_marked(min(self.iterator, key=key, default=marker))  # type: ignore  # weird\n\n    def max(self: Iter[ST]) -&gt; Option[ST]:\n        return wrap_marked(max(self.iterator, default=marker))\n\n    def max_by(self, key: Unary[T, ST]) -&gt; Option[T]:\n        return wrap_marked(max(self.iterator, key=key, default=marker))  # type: ignore  # weird\n\n    def min_max(self: Iter[ST]) -&gt; Option[Pair[ST]]:\n        return wrap_marked(min_max(self.iterator, default=marker))\n\n    def min_max_by(self, key: Unary[T, ST]) -&gt; Option[Pair[T]]:\n        return wrap_marked(min_max(self.iterator, key=key, default=marker))\n\n    def map(self, function: Unary[T, U]) -&gt; Iter[U]:\n        return self.create(map(function, self.iterator))\n\n    def map_except(self, function: Unary[T, U], *errors: AnyErrorType) -&gt; Iter[U]:\n        return self.create(map_except(function, self.iterator, *errors))\n\n    def flat_map(self, function: Unary[T, Iterable[U]]) -&gt; Iter[U]:\n        return self.create(flat_map(function, self.iterator))\n\n    def filter_map(self, predicate: Optional[Predicate[T]], function: Unary[T, U]) -&gt; Iter[U]:\n        return self.create(filter_map(predicate, function, self.iterator))\n\n    def filter_false_map(self, predicate: Optional[Predicate[T]], function: Unary[T, U]) -&gt; Iter[U]:\n        return self.create(filter_false_map(predicate, function, self.iterator))\n\n    def flatten(self: Iter[Iterable[U]]) -&gt; Iter[U]:\n        return self.create(flatten(self.iterator))\n\n    def collapse(self: Iter[RecursiveIterable[U]]) -&gt; Iter[U]:\n        return self.create(collapse(self.iterator))\n\n    def enumerate(self) -&gt; Iter[Tuple[int, T]]:\n        return self.create(enumerate(self.iterator))\n\n    def enumerate_from(self, start: int) -&gt; Iter[Tuple[int, T]]:\n        return self.create(enumerate(self.iterator, start))\n\n    def consume(self) -&gt; None:\n        consume(self.iterator)\n\n    def for_each(self, function: Unary[T, Any]) -&gt; None:\n        for_each(function, self.iterator)\n\n    def append(self: Iter[V], item: V) -&gt; Iter[V]:\n        return self.create(append(item, self.iterator))\n\n    def prepend(self: Iter[V], item: V) -&gt; Iter[V]:\n        return self.create(prepend(item, self.iterator))\n\n    def at(self, index: int) -&gt; Option[T]:\n        return wrap_marked(at(index, self.iterator, marker))\n\n    def at_or_last(self, index: int) -&gt; Option[T]:\n        return wrap_marked(at_or_last(index, self.iterator, marker))\n\n    @overload\n    def slice(self, __stop: Optional[int]) -&gt; Iter[T]:\n        ...\n\n    @overload\n    def slice(\n        self, __start: Optional[int], __stop: Optional[int], __step: Optional[int] = ...\n    ) -&gt; Iter[T]:\n        ...\n\n    def slice(self, *slice_args: Optional[int]) -&gt; Iter[T]:\n        return self.create(iter_slice(self.iterator, *slice_args))\n\n    def drop(self, size: int) -&gt; Iter[T]:\n        return self.create(drop(size, self.iterator))\n\n    skip = drop\n\n    def rest(self) -&gt; Iter[T]:\n        return self.create(rest(self.iterator))\n\n    def drop_while(self, predicate: Optional[Predicate[T]]) -&gt; Iter[T]:\n        return self.create(drop_while(predicate, self.iterator))\n\n    skip_while = drop_while\n\n    def take(self, size: int) -&gt; Iter[T]:\n        return self.create(take(size, self.iterator))\n\n    def take_while(self, predicate: Optional[Predicate[T]]) -&gt; Iter[T]:\n        return self.create(take_while(predicate, self.iterator))\n\n    def step_by(self, step: int) -&gt; Iter[T]:\n        return self.create(step_by(step, self.iterator))\n\n    def tail(self, size: int) -&gt; Iter[T]:\n        return self.create(tail(size, self.iterator))\n\n    def apply_chain(self, *iterables: Iterable[T]) -&gt; Iter[T]:\n        return self.create(chain(self.iterator, *iterables))\n\n    chain = mixed_method(create_chain, apply_chain)\n\n    def apply_chain_with(self, iterables: Iterable[Iterable[T]]) -&gt; Iter[T]:\n        return self.chain(chain_from_iterable(iterables))\n\n    chain_with = mixed_method(create_chain_with, apply_chain_with)\n\n    def cycle(self) -&gt; Iter[T]:\n        return self.create(cycle(self.iterator))\n\n    def intersperse(self: Iter[V], value: V) -&gt; Iter[V]:\n        return self.create(intersperse(value, self.iterator))\n\n    def intersperse_with(self, function: Nullary[T]) -&gt; Iter[T]:\n        return self.create(intersperse_with(function, self.iterator))\n\n    def apply_interleave(self, *iterables: Iterable[T]) -&gt; Iter[T]:\n        return self.create(interleave(self.iterator, *iterables))\n\n    interleave = mixed_method(create_interleave, apply_interleave)\n\n    def apply_interleave_longest(self, *iterables: Iterable[T]) -&gt; Iter[T]:\n        return self.create(interleave_longest(self.iterator, *iterables))\n\n    interleave_longest = mixed_method(create_interleave_longest, apply_interleave_longest)\n\n    def apply_combine(self, *iterables: Iterable[T]) -&gt; Iter[T]:\n        return self.create(combine(self.iterator, *iterables))\n\n    combine = mixed_method(create_combine, apply_combine)\n\n    @overload\n    def distribute_unsafe(self, count: Literal[0]) -&gt; EmptyTuple:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[1]) -&gt; Tuple1[Iter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[2]) -&gt; Tuple2[Iter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[3]) -&gt; Tuple3[Iter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[4]) -&gt; Tuple4[Iter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[5]) -&gt; Tuple5[Iter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[6]) -&gt; Tuple6[Iter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[7]) -&gt; Tuple7[Iter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: Literal[8]) -&gt; Tuple8[Iter[T]]:\n        ...\n\n    @overload\n    def distribute_unsafe(self, count: int) -&gt; DynamicTuple[Iter[T]]:\n        ...\n\n    def distribute_unsafe(self, count: int) -&gt; DynamicTuple[Iter[T]]:\n        return self.create_tuple(distribute_unsafe(count, self.iterator))\n\n    distribute_infinite = distribute_unsafe\n\n    @overload\n    def distribute(self, count: Literal[0]) -&gt; EmptyTuple:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[1]) -&gt; Tuple1[Iter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[2]) -&gt; Tuple2[Iter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[3]) -&gt; Tuple3[Iter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[4]) -&gt; Tuple4[Iter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[5]) -&gt; Tuple5[Iter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[6]) -&gt; Tuple6[Iter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[7]) -&gt; Tuple7[Iter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: Literal[8]) -&gt; Tuple8[Iter[T]]:\n        ...\n\n    @overload\n    def distribute(self, count: int) -&gt; DynamicTuple[Iter[T]]:\n        ...\n\n    def distribute(self, count: int) -&gt; DynamicTuple[Iter[T]]:\n        return self.create_tuple(distribute(count, self.iterator))\n\n    def divide(self, count: int) -&gt; Iter[Iter[T]]:\n        return self.create_nested(divide(count, self.iterator))\n\n    def pad(self: Iter[V], value: V) -&gt; Iter[V]:\n        return self.create(pad(value, self.iterator))\n\n    def pad_exactly(self: Iter[V], value: V, size: int) -&gt; Iter[V]:\n        return self.create(pad(value, self.iterator, size))\n\n    def pad_multiple(self: Iter[V], value: V, size: int) -&gt; Iter[V]:\n        return self.create(pad(value, self.iterator, size, multiple=True))\n\n    def pad_with(self: Iter[V], function: Unary[int, V]) -&gt; Iter[V]:\n        return self.create(pad_with(function, self.iterator))\n\n    def pad_exactly_with(self: Iter[V], function: Unary[int, V], size: int) -&gt; Iter[V]:\n        return self.create(pad_with(function, self.iterator, size))\n\n    def pad_multiple_with(self: Iter[V], function: Unary[int, V], size: int) -&gt; Iter[V]:\n        return self.create(pad_with(function, self.iterator, size, multiple=True))\n\n    def chunks(self, size: int) -&gt; Iter[List[T]]:\n        return self.create(chunks(size, self.iterator))\n\n    def iter_chunks(self, size: int) -&gt; Iter[Iter[T]]:\n        return self.create_nested(iter_chunks(size, self.iterator))\n\n    def iter_chunks_unsafe(self, size: int) -&gt; Iter[Iter[T]]:\n        return self.create_nested(iter_chunks_unsafe(size, self.iterator))\n\n    iter_chunks_infinite = iter_chunks_unsafe\n\n    @overload\n    def groups(self, size: Literal[0]) -&gt; Iter[Never]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[1]) -&gt; Iter[Tuple1[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[2]) -&gt; Iter[Tuple2[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[3]) -&gt; Iter[Tuple3[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[4]) -&gt; Iter[Tuple4[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[5]) -&gt; Iter[Tuple5[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[6]) -&gt; Iter[Tuple6[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[7]) -&gt; Iter[Tuple7[T]]:\n        ...\n\n    @overload\n    def groups(self, size: Literal[8]) -&gt; Iter[Tuple8[T]]:\n        ...\n\n    @overload\n    def groups(self, size: int) -&gt; Iter[DynamicTuple[T]]:\n        ...\n\n    def groups(self, size: int) -&gt; Iter[DynamicTuple[T]]:\n        return self.create(groups(size, self.iterator))\n\n    @overload\n    def groups_longest(self, size: Literal[0]) -&gt; Iter[Never]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[1]) -&gt; Iter[Tuple1[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[2]) -&gt; Iter[Tuple2[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[3]) -&gt; Iter[Tuple3[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[4]) -&gt; Iter[Tuple4[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[5]) -&gt; Iter[Tuple5[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[6]) -&gt; Iter[Tuple6[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[7]) -&gt; Iter[Tuple7[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: Literal[8]) -&gt; Iter[Tuple8[Option[T]]]:\n        ...\n\n    @overload\n    def groups_longest(self, size: int) -&gt; Iter[DynamicTuple[Option[T]]]:\n        ...\n\n    def groups_longest(self, size: int) -&gt; Iter[DynamicTuple[Option[T]]]:\n        return self.create(groups_longest(size, self.iterator))\n\n    def pairs(self) -&gt; Iter[Pair[T]]:\n        return self.create(pairs(self.iterator))\n\n    def pairs_longest(self) -&gt; Iter[Pair[Option[T]]]:\n        return self.create(pairs_longest(self.iterator))\n\n    def iter_windows(self, size: int) -&gt; Iter[Iter[T]]:\n        return self.create_nested(iter_windows(size, self.iterator))\n\n    def list_windows(self, size: int) -&gt; Iter[List[T]]:\n        return self.create(list_windows(size, self.iterator))\n\n    def pairs_windows(self) -&gt; Iter[Pair[T]]:\n        return self.create(pairs_windows(self.iterator))\n\n    @overload\n    def tuple_windows(self, size: Literal[0]) -&gt; Iter[EmptyTuple]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[1]) -&gt; Iter[Tuple1[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[2]) -&gt; Iter[Tuple2[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[3]) -&gt; Iter[Tuple3[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[4]) -&gt; Iter[Tuple4[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[5]) -&gt; Iter[Tuple5[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[6]) -&gt; Iter[Tuple6[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[7]) -&gt; Iter[Tuple7[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: Literal[8]) -&gt; Iter[Tuple8[T]]:\n        ...\n\n    @overload\n    def tuple_windows(self, size: int) -&gt; Iter[DynamicTuple[T]]:\n        ...\n\n    def tuple_windows(self, size: int) -&gt; Iter[DynamicTuple[T]]:\n        return self.create(tuple_windows(size, self.iterator))\n\n    def set_windows(self: Iter[Q], size: int) -&gt; Iter[Set[Q]]:\n        return self.create(set_windows(size, self.iterator))\n\n    @overload\n    def apply_zip(self) -&gt; Iter[Tuple[T]]:\n        ...\n\n    @overload\n    def apply_zip(self, __iterable_a: Iterable[A]) -&gt; Iter[Tuple[T, A]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self, __iterable_a: Iterable[A], __iterable_b: Iterable[B]\n    ) -&gt; Iter[Tuple[T, A, B]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self, __iterable_a: Iterable[A], __iterable_b: Iterable[B], __iterable_c: Iterable[C]\n    ) -&gt; Iter[Tuple[T, A, B, C]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n    ) -&gt; Iter[Tuple[T, A, B, C, D]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n    ) -&gt; Iter[Tuple[T, A, B, C, D, E]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n    ) -&gt; Iter[Tuple[T, A, B, C, D, E, F]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n    ) -&gt; Iter[Tuple[T, A, B, C, D, E, F, G]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n        __iterable_h: Iterable[H],\n    ) -&gt; Iter[Tuple[T, A, B, C, D, E, F, G, H]]:\n        ...\n\n    @overload\n    def apply_zip(\n        self,\n        __iterable_a: Iterable[Any],\n        __iterable_b: Iterable[Any],\n        __iterable_c: Iterable[Any],\n        __iterable_d: Iterable[Any],\n        __iterable_e: Iterable[Any],\n        __iterable_f: Iterable[Any],\n        __iterable_g: Iterable[Any],\n        __iterable_h: Iterable[Any],\n        __iterable_n: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -&gt; Iter[DynamicTuple[Any]]:\n        ...\n\n    def apply_zip(self, *iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Any]]:\n        return self.create(zip(self.iterator, *iterables))\n\n    zip = mixed_method(create_zip, apply_zip)\n\n    @overload\n    def apply_zip_equal(self) -&gt; Iter[Tuple[T]]:\n        ...\n\n    @overload\n    def apply_zip_equal(self, __iterable_a: Iterable[A]) -&gt; Iter[Tuple[T, A]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self, __iterable_a: Iterable[A], __iterable_b: Iterable[B]\n    ) -&gt; Iter[Tuple[T, A, B]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self, __iterable_a: Iterable[A], __iterable_b: Iterable[B], __iterable_c: Iterable[C]\n    ) -&gt; Iter[Tuple[T, A, B, C]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n    ) -&gt; Iter[Tuple[T, A, B, C, D]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n    ) -&gt; Iter[Tuple[T, A, B, C, D, E]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n    ) -&gt; Iter[Tuple[T, A, B, C, D, E, F]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n    ) -&gt; Iter[Tuple[T, A, B, C, D, E, F, G]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n        __iterable_h: Iterable[H],\n    ) -&gt; Iter[Tuple[T, A, B, C, D, E, F, G, H]]:\n        ...\n\n    @overload\n    def apply_zip_equal(\n        self,\n        __iterable_a: Iterable[Any],\n        __iterable_b: Iterable[Any],\n        __iterable_c: Iterable[Any],\n        __iterable_d: Iterable[Any],\n        __iterable_e: Iterable[Any],\n        __iterable_f: Iterable[Any],\n        __iterable_g: Iterable[Any],\n        __iterable_h: Iterable[Any],\n        __iterable_n: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -&gt; Iter[DynamicTuple[Any]]:\n        ...\n\n    def apply_zip_equal(self, *iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Any]]:\n        return self.create(zip_equal(self.iterator, *iterables))\n\n    zip_equal = mixed_method(create_zip_equal, apply_zip_equal)\n\n    @overload\n    def apply_zip_longest(self) -&gt; Iter[Tuple[Option[T]]]:\n        ...\n\n    @overload\n    def apply_zip_longest(self, __iterable_a: Iterable[A]) -&gt; Iter[Tuple[Option[T], Option[A]]]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self, __iterable_a: Iterable[A], __iterable_b: Iterable[B]\n    ) -&gt; Iter[Tuple[Option[T], Option[A], Option[B]]]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self, __iterable_a: Iterable[A], __iterable_b: Iterable[B], __iterable_c: Iterable[C]\n    ) -&gt; Iter[Tuple[Option[T], Option[A], Option[B], Option[C]]]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n    ) -&gt; Iter[Tuple[Option[T], Option[A], Option[B], Option[C], Option[D]]]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n    ) -&gt; Iter[Tuple[Option[T], Option[A], Option[B], Option[C], Option[D], Option[E]]]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n    ) -&gt; Iter[Tuple[Option[T], Option[A], Option[B], Option[C], Option[D], Option[E], Option[F],]]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n    ) -&gt; Iter[\n        Tuple[\n            Option[T],\n            Option[A],\n            Option[B],\n            Option[C],\n            Option[D],\n            Option[E],\n            Option[F],\n            Option[G],\n        ]\n    ]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n        __iterable_h: Iterable[H],\n    ) -&gt; Iter[\n        Tuple[\n            Option[T],\n            Option[A],\n            Option[B],\n            Option[C],\n            Option[D],\n            Option[E],\n            Option[F],\n            Option[G],\n            Option[H],\n        ]\n    ]:\n        ...\n\n    @overload\n    def apply_zip_longest(\n        self,\n        __iterable_a: Iterable[Any],\n        __iterable_b: Iterable[Any],\n        __iterable_c: Iterable[Any],\n        __iterable_d: Iterable[Any],\n        __iterable_e: Iterable[Any],\n        __iterable_f: Iterable[Any],\n        __iterable_g: Iterable[Any],\n        __iterable_h: Iterable[Any],\n        __iterable_n: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -&gt; Iter[DynamicTuple[Option[Any]]]:\n        ...\n\n    def apply_zip_longest(self, *iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Option[Any]]]:\n        return self.create(zip_longest(self.iterator, *iterables))\n\n    zip_longest = mixed_method(create_zip_longest, apply_zip_longest)\n\n    def transpose(self: Iter[Iterable[U]]) -&gt; Iter[DynamicTuple[U]]:\n        return self.create(transpose(self.iterator))\n\n    @overload\n    def apply_cartesian_product(self) -&gt; Iter[Tuple[T]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(self, __iterable_a: Iterable[A]) -&gt; Iter[Tuple[T, A]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self, __iterable_a: Iterable[A], __iterable_b: Iterable[B]\n    ) -&gt; Iter[Tuple[T, A, B]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self, __iterable_a: Iterable[A], __iterable_b: Iterable[B], __iterable_c: Iterable[C]\n    ) -&gt; Iter[Tuple[T, A, B, C]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n    ) -&gt; Iter[Tuple[T, A, B, C, D]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n    ) -&gt; Iter[Tuple[T, A, B, C, D, E]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n    ) -&gt; Iter[Tuple[T, A, B, C, D, E, F]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n    ) -&gt; Iter[Tuple[T, A, B, C, D, E, F, G]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self,\n        __iterable_a: Iterable[A],\n        __iterable_b: Iterable[B],\n        __iterable_c: Iterable[C],\n        __iterable_d: Iterable[D],\n        __iterable_e: Iterable[E],\n        __iterable_f: Iterable[F],\n        __iterable_g: Iterable[G],\n        __iterable_h: Iterable[H],\n    ) -&gt; Iter[Tuple[T, A, B, C, D, E, F, G, H]]:\n        ...\n\n    @overload\n    def apply_cartesian_product(\n        self,\n        __iterable_a: Iterable[Any],\n        __iterable_b: Iterable[Any],\n        __iterable_c: Iterable[Any],\n        __iterable_d: Iterable[Any],\n        __iterable_e: Iterable[Any],\n        __iterable_f: Iterable[Any],\n        __iterable_g: Iterable[Any],\n        __iterable_h: Iterable[Any],\n        __iterable_n: Iterable[Any],\n        *iterables: Iterable[Any],\n    ) -&gt; Iter[DynamicTuple[Any]]:\n        ...\n\n    def apply_cartesian_product(self, *iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Any]]:\n        return self.create(cartesian_product(self.iterator, *iterables))\n\n    cartesian_product = mixed_method(create_cartesian_product, apply_cartesian_product)\n\n    @overload\n    def cartesian_power(self, power: Literal[0]) -&gt; Iter[EmptyTuple]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[1]) -&gt; Iter[Tuple1[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[2]) -&gt; Iter[Tuple2[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[3]) -&gt; Iter[Tuple3[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[4]) -&gt; Iter[Tuple4[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[5]) -&gt; Iter[Tuple5[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[6]) -&gt; Iter[Tuple6[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[7]) -&gt; Iter[Tuple7[T]]:\n        ...\n\n    @overload\n    def cartesian_power(self, power: Literal[8]) -&gt; Iter[Tuple8[T]]:\n        ...\n\n    def cartesian_power(self, power: int) -&gt; Iter[DynamicTuple[T]]:\n\"\"\"Creates an iterator over the\n        [*Cartesian power*](https://en.wikipedia.org/wiki/Cartesian_product) of the iterator.\n\n        Warning:\n            It only makes sense to compute the Cartesian power of finite iterators.\n\n        Example:\n            ```python\n            bits = (0, 1)\n            result = ((0, 0), (0, 1), (1, 0), (1, 1))\n\n            iterator = iter(bits)\n\n            assert iterator.cartesian_power(2).tuple() == result\n            ```\n\n        Arguments:\n            power: The power to \"raise\" the iterator to.\n\n        Returns:\n            An [`Iter[Tuple[...]]`] over the Cartesian power of the iterator.\n        \"\"\"\n        return self.create(cartesian_power(power, self.iterator))\n\n    @overload\n    def combinations(self, count: Literal[0]) -&gt; Iter[EmptyTuple]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[1]) -&gt; Iter[Tuple1[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[2]) -&gt; Iter[Tuple2[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[3]) -&gt; Iter[Tuple3[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[4]) -&gt; Iter[Tuple4[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[5]) -&gt; Iter[Tuple5[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[6]) -&gt; Iter[Tuple6[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[7]) -&gt; Iter[Tuple7[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: Literal[8]) -&gt; Iter[Tuple8[T]]:\n        ...\n\n    @overload\n    def combinations(self, count: int) -&gt; Iter[DynamicTuple[T]]:\n        ...\n\n    def combinations(self, count: int) -&gt; Iter[DynamicTuple[T]]:\n        return self.create(combinations(count, self.iterator))\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[0]) -&gt; Iter[EmptyTuple]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[1]) -&gt; Iter[Tuple1[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[2]) -&gt; Iter[Tuple2[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[3]) -&gt; Iter[Tuple3[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[4]) -&gt; Iter[Tuple4[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[5]) -&gt; Iter[Tuple5[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[6]) -&gt; Iter[Tuple6[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[7]) -&gt; Iter[Tuple7[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: Literal[8]) -&gt; Iter[Tuple8[T]]:\n        ...\n\n    @overload\n    def combinations_with_replacement(self, count: int) -&gt; Iter[DynamicTuple[T]]:\n        ...\n\n    def combinations_with_replacement(self, count: int) -&gt; Iter[DynamicTuple[T]]:\n        return self.create(combinations_with_replacement(count, self.iterator))\n\n    def permute(self) -&gt; Iter[DynamicTuple[T]]:\n        return self.create(permute(self.iterator))\n\n    @overload\n    def permutations(self, count: Literal[0]) -&gt; Iter[EmptyTuple]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[1]) -&gt; Iter[Tuple1[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[2]) -&gt; Iter[Tuple2[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[3]) -&gt; Iter[Tuple3[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[4]) -&gt; Iter[Tuple4[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[5]) -&gt; Iter[Tuple5[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[6]) -&gt; Iter[Tuple6[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[7]) -&gt; Iter[Tuple7[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: Literal[8]) -&gt; Iter[Tuple8[T]]:\n        ...\n\n    @overload\n    def permutations(self, count: int) -&gt; Iter[DynamicTuple[T]]:\n        ...\n\n    def permutations(self, count: int) -&gt; Iter[DynamicTuple[T]]:\n        return self.create(permutations(count, self.iterator))\n\n    def power_set(self) -&gt; Iter[DynamicTuple[T]]:\n\"\"\"Computes the power set of the iterator.\n\n        The power set of $S$ contains all subsets of $S$, including\n        the empty set $\\\\varnothing$ and $S$ itself.\n        The power set is often denoted as $2^S$ since if $|S| = n$, then $|2^S| = 2^n$.\n\n        Returns:\n            An iterator over the power set of the iterator.\n        \"\"\"\n        return self.create(power_set(self.iterator))\n\n    def reverse(self) -&gt; Iter[T]:\n        return self.create(reverse(self.iterator))\n\n    def sorted(self: Iter[ST]) -&gt; List[ST]:\n        return sorted(self.iterator)\n\n    def sorted_by(self, key: Unary[T, ST]) -&gt; List[T]:\n        return sorted(self.iterator, key=key)\n\n    def sorted_reverse(self: Iter[ST]) -&gt; List[ST]:\n        return sorted(self.iterator, reverse=True)\n\n    def sorted_reverse_by(self, key: Unary[T, ST]) -&gt; List[T]:\n        return sorted(self.iterator, key=key, reverse=True)\n\n    def sort(self: Iter[ST]) -&gt; Iter[ST]:\n        return self.create(sort(self.iterator))\n\n    def sort_by(self, key: Unary[T, ST]) -&gt; Iter[T]:\n        return self.create(sort(self.iterator, key=key))\n\n    def sort_reverse(self: Iter[ST]) -&gt; Iter[ST]:\n        return self.create(sort(self.iterator, reverse=True))\n\n    def sort_reverse_by(self, key: Unary[T, ST]) -&gt; Iter[T]:\n        return self.create(sort(self.iterator, key=key, reverse=True))\n\n    def is_sorted(self: Iter[LT]) -&gt; bool:\n        return is_sorted(self.iterator)\n\n    def is_sorted_by(self, key: Unary[T, LT]) -&gt; bool:\n        return is_sorted(self.iterator, key)\n\n    def is_sorted_reverse(self: Iter[LT]) -&gt; bool:\n        return is_sorted(self.iterator, reverse=True)\n\n    def is_sorted_reverse_by(self, key: Unary[T, LT]) -&gt; bool:\n        return is_sorted(self.iterator, key, reverse=True)\n\n    def is_sorted_strict(self: Iter[ST]) -&gt; bool:\n        return is_sorted(self.iterator, strict=True)\n\n    def is_sorted_strict_by(self, key: Unary[T, ST]) -&gt; bool:\n        return is_sorted(self.iterator, key, strict=True)\n\n    def is_sorted_reverse_strict(self: Iter[ST]) -&gt; bool:\n        return is_sorted(self.iterator, strict=True, reverse=True)\n\n    def is_sorted_reverse_strict_by(self, key: Unary[T, ST]) -&gt; bool:\n        return is_sorted(self.iterator, key, strict=True, reverse=True)\n\n    def duplicates_fast(self: Iter[Q]) -&gt; Iter[Q]:\n        return self.create(duplicates_fast(self.iterator))\n\n    def duplicates_fast_by(self, key: Unary[T, Q]) -&gt; Iter[T]:\n        return self.create(duplicates_fast(self.iterator, key))\n\n    def duplicates(self) -&gt; Iter[T]:\n        return self.create(duplicates(self.iterator))\n\n    def duplicates_by(self, key: Unary[T, V]) -&gt; Iter[T]:\n        return self.create(duplicates(self.iterator, key))\n\n    def unique_fast(self: Iter[Q]) -&gt; Iter[Q]:\n        return self.create(unique_fast(self.iterator))\n\n    def unique_fast_by(self, key: Unary[T, Q]) -&gt; Iter[T]:\n        return self.create(unique_fast(self.iterator, key))\n\n    def unique(self) -&gt; Iter[T]:\n\"\"\"Creates an iterator over the unique items in the iterator.\n\n        This function may be slower than [`unique_fast`][iters.iters.Iter.unique_fast]\n        in case `T` is not [`Hashable`][typing.Hashable].\n\n        To be precise, this function is $O(n)$ for hashable items, and $O(n^2)$ otherwise.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; iterator = iter.of(0, 1, 1, 0, 1, 1, 1, 0)\n            &gt;&gt;&gt; iterator.unique().tuple()\n            (0, 1)\n            ```\n\n        Returns:\n            An iterator over the unique items in the iterator.\n        \"\"\"\n        return self.create(unique(self.iterator))\n\n    def unique_by(self, key: Unary[T, V]) -&gt; Iter[T]:\n\"\"\"Creates an iterator over the unique items in the iterator based on the given `key`.\n\n        This function may be slower than [`unique_fast_by`][iters.iters.Iter.unique_fast_by]\n        in case `V` is not [`Hashable`][typing.Hashable].\n\n        To be precise, this function is $O(n)$ for hashable items, and $O(n^2)$ otherwise.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; iterator = iter.of(0, 1, -1)\n            &gt;&gt;&gt; iterator.unique_by(abs).tuple()\n            (0, 1)\n            ```\n\n        Arguments:\n            key: The key to use in determining uniqueness.\n\n        Returns:\n            An iterator over the unique items in the iterator based on the given `key`.\n        \"\"\"\n        return self.create(unique(self.iterator, key))\n\n    def partition(self, predicate: Optional[Predicate[T]]) -&gt; Pair[Iter[T]]:\n\"\"\"Partitions the iterator into two iterators *safely* based on the given `predicate`,\n        loading **all** items into memory!\n\n        See [predicates](/predicates) for more information on the `predicate` argument.\n\n        Example:\n            Suppose we have the following function:\n\n            ```python\n            def is_positive(z: int) -&gt; bool:\n                return z &gt; 0\n            ```\n\n            Then\n\n            ```python\n            &gt;&gt;&gt; iterator = iter.of(-1, 0, 1)\n            &gt;&gt;&gt; positive, non_positive = iterator.partition(is_positive)\n            &gt;&gt;&gt; positive.list()\n            [1]\n            &gt;&gt;&gt; non_positive.list()\n            [-1, 0]\n            ```\n\n        Note:\n            This method exhausts the underlying iterator.\n\n        Arguments:\n            predicate: The predicate to use in partitioning the iterator.\n\n        Returns:\n            A tuple of two iterators, the former containing the items that match the predicate,\n            and the latter containing items that do *not* match the predicate.\n        \"\"\"\n        true, false = partition(predicate, self.iterator)\n\n        return (self.create(true), self.create(false))\n\n    def partition_unsafe(self, predicate: Optional[Predicate[T]]) -&gt; Pair[Iter[T]]:\n\"\"\"Partitions the iterator into two iterators *unsafely* based on the given `predicate`.\n\n        See [predicates](/predicates) for more information on the `predicate` argument.\n\n        Example:\n            Suppose we have the following function:\n\n            ```python\n            def is_negative(z: int) -&gt; bool:\n                return z &lt; 0\n            ```\n\n            Then\n\n            ```python\n            &gt;&gt;&gt; iterator = iter.of(-1, 0, 1)\n            &gt;&gt;&gt; negative, non_negative = iterator.partition_unsafe(is_negative)\n            &gt;&gt;&gt; non_negative.list()\n            [0, 1]\n            &gt;&gt;&gt; negative.list()\n            [-1]\n            ```\n\n        Warning:\n            This method is not thread-safe!\n\n        Note:\n            This method works on the underlying iterator, so using the original iterator\n            is not recommended after calling this method.\n\n        Arguments:\n            predicate: The predicate to use in partitioning the iterator.\n\n        Returns:\n            A tuple of two iterators, the former containing the items that match the predicate,\n            and the latter containing items that do *not* match the predicate.\n        \"\"\"\n        true, false = partition_unsafe(predicate, self.iterator)\n\n        return (self.create(true), self.create(false))\n\n    partition_infinite = partition_unsafe\n\"\"\"An alias of [`partition_unsafe`][iters.iters.Iter.partition_unsafe],\n    since partitioning infinite iterators can only be done *unsafely*.\n    \"\"\"\n\n    def copy(self) -&gt; Iter[T]:\n\"\"\"Copies the iterator *safely*, loading **all** items into memory!\n\n        Example:\n            ```python\n            &gt;&gt;&gt; iterator = iter.of(1, 2, 3)\n            &gt;&gt;&gt; copy = iterator.copy()\n            &gt;&gt;&gt; iterator.tuple()\n            (1, 2, 3)\n            &gt;&gt;&gt; copy.tuple()\n            (1, 2, 3)\n            ```\n\n        Note:\n            This method replaces the underlying iterator.\n\n        Returns:\n            A copy of the iterator.\n        \"\"\"\n        iterator, copied = copy(self.iterator)\n\n        self._replace(iterator)\n\n        return self.create(copied)\n\n    def copy_unsafe(self) -&gt; Iter[T]:\n\"\"\"Copies the iterator *unsafely*.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; iterator = iter.of(13, 42, 69)\n            &gt;&gt;&gt; copy = iterator.copy_unsafe()\n            &gt;&gt;&gt; iterator.zip(copy).tuple()\n            ((13, 13), (42, 42), (69, 69))\n            ```\n\n        Warning:\n            This method is not thread-safe!\n\n        Note:\n            This method replaces the underlying iterator.\n\n        Returns:\n            A copy of the iterator.\n        \"\"\"\n        iterator, copied = copy_unsafe(self.iterator)\n\n        self._replace(iterator)\n\n        return self.create(copied)\n\n    copy_infinite = copy_unsafe\n\"\"\"An alias of [`copy_unsafe`][iters.iters.Iter.copy_unsafe],\n    since copying infinite iterators can only be done *unsafely*.\n    \"\"\"\n\n    def spy(self, size: int) -&gt; List[T]:\n\"\"\"Spies on at most `size` next items of the iterator, without consuming them.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; iterator = iter.of(13, 34, 42)\n            &gt;&gt;&gt; iterator.spy(2)\n            [13, 34]\n            &gt;&gt;&gt; iterator.spy(4)\n            [13, 34, 42]\n            &gt;&gt;&gt; iterator.next()\n            Some(13)\n            ```\n\n        Note:\n            This method replaces the underlying iterator.\n\n        Arguments:\n            size: The amount of items to spy on.\n\n        Returns:\n            Up to `size` next items of the iterator.\n        \"\"\"\n        result, iterator = spy(size, self.iterator)\n\n        self._replace(iterator)\n\n        return result\n\n    def peek(self) -&gt; Option[T]:\n\"\"\"Peeks at the next item in the iterator, without consuming it.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; iterator = iter.of(13, 34, 42)\n            &gt;&gt;&gt; iterator.peek()\n            Some(13)\n            &gt;&gt;&gt; iterator.next()\n            Some(13)\n            ```\n\n        Note:\n            This method replaces the underlying iterator.\n\n        Returns:\n            The next item in the iterator, if one exists.\n        \"\"\"\n        item, iterator = peek(self.iterator, marker)\n\n        self._replace(iterator)\n\n        return wrap_marked(item)\n\n    def has_next(self) -&gt; bool:\n\"\"\"Checks if the iterator has a next item (i.e. is non-empty).\n\n        Example:\n            ```python\n            &gt;&gt;&gt; assert iter.once(1).has_next()\n            &gt;&gt;&gt; assert not iter.empty().has_next()\n            ```\n\n        Note:\n            This method replaces the underlying iterator.\n\n        Returns:\n            Whether the iterator has a next item.\n        \"\"\"\n        result, iterator = has_next(self.iterator)\n\n        self._replace(iterator)\n\n        return result\n\n    def is_empty(self) -&gt; bool:\n\"\"\"Checks if the iterator is empty.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; assert iter.empty().is_empty()\n            &gt;&gt;&gt; assert not iter.once(0).is_empty()\n            ```\n\n        Note:\n            This method replaces the underlying iterator.\n\n        Returns:\n            Whether the iterator is empty.\n        \"\"\"\n        result, iterator = is_empty(self.iterator)\n\n        self._replace(iterator)\n\n        return result\n\n    def repeat_last(self) -&gt; Iter[T]:\n\"\"\"Repeats the last item of the iterator indefinitely.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; iterator = iter.of(0, 1)\n            &gt;&gt;&gt; iterator.next()\n            Some(0)\n            &gt;&gt;&gt; iterator.next()\n            Some(1)\n            &gt;&gt;&gt; iterator.next()\n            Some(1)  # now repeating the last item\n            ```\n\n        Returns:\n            The iterator with the last item repeated indefinitely.\n        \"\"\"\n        return self.create(repeat_last(self.iterator))\n\n    def repeat_each(self, count: int) -&gt; Iter[T]:\n\"\"\"Repeat each item of the iterator `count` times.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; iter.of(0, 1).repeat_each(2).tuple()\n            (0, 0, 1, 1)\n            ```\n\n            ```python\n            &gt;&gt;&gt; iter.once(0).repeat_each(0).tuple()\n            ()\n            ```\n\n        Arguments:\n            count: The amount of times to repeat each item.\n\n        Returns:\n            The iterator with each item repeated `count` times.\n        \"\"\"\n        return self.create(repeat_each(count, self.iterator))\n\n    def inspect(self, function: Inspect[T]) -&gt; Iter[T]:\n\"\"\"Inspects each item of the iterator with the given `function`.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; iter.of(1, 2, 3).inspect(print).consume()\n            1\n            2\n            3\n            ```\n\n        Arguments:\n            function: The inspecting function.\n\n        Returns:\n            The original iterator.\n        \"\"\"\n        return self.create(inspect(function, self.iterator))\n\n    def scan(self, state: V, function: Binary[V, T, Option[U]]) -&gt; Iter[U]:\n        return self.create(scan(state, function, self.iterator))\n\n    def filter_map_option(self, function: Unary[T, Option[U]]) -&gt; Iter[U]:\n        return self.create(filter_map_option(function, self.iterator))\n\n    # def transpose_option(self: Iter[Option[U]]) -&gt; Option[Iter[U]]:\n    #     return self.create_option(transpose_option(self.iterator))\n\n    def into_async_iter(self) -&gt; AsyncIter[T]:\n\"\"\"Converts an [`Iter[T]`][iters.iters.Iter] into\n        an [`AsyncIter[T]`][iters.async_iters.AsyncIter].\n\n        Example:\n            ```python\n            &gt;&gt;&gt; async_iterator = iter.of(13, 34, 42).into_async_iter()\n            &gt;&gt;&gt; await async_iterator.tuple()\n            (13, 34, 42)\n            ```\n\n        Returns:\n            The async iterator created from the iterator.\n        \"\"\"\n        return async_iter(self.iterator)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.iterator","title":"<code>iterator: Iterator[T]</code>  <code>property</code>","text":"<p>The underlying iterator.</p>"},{"location":"reference/iters/#iters.iters.Iter.partition_infinite","title":"<code>partition_infinite = partition_unsafe</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An alias of <code>partition_unsafe</code>, since partitioning infinite iterators can only be done unsafely.</p>"},{"location":"reference/iters/#iters.iters.Iter.copy_infinite","title":"<code>copy_infinite = copy_unsafe</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An alias of <code>copy_unsafe</code>, since copying infinite iterators can only be done unsafely.</p>"},{"location":"reference/iters/#iters.iters.Iter.empty","title":"<code>empty() -&gt; Iter[T]</code>  <code>classmethod</code>","text":"<p>Creates an empty iterator.</p> Example <pre><code>&gt;&gt;&gt; iterator = iter.empty()\n&gt;&gt;&gt; iterator.next()\nNull()\n</code></pre> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>An empty iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef empty(cls) -&gt; Iter[T]:\n\"\"\"Creates an empty iterator.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; iterator = iter.empty()\n        &gt;&gt;&gt; iterator.next()\n        Null()\n        ```\n\n    Returns:\n        An empty iterator.\n    \"\"\"\n    return cls.create(empty())\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.of","title":"<code>of(*items: V) -&gt; Iter[V]</code>  <code>classmethod</code>","text":"<p>Creates an iterator from <code>items</code>.</p> Example <pre><code>&gt;&gt;&gt; iterator = iter.of(13, 42, 69)\n&gt;&gt;&gt; iterator.next()\nSome(13)\n&gt;&gt;&gt; iterator.next()\nSome(42)\n&gt;&gt;&gt; iterator.next()\nSome(69)\n&gt;&gt;&gt; iterator.next()\nNull()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*items</code> <code>V</code> <p>The items to iterate over.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[V]</code> <p>An iterator over <code>items</code>.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef of(cls, *items: V) -&gt; Iter[V]:\n\"\"\"Creates an iterator from `items`.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; iterator = iter.of(13, 42, 69)\n        &gt;&gt;&gt; iterator.next()\n        Some(13)\n        &gt;&gt;&gt; iterator.next()\n        Some(42)\n        &gt;&gt;&gt; iterator.next()\n        Some(69)\n        &gt;&gt;&gt; iterator.next()\n        Null()\n        ```\n\n    Arguments:\n        *items: The items to iterate over.\n\n    Returns:\n        An iterator over `items`.\n    \"\"\"\n    return cls.create(items)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.once","title":"<code>once(value: V) -&gt; Iter[V]</code>  <code>classmethod</code>","text":"<p>Creates an iterator that yields the <code>value</code> exactly once.</p> <p>This is commonly used to adapt a single value into a <code>chain</code> of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</p> Example <pre><code>&gt;&gt;&gt; iterator = iter.once(42)\n&gt;&gt;&gt; iterator.next()\nSome(42)\n&gt;&gt;&gt; iterator.next()\nNull()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V</code> <p>The value to yield.</p> required <p>Returns:</p> Type Description <code>Iter[V]</code> <p>An <code>Iter[V]</code> with <code>value</code>.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef once(cls, value: V) -&gt; Iter[V]:\n\"\"\"Creates an iterator that yields the `value` exactly once.\n\n    This is commonly used to adapt a single value into a [`chain`][iters.iters.Iter.chain]\n    of other kinds of iteration. Maybe you have an iterator that covers almost everything,\n    but you need an extra special case. Maybe you have a function which works on iterators,\n    but you only need to process one value.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; iterator = iter.once(42)\n        &gt;&gt;&gt; iterator.next()\n        Some(42)\n        &gt;&gt;&gt; iterator.next()\n        Null()\n        ```\n\n    Arguments:\n        value: The value to yield.\n\n    Returns:\n        An [`Iter[V]`][iters.iters.Iter] with `value`.\n    \"\"\"\n    return cls.create(once(value))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.once_with","title":"<code>once_with(function: Nullary[V]) -&gt; Iter[V]</code>  <code>classmethod</code>","text":"<p>Creates an iterator that lazily generates an item exactly once by invoking the <code>function</code> provided.</p> <p>This is commonly used to adapt a single value into a <code>chain</code> of other kinds of iteration. Maybe you have an iterator that covers almost everything, but you need an extra special case. Maybe you have a function which works on iterators, but you only need to process one value.</p> <p>Unlike <code>once</code>, this function will lazily generate the item on request.</p> Example <pre><code>&gt;&gt;&gt; iterator = iter.once_with(tuple)\n&gt;&gt;&gt; iterator.next()\nSome(())\n&gt;&gt;&gt; iterator.next()\nNull()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Nullary[V]</code> <p>The value-generating function to use.</p> required <p>Returns:</p> Type Description <code>Iter[V]</code> <p>An <code>Iter[V]</code> with the generated <code>value</code>.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef once_with(cls, function: Nullary[V]) -&gt; Iter[V]:\n\"\"\"Creates an iterator that lazily generates an item exactly once\n    by invoking the `function` provided.\n\n    This is commonly used to adapt a single value into a [`chain`][iters.iters.Iter.chain]\n    of other kinds of iteration. Maybe you have an iterator that covers almost everything,\n    but you need an extra special case. Maybe you have a function which works on iterators,\n    but you only need to process one value.\n\n    Unlike [`once`][iters.iters.Iter.once], this function will\n    lazily generate the item on request.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; iterator = iter.once_with(tuple)\n        &gt;&gt;&gt; iterator.next()\n        Some(())\n        &gt;&gt;&gt; iterator.next()\n        Null()\n        ```\n\n    Arguments:\n        function: The value-generating function to use.\n\n    Returns:\n        An [`Iter[V]`][iters.iters.Iter] with the generated `value`.\n    \"\"\"\n    return cls.create(once_with(function))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.repeat","title":"<code>repeat(value: V) -&gt; Iter[V]</code>  <code>classmethod</code>","text":"<p>Creates an iterator that endlessly repeats a single <code>value</code>.</p> <p>This function repeats a single value over and over again.</p> <p>Infinite iterators like <code>repeat</code> are often used with adapters like <code>take</code>, in order to make them finite.</p> Example <pre><code>&gt;&gt;&gt; fours = iter.repeat(4)\n&gt;&gt;&gt; fours.next()\nSome(4)\n&gt;&gt;&gt; fours.next()\nSome(4)\n&gt;&gt;&gt; fours.next()\nSome(4)\n&gt;&gt;&gt; # ad infinitum...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V</code> <p>The value to repeat.</p> required <p>Returns:</p> Type Description <code>Iter[V]</code> <p>An infinite <code>Iter[V]</code> with repeated <code>value</code>.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef repeat(cls, value: V) -&gt; Iter[V]:\n\"\"\"Creates an iterator that endlessly repeats a single `value`.\n\n    This function repeats a single value over and over again.\n\n    Infinite iterators like [`repeat`][iters.iters.Iter.repeat]\n    are often used with adapters like [`take`][iters.iters.Iter.take],\n    in order to make them finite.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; fours = iter.repeat(4)\n        &gt;&gt;&gt; fours.next()\n        Some(4)\n        &gt;&gt;&gt; fours.next()\n        Some(4)\n        &gt;&gt;&gt; fours.next()\n        Some(4)\n        &gt;&gt;&gt; # ad infinitum...\n        ```\n\n    Arguments:\n        value: The value to repeat.\n\n    Returns:\n        An infinite [`Iter[V]`][iters.iters.Iter] with repeated `value`.\n    \"\"\"\n    return cls.create(repeat(value))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.repeat_exactly","title":"<code>repeat_exactly(value: V, count: int) -&gt; Iter[V]</code>  <code>classmethod</code>","text":"<p>Creates an iterator that repeats a single <code>value</code> exactly <code>count</code> times.</p> <p>This function is a shorthand for <code>iter.repeat(value).take(count)</code>.</p> Example <pre><code># let's only have four fours\niterator = iter.repeat_exactly(4, 4)\n\nassert iterator.list() == [4, 4, 4, 4]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V</code> <p>The value to repeat.</p> required <code>count</code> <code>int</code> <p>The number of times to repeat the <code>value</code>.</p> required <p>Returns:</p> Type Description <code>Iter[V]</code> <p>An <code>Iter[V]</code> with <code>value</code> repeated <code>count</code> times.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef repeat_exactly(cls, value: V, count: int) -&gt; Iter[V]:\n\"\"\"Creates an iterator that repeats a single `value` exactly `count` times.\n\n    This function is a shorthand for [`iter.repeat(value).take(count)`][iters.iters.Iter.take].\n\n    Example:\n        ```python\n        # let's only have four fours\n        iterator = iter.repeat_exactly(4, 4)\n\n        assert iterator.list() == [4, 4, 4, 4]\n        ```\n\n    Arguments:\n        value: The value to repeat.\n        count: The number of times to repeat the `value`.\n\n    Returns:\n        An [`Iter[V]`][iters.iters.Iter] with `value` repeated `count` times.\n    \"\"\"\n    return cls.create(repeat(value, count))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.repeat_with","title":"<code>repeat_with(function: Nullary[V]) -&gt; Iter[V]</code>  <code>classmethod</code>","text":"<p>Creates an iterator that endlessly generates values.</p> <p>This function repeats generated values over and over again.</p> <p>Infinite iterators like <code>repeat_with</code> are often used with adapters like <code>take</code>, in order to make them finite.</p> Example <pre><code>iterator = iter.repeat_with(tuple)\n\nassert iterator.next().unwrap() == ()\nassert iterator.next().unwrap() == ()\nassert iterator.next().unwrap() == ()\n\n# ... ad infinitum\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Nullary[V]</code> <p>The value-generating function to use.</p> required <p>Returns:</p> Type Description <code>Iter[V]</code> <p>An infinite <code>Iter[V]</code> with repeated <code>value</code> of type <code>V</code>.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef repeat_with(cls, function: Nullary[V]) -&gt; Iter[V]:\n\"\"\"Creates an iterator that endlessly generates values.\n\n    This function repeats generated values over and over again.\n\n    Infinite iterators like [`repeat_with`][iters.iters.Iter.repeat_with]\n    are often used with adapters like [`take`][iters.iters.Iter.take],\n    in order to make them finite.\n\n    Example:\n        ```python\n        iterator = iter.repeat_with(tuple)\n\n        assert iterator.next().unwrap() == ()\n        assert iterator.next().unwrap() == ()\n        assert iterator.next().unwrap() == ()\n\n        # ... ad infinitum\n        ```\n\n    Arguments:\n        function: The value-generating function to use.\n\n    Returns:\n        An infinite [`Iter[V]`][iters.iters.Iter] with repeated `value` of type `V`.\n    \"\"\"\n    return cls.create(repeat_with(function))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.repeat_exactly_with","title":"<code>repeat_exactly_with(function: Nullary[V], count: int) -&gt; Iter[V]</code>  <code>classmethod</code>","text":"<p>Creates an iterator that generates values of type <code>V</code> exactly <code>count</code> times.</p> <p>This function is a shorthand for <code>iter.repeat_with(function).take(count)</code>.</p> Example <pre><code>assert iter.repeat_exactly_with(tuple, 3).tuple() == ((), (), ())  # tuple triple!\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Nullary[V]</code> <p>The value-generating function to use.</p> required <code>count</code> <code>int</code> <p>The number of times to repeat values.</p> required <p>Returns:</p> Type Description <code>Iter[V]</code> <p>An <code>Iter[V]</code> with repeated <code>value</code> of type <code>V</code> exactly <code>count</code> times.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef repeat_exactly_with(cls, function: Nullary[V], count: int) -&gt; Iter[V]:\n\"\"\"Creates an iterator that generates values of type `V` exactly `count` times.\n\n    This function is a shorthand for\n    [`iter.repeat_with(function).take(count)`][iters.iters.Iter.take].\n\n    Example:\n        ```python\n        assert iter.repeat_exactly_with(tuple, 3).tuple() == ((), (), ())  # tuple triple!\n        ```\n\n    Arguments:\n        function: The value-generating function to use.\n        count: The number of times to repeat values.\n\n    Returns:\n        An [`Iter[V]`][iters.iters.Iter] with repeated\n            `value` of type `V` exactly `count` times.\n    \"\"\"\n    return cls.create(repeat_with(function, count))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.count_from_by","title":"<code>count_from_by(start: int, step: int) -&gt; Iter[int]</code>  <code>classmethod</code>","text":"<p>Creates an iterator of evenly spaced (by <code>step</code>) values starting from <code>start</code>.</p> Example <pre><code>iterator = iter.count_from_by(1, 2)\n\nassert iterator.next() == 1\nassert iterator.next() == 3\nassert iterator.next() == 5\nassert iterator.next() == 7\nassert iterator.next() == 9\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>The value to start from.</p> required <code>step</code> <code>int</code> <p>The value to step by.</p> required <p>Returns:</p> Type Description <code>Iter[int]</code> <p>An <code>Iter[int]</code> over evenly spaced values.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef count_from_by(cls, start: int, step: int) -&gt; Iter[int]:\n\"\"\"Creates an iterator of evenly spaced (by `step`) values starting from `start`.\n\n    Example:\n        ```python\n        iterator = iter.count_from_by(1, 2)\n\n        assert iterator.next() == 1\n        assert iterator.next() == 3\n        assert iterator.next() == 5\n        assert iterator.next() == 7\n        assert iterator.next() == 9\n        ```\n\n    Arguments:\n        start: The value to start from.\n        step: The value to step by.\n\n    Returns:\n        An [`Iter[int]`][iters.iters.Iter] over evenly spaced values.\n    \"\"\"\n    return cls.create(count(start, step))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.count_from","title":"<code>count_from(start: int) -&gt; Iter[int]</code>  <code>classmethod</code>","text":"<p>Creates an iterator of evenly spaced (by <code>1</code>) values starting from <code>start</code>.</p> <p>This is a shorthand for:</p> <pre><code>iter.count_from_by(start, 1)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>The value to start from.</p> required <p>Returns:</p> Type Description <code>Iter[int]</code> <p>An <code>Iter[int]</code> over evenly spaced values.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef count_from(cls, start: int) -&gt; Iter[int]:\n\"\"\"Creates an iterator of evenly spaced (by `1`) values starting from `start`.\n\n    This is a shorthand for:\n\n    ```python\n    iter.count_from_by(start, 1)\n    ```\n\n    Arguments:\n        start: The value to start from.\n\n    Returns:\n        An [`Iter[int]`][iters.iters.Iter] over evenly spaced values.\n    \"\"\"\n    return cls.count_from_by(start, DEFAULT_STEP)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.count_by","title":"<code>count_by(step: int) -&gt; Iter[int]</code>  <code>classmethod</code>","text":"<p>Creates an iterator of evenly spaced (by <code>step</code>) values starting from <code>0</code>.</p> <p>This is a shorthand for:</p> <pre><code>iter.count_from_by(0, step)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>int</code> <p>The value to step by.</p> required <p>Returns:</p> Type Description <code>Iter[int]</code> <p>An <code>Iter[int]</code> over evenly spaced values.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef count_by(cls, step: int) -&gt; Iter[int]:\n\"\"\"Creates an iterator of evenly spaced (by `step`) values starting from `0`.\n\n    This is a shorthand for:\n\n    ```python\n    iter.count_from_by(0, step)\n    ```\n\n    Arguments:\n        step: The value to step by.\n\n    Returns:\n        An [`Iter[int]`][iters.iters.Iter] over evenly spaced values.\n    \"\"\"\n    return cls.count_from_by(DEFAULT_START, step)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.count","title":"<code>count() -&gt; Iter[int]</code>  <code>classmethod</code>","text":"<p>Creates an iterator of evenly spaced (by <code>1</code>) values starting from <code>0</code>.</p> <p>This is a shorthand for:</p> <pre><code>iter.count_from_by(0, 1)\n</code></pre> <p>Returns:</p> Type Description <code>Iter[int]</code> <p>An <code>Iter[int]</code> over evenly spaced values.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef count(cls) -&gt; Iter[int]:\n\"\"\"Creates an iterator of evenly spaced (by `1`) values starting from `0`.\n\n    This is a shorthand for:\n\n    ```python\n    iter.count_from_by(0, 1)\n    ```\n\n    Returns:\n        An [`Iter[int]`][iters.iters.Iter] over evenly spaced values.\n    \"\"\"\n    return cls.count_from_by(DEFAULT_START, DEFAULT_STEP)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.iterate","title":"<code>iterate(function: Unary[V, V], value: V) -&gt; Iter[V]</code>  <code>classmethod</code>","text":"<p>Creates an iterator that iterates function calls endlessly, i.e. <code>value</code>, <code>function(value)</code>, <code>function(function(value))</code>, ...</p> Example <pre><code>zero = 0\n\ndef successor(natural: int) -&gt; int:\n    return natural + 1\n\nnaturals = iter.iterate(successor, zero)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[V, V]</code> <p>The function to iterate.</p> required <code>value</code> <code>V</code> <p>The value to begin iteration with.</p> required <p>Returns:</p> Type Description <code>Iter[V]</code> <p>An <code>Iter[V]</code> over iteration results.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef iterate(cls, function: Unary[V, V], value: V) -&gt; Iter[V]:\n\"\"\"Creates an iterator that iterates function calls endlessly, i.e. `value`,\n    `function(value)`, `function(function(value))`, ...\n\n    Example:\n        ```python\n        zero = 0\n\n        def successor(natural: int) -&gt; int:\n            return natural + 1\n\n        naturals = iter.iterate(successor, zero)\n        ```\n\n    Arguments:\n        function: The function to iterate.\n        value: The value to begin iteration with.\n\n    Returns:\n        An [`Iter[V]`][iters.iters.Iter] over iteration results.\n    \"\"\"\n    return cls.create(iterate(function, value))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.iterate_exactly","title":"<code>iterate_exactly(function: Unary[V, V], value: V, count: int) -&gt; Iter[V]</code>  <code>classmethod</code>","text":"<p>Creates an iterator that iterates function calls exactly <code>count</code> times.</p> <p>This is a shorthand for <code>iter.iterate(function, value).take(count)</code>.</p> Example <pre><code>def wrap(item: T) -&gt; List[T]:\n    return [item]\n\niter.iterate_exactly(wrap, 13, 5).list() == [\n    13, [13], [[13]], [[[13]]], [[[[13]]]]\n]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[V, V]</code> <p>The function to iterate.</p> required <code>value</code> <code>V</code> <p>The value to begin iteration with.</p> required <code>count</code> <code>int</code> <p>The amount of function iterations.</p> required <p>Returns:</p> Type Description <code>Iter[V]</code> <p>An <code>Iter[V]</code> over iteration results.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef iterate_exactly(cls, function: Unary[V, V], value: V, count: int) -&gt; Iter[V]:\n\"\"\"Creates an iterator that iterates function calls exactly `count` times.\n\n    This is a shorthand for\n    [`iter.iterate(function, value).take(count)`][iters.iters.Iter.take].\n\n    Example:\n        ```python\n        def wrap(item: T) -&gt; List[T]:\n            return [item]\n\n        iter.iterate_exactly(wrap, 13, 5).list() == [\n            13, [13], [[13]], [[[13]]], [[[[13]]]]\n        ]\n        ```\n\n    Arguments:\n        function: The function to iterate.\n        value: The value to begin iteration with.\n        count: The amount of function iterations.\n\n    Returns:\n        An [`Iter[V]`][iters.iters.Iter] over iteration results.\n    \"\"\"\n    return cls.create(iterate(function, value, count))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.iter_except","title":"<code>iter_except(function: Nullary[T], *errors: AnyErrorType) -&gt; Iter[T]</code>  <code>classmethod</code>","text":"<p>Creates an iterator that repeatedly calls <code>function</code> until any of the <code>errors</code> is encountered.</p> Example <p>An interesting way to reverse arrays:</p> <pre><code>array = [1, 2, 3]\n\niter.iter_except(array.pop, IndexError).list() == [3, 2, 1]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Nullary[T]</code> <p>The function to iterate.</p> required <code>*errors</code> <code>AnyErrorType</code> <p>The errors to <code>except</code>, stopping iteration.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>An <code>Iter[T]</code> over function results.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef iter_except(cls, function: Nullary[T], *errors: AnyErrorType) -&gt; Iter[T]:\n\"\"\"Creates an iterator that repeatedly calls `function` until\n    any of the `errors` is encountered.\n\n    Example:\n        An interesting way to reverse arrays:\n\n        ```python\n        array = [1, 2, 3]\n\n        iter.iter_except(array.pop, IndexError).list() == [3, 2, 1]\n        ```\n\n    Arguments:\n        function: The function to iterate.\n        *errors: The errors to `except`, stopping iteration.\n\n    Returns:\n        An [`Iter[T]`][iters.iters.Iter] over function results.\n    \"\"\"\n    return cls.create(iter_except(function, *errors))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.iter_with","title":"<code>iter_with(context_manager: ContextManager[Iterable[T]]) -&gt; Iter[T]</code>  <code>classmethod</code>","text":"<p>Creates an iterator over the iterable returned by <code>context_manager</code>.</p> <p>This is essentially equivalent to:</p> <pre><code>def iter_with(context_manager: ContextManager[Iterable[T]]) -&gt; Iterator[T]:\n    with context_manager as iterable:\n        for item in iterable:\n            yield item\n\niterator = iter(iter_with(context_manager))\n</code></pre> <p>This function can be used to open and close files, for example; let us consider parsing some file containing integers on every line.</p> Example <pre><code>array = iter.iter_with(open(\"file.in\")).map(int).list()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>context_manager</code> <code>ContextManager[Iterable[T]]</code> <p>The context manager returning an iterable.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>An <code>Iter[T]</code> over items in an iterable.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef iter_with(cls, context_manager: ContextManager[Iterable[T]]) -&gt; Iter[T]:\n\"\"\"Creates an iterator over the iterable returned by `context_manager`.\n\n    This is essentially equivalent to:\n\n    ```python\n    def iter_with(context_manager: ContextManager[Iterable[T]]) -&gt; Iterator[T]:\n        with context_manager as iterable:\n            for item in iterable:\n                yield item\n\n    iterator = iter(iter_with(context_manager))\n    ```\n\n    This function can be used to open and close files, for example;\n    let us consider parsing some file containing integers on every line.\n\n    Example:\n        ```python\n        array = iter.iter_with(open(\"file.in\")).map(int).list()\n        ```\n\n    Arguments:\n        context_manager: The context manager returning an iterable.\n\n    Returns:\n        An [`Iter[T]`][iters.iters.Iter] over items in an iterable.\n    \"\"\"\n    return cls.create(iter_with(context_manager))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.create_chain","title":"<code>create_chain(*iterables: Iterable[T]) -&gt; Iter[T]</code>  <code>classmethod</code>","text":"<p>Creates an iterator chaining <code>iterables</code> together.</p> <p>For example, it can be used to chain arrays.</p> Example <pre><code>a = [1, 2, 3]\nb = [4, 5, 6]\nc = [7, 8, 9]\n\nassert iter.create_chain(a, b, c).list() == a + b + c\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[T]</code> <p>Iterables to chain together.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>An <code>Iter[T]</code> over chained iterables.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef create_chain(cls, *iterables: Iterable[T]) -&gt; Iter[T]:\n\"\"\"Creates an iterator chaining `iterables` together.\n\n    For example, it can be used to chain arrays.\n\n    Example:\n        ```python\n        a = [1, 2, 3]\n        b = [4, 5, 6]\n        c = [7, 8, 9]\n\n        assert iter.create_chain(a, b, c).list() == a + b + c\n        ```\n\n    Arguments:\n        *iterables: Iterables to chain together.\n\n    Returns:\n        An [`Iter[T]`][iters.iters.Iter] over chained iterables.\n    \"\"\"\n    return cls.create(chain(*iterables))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.create_chain_with","title":"<code>create_chain_with(iterable: Iterable[Iterable[T]]) -&gt; Iter[T]</code>  <code>classmethod</code>","text":"<p>Creates an iterator chaining iterables in the <code>iterable</code> together.</p> <p>This function essentially flattens the <code>iterable</code> provided.</p> Example <pre><code>matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n]\n\nresult = 45\n\nassert iter.create_chain_with(matrix).sum() == result\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[Iterable[T]]</code> <p>The iterable of iterables to chain.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>An <code>Iter[T]</code> over chained iterables.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef create_chain_with(cls, iterable: Iterable[Iterable[T]]) -&gt; Iter[T]:\n\"\"\"Creates an iterator chaining iterables in the `iterable` together.\n\n    This function essentially flattens the `iterable` provided.\n\n    Example:\n        ```python\n        matrix = [\n            [1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9],\n        ]\n\n        result = 45\n\n        assert iter.create_chain_with(matrix).sum() == result\n        ```\n\n    Arguments:\n        iterable: The iterable of iterables to chain.\n\n    Returns:\n        An [`Iter[T]`][iters.iters.Iter] over chained iterables.\n    \"\"\"\n    return cls.create(chain_from_iterable(iterable))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.create_combine","title":"<code>create_combine(*iterables: Iterable[T]) -&gt; Iter[T]</code>  <code>classmethod</code>","text":"<p>Creates an iterator combining <code>iterables</code>.</p> <p>This method is a slightly different version of <code>create_interleave_longest</code>.</p> Example <pre><code>a = [1, 2, 3]\nb = [4, 5, 6]\nc = [1, 4, 2, 5, 3, 6]\n\nassert iter.combine(a, b).list() == c\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[T]</code> <p>Iterables to combine.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>An <code>Iter[T]</code> over combined iterables.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef create_combine(cls, *iterables: Iterable[T]) -&gt; Iter[T]:\n\"\"\"Creates an iterator combining `iterables`.\n\n    This method is a slightly different version of\n    [`create_interleave_longest`][iters.iters.Iter.create_interleave_longest].\n\n    Example:\n        ```python\n        a = [1, 2, 3]\n        b = [4, 5, 6]\n        c = [1, 4, 2, 5, 3, 6]\n\n        assert iter.combine(a, b).list() == c\n        ```\n\n    Arguments:\n        *iterables: Iterables to combine.\n\n    Returns:\n        An [`Iter[T]`][iters.iters.Iter] over combined iterables.\n    \"\"\"\n    return cls.create(combine(*iterables))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.create_interleave","title":"<code>create_interleave(*iterables: Iterable[T]) -&gt; Iter[T]</code>  <code>classmethod</code>","text":"<p>Creates an iterator interleaving <code>iterables</code>.</p> Note <p>This method stops when the shortest iterable is exhausted.</p> Example <pre><code>a = [1, 2, 3]\nb = [4, 5, 6, 7, 8, 9]\nc = [1, 4, 2, 5, 3, 6]\n\nassert iter.create_interleave(a, b).list() == c\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[T]</code> <p>Iterables to interleave.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>An <code>Iter[T]</code> over interleft iterables.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef create_interleave(cls, *iterables: Iterable[T]) -&gt; Iter[T]:\n\"\"\"Creates an iterator interleaving `iterables`.\n\n    Note:\n        This method stops when the shortest iterable is exhausted.\n\n    Example:\n        ```python\n        a = [1, 2, 3]\n        b = [4, 5, 6, 7, 8, 9]\n        c = [1, 4, 2, 5, 3, 6]\n\n        assert iter.create_interleave(a, b).list() == c\n        ```\n\n    Arguments:\n        *iterables: Iterables to interleave.\n\n    Returns:\n        An [`Iter[T]`][iters.iters.Iter] over interleft iterables.\n    \"\"\"\n    return cls.create(interleave(*iterables))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.create_interleave_longest","title":"<code>create_interleave_longest(*iterables: Iterable[T]) -&gt; Iter[T]</code>  <code>classmethod</code>","text":"<p>Creates an iterator interleaving <code>iterables</code>.</p> <p>This method is a slightly different version of <code>create_combine</code>.</p> Example <pre><code>a = [1, 2, 3]\nb = [4, 5, 6, 7, 8, 9]\nc = [1, 4, 2, 5, 3, 6, 7, 8, 9]\n\nassert iter.create_interleave_longest(a, b).list() == c\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[T]</code> <p>Iterables to interleave.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>An <code>Iter[T]</code> over interleft iterables.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef create_interleave_longest(cls, *iterables: Iterable[T]) -&gt; Iter[T]:\n\"\"\"Creates an iterator interleaving `iterables`.\n\n    This method is a slightly different version of\n    [`create_combine`][iters.iters.Iter.create_combine].\n\n    Example:\n        ```python\n        a = [1, 2, 3]\n        b = [4, 5, 6, 7, 8, 9]\n        c = [1, 4, 2, 5, 3, 6, 7, 8, 9]\n\n        assert iter.create_interleave_longest(a, b).list() == c\n        ```\n\n    Arguments:\n        *iterables: Iterables to interleave.\n\n    Returns:\n        An [`Iter[T]`][iters.iters.Iter] over interleft iterables.\n    \"\"\"\n    return cls.create(interleave_longest(*iterables))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.create_zip","title":"<code>create_zip(*iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Any]]</code>  <code>classmethod</code>","text":"<p>Zips <code>iterables</code> into an iterator of tuples, where the i-th tuple contains the i-th item from each of the iterables.</p> Note <p>This method stops when the shortest iterable is exhausted.</p> Example <pre><code>x = (1, 2, 3, 4, 5)\n\ny = \"nekit\"\n\niter.create_zip(x, y).list() == [(1, \"n\"), (2, \"e\"), (3, \"k\"), (4, \"i\"), (5, \"t\")]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[Any]</code> <p>Iterables to zip.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[DynamicTuple[Any]]</code> <p>An <code>Iter[Tuple[...]]</code> over zipped tuples.</p> Source code in <code>iters/iters.py</code> <pre><code>@no_type_check\n@classmethod\ndef create_zip(cls, *iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Any]]:\n\"\"\"Zips `iterables` into an iterator of tuples, where\n    the *i*-th tuple contains the *i*-th item from each of the iterables.\n\n    Note:\n        This method stops when the shortest iterable is exhausted.\n\n    Example:\n        ```python\n        x = (1, 2, 3, 4, 5)\n\n        y = \"nekit\"\n\n        iter.create_zip(x, y).list() == [(1, \"n\"), (2, \"e\"), (3, \"k\"), (4, \"i\"), (5, \"t\")]\n        ```\n\n    Arguments:\n        *iterables: Iterables to zip.\n\n    Returns:\n        An [`Iter[Tuple[...]]`][iters.iters.Iter] over zipped tuples.\n    \"\"\"\n    return cls.create(zip(*iterables))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.create_zip_equal","title":"<code>create_zip_equal(*iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Any]]</code>  <code>classmethod</code>","text":"<p>Zips <code>iterables</code> into an iterator of tuples, where the i-th tuple contains the i-th item from each of the iterables.</p> <p>This is the strict version of <code>create_zip</code>.</p> Example <pre><code>x = (1, 2, 3)\n\ny = \"dev\"\n\niter.create_zip_equal(x, y).list() == [(1, \"d\"), (2, \"e\"), (3, \"v\")]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[Any]</code> <p>Iterables to zip.</p> <code>()</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Iterables have different lengths.</p> <p>Returns:</p> Type Description <code>Iter[DynamicTuple[Any]]</code> <p>An <code>Iter[Tuple[...]]</code> over zipped tuples.</p> Source code in <code>iters/iters.py</code> <pre><code>@no_type_check\n@classmethod\ndef create_zip_equal(cls, *iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Any]]:\n\"\"\"Zips `iterables` into an iterator of tuples, where\n    the *i*-th tuple contains the *i*-th item from each of the iterables.\n\n    This is the strict version of [`create_zip`][iters.iters.Iter.create_zip].\n\n    Example:\n        ```python\n        x = (1, 2, 3)\n\n        y = \"dev\"\n\n        iter.create_zip_equal(x, y).list() == [(1, \"d\"), (2, \"e\"), (3, \"v\")]\n        ```\n\n    Arguments:\n        *iterables: Iterables to zip.\n\n    Raises:\n        ValueError: Iterables have different lengths.\n\n    Returns:\n        An [`Iter[Tuple[...]]`][iters.iters.Iter] over zipped tuples.\n    \"\"\"\n    return cls.create(zip_equal(*iterables))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.create_zip_longest","title":"<code>create_zip_longest(*iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Option[Any]]]</code>  <code>classmethod</code>","text":"<p>Zips <code>iterables</code> into an iterator of tuples, where the i-th tuple contains the i-th item from each of the iterables.</p> <p>This is a version of <code>create_zip</code> that places <code>None</code> in place of a j-th item of an i-th tuple when a j-th iterable is exhausted.</p> Example <pre><code>x = (1, 2, 3, 4)\n\ny = \"dev\"\n\nf = \"x\"\n\ndef process(a: Option[int], b: Option[str]) -&gt; Tuple[int, str]:\n    return (a.unwrap_or(0), b.unwrap_or(f))\n\nassert (\n    iter.create_zip_longest(x, y)\n    .map(unpack_binary(process))\n    .list()\n) == [(1, \"d\"), (2, \"e\"), (3, \"v\"), (4, \"x\")]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[Any]</code> <p>Iterables to zip.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[DynamicTuple[Option[Any]]]</code> <p>An <code>Iter[Tuple[...]]</code> over zipped tuples.</p> Source code in <code>iters/iters.py</code> <pre><code>@no_type_check\n@classmethod\ndef create_zip_longest(cls, *iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Option[Any]]]:\n\"\"\"Zips `iterables` into an iterator of tuples, where\n    the *i*-th tuple contains the *i*-th item from each of the iterables.\n\n    This is a version of [`create_zip`][iters.iters.Iter.create_zip] that places [`None`][None]\n    in place of a *j*-th item of an *i*-th tuple when a *j*-th iterable is exhausted.\n\n    Example:\n        ```python\n        x = (1, 2, 3, 4)\n\n        y = \"dev\"\n\n        f = \"x\"\n\n        def process(a: Option[int], b: Option[str]) -&gt; Tuple[int, str]:\n            return (a.unwrap_or(0), b.unwrap_or(f))\n\n        assert (\n            iter.create_zip_longest(x, y)\n            .map(unpack_binary(process))\n            .list()\n        ) == [(1, \"d\"), (2, \"e\"), (3, \"v\"), (4, \"x\")]\n        ```\n\n    Arguments:\n        *iterables: Iterables to zip.\n\n    Returns:\n        An [`Iter[Tuple[...]]`][iters.iters.Iter] over zipped tuples.\n    \"\"\"\n    return cls.create(zip_longest(*iterables))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.create_cartesian_product","title":"<code>create_cartesian_product(*iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Any]]</code>  <code>classmethod</code>","text":"<p>Creates an iterator over the Cartesian product of <code>iterables</code>.</p> Warning <p>It only makes sense to compute the product of finite iterables.</p> Example <pre><code>a = (1, 2, 3)\nb = \"xyz\"\n\nc = [\n    (1, \"x\"), (1, \"y\"), (1, \"z\"),\n    (2, \"x\"), (2, \"y\"), (2, \"z\"),\n    (3, \"x\"), (3, \"y\"), (3, \"z\"),\n]\n\nassert iter.create_cartesian_product(a, b).list() == c\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[Any]</code> <p>Iterables to compute the Cartesian product of.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[DynamicTuple[Any]]</code> <p>An <code>Iter[Tuple[...]]</code> over the Cartesian product of iterables.</p> Source code in <code>iters/iters.py</code> <pre><code>@no_type_check\n@classmethod\ndef create_cartesian_product(cls, *iterables: Iterable[Any]) -&gt; Iter[DynamicTuple[Any]]:\n\"\"\"Creates an iterator over the\n    [*Cartesian product*](https://en.wikipedia.org/wiki/Cartesian_product) of `iterables`.\n\n    Warning:\n        It only makes sense to compute the product of finite iterables.\n\n    Example:\n        ```python\n        a = (1, 2, 3)\n        b = \"xyz\"\n\n        c = [\n            (1, \"x\"), (1, \"y\"), (1, \"z\"),\n            (2, \"x\"), (2, \"y\"), (2, \"z\"),\n            (3, \"x\"), (3, \"y\"), (3, \"z\"),\n        ]\n\n        assert iter.create_cartesian_product(a, b).list() == c\n        ```\n\n    Arguments:\n        *iterables: Iterables to compute the Cartesian product of.\n\n    Returns:\n        An [`Iter[Tuple[...]]`][iters.iters.Iter] over the Cartesian product of iterables.\n    \"\"\"\n    return cls.create(cartesian_product(*iterables))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.reversed","title":"<code>reversed(reversible: Reversible[T]) -&gt; Iter[T]</code>  <code>classmethod</code>","text":"<p>Creates an iterator over the reversed <code>reversible</code>.</p> Example <pre><code>assert iter.reversed([1, 2, 3]).list() == [3, 2, 1]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>reversible</code> <code>Reversible[T]</code> <p>The reversible to reverse.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>An <code>Iter[T]</code> over the reversed reversible.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef reversed(cls, reversible: Reversible[T]) -&gt; Iter[T]:\n\"\"\"Creates an iterator over the reversed `reversible`.\n\n    Example:\n        ```python\n        assert iter.reversed([1, 2, 3]).list() == [3, 2, 1]\n        ```\n\n    Arguments:\n        reversible: The reversible to reverse.\n\n    Returns:\n        An [`Iter[T]`][iters.iters.Iter] over the reversed reversible.\n    \"\"\"\n    return cls.create(standard_reversed(reversible))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.function","title":"<code>function(function: Nullary[T], sentinel: V) -&gt; Iter[T]</code>  <code>classmethod</code>","text":"<p>Creates an iterator over <code>function</code> call results until it returns the <code>sentinel</code>.</p> Example <pre><code>EMPTY_BYTES = bytes()\n\nREAD_BINARY = \"rb\"\n\nCHUNK_SIZE = 65536\n\ndef read_chunk(file: BinaryIO) -&gt; Nullary[bytes]:\n    def reader(size: int = CHUNK_SIZE) -&gt; bytes:\n        return file.read(size)\n\n    return reader\n\nwith path.open(READ_BINARY) as file:\n    iter.function(read_chunk(file), EMPTY_BYTES).for_each(process_chunk)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Nullary[T]</code> <p>The function to iterate.</p> required <code>sentinel</code> <code>V</code> <p>The sentinel to stop at.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>An <code>Iter[T]</code> over function calls until the <code>sentinel</code> is met.</p> Source code in <code>iters/iters.py</code> <pre><code>@classmethod\ndef function(cls, function: Nullary[T], sentinel: V) -&gt; Iter[T]:\n\"\"\"Creates an iterator over `function` call results until it returns the `sentinel`.\n\n    Example:\n        ```python\n        EMPTY_BYTES = bytes()\n\n        READ_BINARY = \"rb\"\n\n        CHUNK_SIZE = 65536\n\n        def read_chunk(file: BinaryIO) -&gt; Nullary[bytes]:\n            def reader(size: int = CHUNK_SIZE) -&gt; bytes:\n                return file.read(size)\n\n            return reader\n\n        with path.open(READ_BINARY) as file:\n            iter.function(read_chunk(file), EMPTY_BYTES).for_each(process_chunk)\n        ```\n\n    Arguments:\n        function: The function to iterate.\n        sentinel: The sentinel to stop at.\n\n    Returns:\n        An [`Iter[T]`][iters.iters.Iter] over function calls until the `sentinel` is met.\n    \"\"\"\n    return cls.create(iter_function(function, sentinel))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.unwrap","title":"<code>unwrap() -&gt; Iterator[T]</code>","text":"<p>Unwraps the underlying iterator.</p> <p>Returns:</p> Type Description <code>Iterator[T]</code> <p>The underlying iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def unwrap(self) -&gt; Iterator[T]:\n\"\"\"Unwraps the underlying iterator.\n\n    Returns:\n        The underlying iterator.\n    \"\"\"\n    return self.iterator\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.iter","title":"<code>iter() -&gt; Iter[T]</code>","text":"<p>Simply returns <code>self</code>.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p><code>self</code>, the current iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def iter(self) -&gt; Iter[T]:\n\"\"\"Simply returns `self`.\n\n    Returns:\n        `self`, the current iterator.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.next","title":"<code>next() -&gt; Option[T]</code>","text":"<p>Returns the next item in the iterator.</p> Example <pre><code>value = 42\n\niterator = iter.once(value)\n\nassert iterator.next().unwrap() is value\n</code></pre> <p>Returns:</p> Type Description <code>Option[T]</code> <p>The next item.</p> Source code in <code>iters/iters.py</code> <pre><code>def next(self) -&gt; Option[T]:\n\"\"\"Returns the next item in the iterator.\n\n    Example:\n        ```python\n        value = 42\n\n        iterator = iter.once(value)\n\n        assert iterator.next().unwrap() is value\n        ```\n\n    Returns:\n        The next item.\n    \"\"\"\n    return wrap_marked(next(self.iterator, marker))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.compare","title":"<code>compare(other: Iterable[ST]) -&gt; Ordering</code>","text":"<p>Compares <code>self</code> with the <code>other</code> iterable.</p> Example <pre><code>array = [1, 2, 3]\n\niterator = iter(array)\n\nassert iterator.compare(array).is_equal()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[ST]</code> <p>The other iterable.</p> required <p>Returns:</p> Type Description <code>Ordering</code> <p>The <code>Ordering</code> representing the result.</p> Source code in <code>iters/iters.py</code> <pre><code>def compare(self: Iter[ST], other: Iterable[ST]) -&gt; Ordering:\n\"\"\"Compares `self` with the `other` iterable.\n\n    Example:\n        ```python\n        array = [1, 2, 3]\n\n        iterator = iter(array)\n\n        assert iterator.compare(array).is_equal()\n        ```\n\n    Arguments:\n        other: The other iterable.\n\n    Returns:\n        The [`Ordering`][iters.types.Ordering] representing the result.\n    \"\"\"\n    return compare(self.iterator, other)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.compare_by","title":"<code>compare_by(other: Iterable[T], key: Unary[T, ST]) -&gt; Ordering</code>","text":"<p>Compares <code>self</code> with the <code>other</code> iterable using the <code>key</code> function.</p> Example <pre><code>array = [13, 34, 42]\nnegative = [-x for x in array]\n\niterator = iter(array)\n\nassert iterator.compare_by(negative, abs).is_equal()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[T]</code> <p>The other iterable.</p> required <code>key</code> <code>Unary[T, ST]</code> <p>The key function.</p> required <p>Returns:</p> Type Description <code>Ordering</code> <p>The <code>Ordering</code> representing the result.</p> Source code in <code>iters/iters.py</code> <pre><code>def compare_by(self, other: Iterable[T], key: Unary[T, ST]) -&gt; Ordering:\n\"\"\"Compares `self` with the `other` iterable using the `key` function.\n\n    Example:\n        ```python\n        array = [13, 34, 42]\n        negative = [-x for x in array]\n\n        iterator = iter(array)\n\n        assert iterator.compare_by(negative, abs).is_equal()\n        ```\n\n    Arguments:\n        other: The other iterable.\n        key: The key function.\n\n    Returns:\n        The [`Ordering`][iters.types.Ordering] representing the result.\n    \"\"\"\n    return compare(self.iterator, other, key)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.length","title":"<code>length() -&gt; int</code>","text":"<p>Computes the length of the iterator.</p> Example <pre><code>assert iter.repeat_exactly(7, 7).length() == 7\n</code></pre> Warning <p>This function exhausts the underlying iterator!</p> <p>Returns:</p> Type Description <code>int</code> <p>The length of the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def length(self) -&gt; int:\n\"\"\"Computes the length of the iterator.\n\n    Example:\n        ```python\n        assert iter.repeat_exactly(7, 7).length() == 7\n        ```\n\n    Warning:\n        This function exhausts the underlying iterator!\n\n    Returns:\n        The length of the iterator.\n    \"\"\"\n    return iter_length(self.iterator)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.first","title":"<code>first() -&gt; Option[T]</code>","text":"<p>Returns the first item in the iterator.</p> Example <pre><code>value = 69\n\niterator = iter.once(value)\n\nassert iterator.first().unwrap() is value\n</code></pre> <p>Returns:</p> Type Description <code>Option[T]</code> <p>The first item.</p> Source code in <code>iters/iters.py</code> <pre><code>def first(self) -&gt; Option[T]:\n\"\"\"Returns the first item in the iterator.\n\n    Example:\n        ```python\n        value = 69\n\n        iterator = iter.once(value)\n\n        assert iterator.first().unwrap() is value\n        ```\n\n    Returns:\n        The first item.\n    \"\"\"\n    return wrap_marked(first(self.iterator, marker))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.last","title":"<code>last() -&gt; Option[T]</code>","text":"<p>Returns the last item in the iterator.</p> Example <pre><code>value = 69\n\niterator = iter.once(value)\n\nassert iterator.last().unwrap() is value\n</code></pre> <p>Returns:</p> Type Description <code>Option[T]</code> <p>The last item.</p> Source code in <code>iters/iters.py</code> <pre><code>def last(self) -&gt; Option[T]:\n\"\"\"Returns the last item in the iterator.\n\n    Example:\n        ```python\n        value = 69\n\n        iterator = iter.once(value)\n\n        assert iterator.last().unwrap() is value\n        ```\n\n    Returns:\n        The last item.\n    \"\"\"\n    return wrap_marked(last(self.iterator))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.last_with_tail","title":"<code>last_with_tail() -&gt; Option[T]</code>","text":"<p>Returns the last item in the iterator.</p> Note <p>This method uses the <code>tail</code> function.</p> Example <pre><code>value = 69\n\niterator = iter.once(value)\n\nassert iterator.last_with_tail().unwrap() is value\n</code></pre> <p>Returns:</p> Type Description <code>Option[T]</code> <p>The last item.</p> Source code in <code>iters/iters.py</code> <pre><code>def last_with_tail(self) -&gt; Option[T]:\n\"\"\"Returns the last item in the iterator.\n\n    Note:\n        This method uses the [`tail`][iters.utils.tail] function.\n\n    Example:\n        ```python\n        value = 69\n\n        iterator = iter.once(value)\n\n        assert iterator.last_with_tail().unwrap() is value\n        ```\n\n    Returns:\n        The last item.\n    \"\"\"\n    return wrap_marked(last_with_tail(self.iterator, marker))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.collect","title":"<code>collect(function: Unary[Iterable[T], U]) -&gt; U</code>","text":"<p>Collects the iterator with the <code>function</code>.</p> <p>This is equivalent to:</p> <pre><code>function(iterator.unwrap())\n</code></pre> Example <pre><code>array = [1, 2, 3]\n\niterator = iter(array)\n\nassert iterator.collect(list) == array\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[Iterable[T], U]</code> <p>The function to use.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The result of the <code>function</code> call.</p> Source code in <code>iters/iters.py</code> <pre><code>def collect(self, function: Unary[Iterable[T], U]) -&gt; U:\n\"\"\"Collects the iterator with the `function`.\n\n    This is equivalent to:\n\n    ```python\n    function(iterator.unwrap())\n    ```\n\n    Example:\n        ```python\n        array = [1, 2, 3]\n\n        iterator = iter(array)\n\n        assert iterator.collect(list) == array\n        ```\n\n    Arguments:\n        function: The function to use.\n\n    Returns:\n        The result of the `function` call.\n    \"\"\"\n    return function(self.iterator)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.collect_iter","title":"<code>collect_iter(function: Unary[Iterable[T], Iterable[U]]) -&gt; Iter[U]</code>","text":"<p>Collects the iterator with the <code>function</code>.</p> <p>This is equivalent to:</p> <pre><code>iterator.create(iterator.collect(function))\n</code></pre> Example <pre><code>from typing import TypeVar\n\nT = TypeVar(\"T\")\n\ndef identity(item: T) -&gt; T:\n    return item\n\narray = [13, 25, 34]\n\niterator = iter(array).collect_iter(identity)\n\nassert iterator.list() == array\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Unary[Iterable[T], Iterable[U]]</code> <p>The function to use.</p> required <p>Returns:</p> Type Description <code>Iter[U]</code> <p>The result of the <code>function</code> call, wrapped back into an iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def collect_iter(self, function: Unary[Iterable[T], Iterable[U]]) -&gt; Iter[U]:\n\"\"\"Collects the iterator with the `function`.\n\n    This is equivalent to:\n\n    ```python\n    iterator.create(iterator.collect(function))\n    ```\n\n    Example:\n        ```python\n        from typing import TypeVar\n\n        T = TypeVar(\"T\")\n\n        def identity(item: T) -&gt; T:\n            return item\n\n        array = [13, 25, 34]\n\n        iterator = iter(array).collect_iter(identity)\n\n        assert iterator.list() == array\n        ```\n\n    Arguments:\n        function: The function to use.\n\n    Returns:\n        The result of the `function` call, wrapped back into an iterator.\n    \"\"\"\n    return self.create(self.collect(function))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.list","title":"<code>list() -&gt; List[T]</code>","text":"<p>Collects the iterator into the <code>List[T]</code>.</p> <p>This is equivalent to:</p> <pre><code>list(iterator.unwrap())\n</code></pre> Example <pre><code>array = [1, 2, 3]\n\niterator = iter(array)\n\nassert iterator.list() == array\n</code></pre> <p>Returns:</p> Type Description <code>List[T]</code> <p>The <code>List[T]</code> over the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def list(self) -&gt; List[T]:\n\"\"\"Collects the iterator into the [`List[T]`][list].\n\n    This is equivalent to:\n\n    ```python\n    list(iterator.unwrap())\n    ```\n\n    Example:\n        ```python\n        array = [1, 2, 3]\n\n        iterator = iter(array)\n\n        assert iterator.list() == array\n        ```\n\n    Returns:\n        The [`List[T]`][list] over the iterator.\n    \"\"\"\n    return list(self.iterator)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.set","title":"<code>set() -&gt; Set[Q]</code>","text":"<p>Collects the iterator into the <code>Set[Q]</code>.</p> Warning <p>The items of the iterator have to be hashable for this method to work.</p> <p>This is equivalent to:</p> <pre><code>set(iterator.unwrap())\n</code></pre> Example <pre><code>set = {13, 42, 69}\n\niterator = iter(set)\n\nassert iterator.set() == set\n</code></pre> <p>Returns:</p> Type Description <code>Set[Q]</code> <p>The <code>Set[Q]</code> over the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def set(self: Iter[Q]) -&gt; Set[Q]:\n\"\"\"Collects the iterator into the [`Set[Q]`][set].\n\n    Warning:\n        The items of the iterator have to be hashable for this method to work.\n\n    This is equivalent to:\n\n    ```python\n    set(iterator.unwrap())\n    ```\n\n    Example:\n        ```python\n        set = {13, 42, 69}\n\n        iterator = iter(set)\n\n        assert iterator.set() == set\n        ```\n\n    Returns:\n        The [`Set[Q]`][set] over the iterator.\n    \"\"\"\n    return set(self.iterator)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.ordered_set","title":"<code>ordered_set() -&gt; OrderedSet[Q]</code>","text":"<p>Collects the iterator into the <code>OrderedSet[Q]</code>.</p> Warning <p>The items of the iterator have to be hashable for this method to work.</p> <p>This is equivalent to:</p> <pre><code>ordered_set(iterator.unwrap())\n</code></pre> Example <pre><code>ordered_set = OrderedSet([13, 42, 69])\n\niterator = iter(ordered_set)\n\nassert iterator.ordered_set() == ordered_set\n</code></pre> <p>Returns:</p> Type Description <code>OrderedSet[Q]</code> <p>The <code>OrderedSet[Q]</code> over the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def ordered_set(self: Iter[Q]) -&gt; OrderedSet[Q]:\n\"\"\"Collects the iterator into the [`OrderedSet[Q]`][iters.ordered_set.OrderedSet].\n\n    Warning:\n        The items of the iterator have to be hashable for this method to work.\n\n    This is equivalent to:\n\n    ```python\n    ordered_set(iterator.unwrap())\n    ```\n\n    Example:\n        ```python\n        ordered_set = OrderedSet([13, 42, 69])\n\n        iterator = iter(ordered_set)\n\n        assert iterator.ordered_set() == ordered_set\n        ```\n\n    Returns:\n        The [`OrderedSet[Q]`][iters.ordered_set.OrderedSet] over the iterator.\n    \"\"\"\n    return ordered_set(self.iterator)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.tuple","title":"<code>tuple() -&gt; DynamicTuple[T]</code>","text":"<p>Collects the iterator into the <code>Tuple[T, ...]</code>.</p> <p>This is equivalent to:</p> <pre><code>tuple(iterator.unwrap())\n</code></pre> Example <pre><code>tuple = (-1, 0, 1)\n\niterator = iter(tuple)\n\nassert iterator.tuple() == tuple\n</code></pre> <p>Returns:</p> Type Description <code>DynamicTuple[T]</code> <p>The <code>Tuple[T, ...]</code> over the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def tuple(self) -&gt; DynamicTuple[T]:\n\"\"\"Collects the iterator into the [`Tuple[T, ...]`][tuple].\n\n    This is equivalent to:\n\n    ```python\n    tuple(iterator.unwrap())\n    ```\n\n    Example:\n        ```python\n        tuple = (-1, 0, 1)\n\n        iterator = iter(tuple)\n\n        assert iterator.tuple() == tuple\n        ```\n\n    Returns:\n        The [`Tuple[T, ...]`][tuple] over the iterator.\n    \"\"\"\n    return tuple(self.iterator)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.dict","title":"<code>dict() -&gt; Dict[Q, V]</code>","text":"<p>Collects the iterator into the <code>Dict[Q, V]</code>.</p> Warning <p>The first item in each couple has to be hashable for this method to work.</p> <p>This is equivalent to:</p> <pre><code>dict(iterator.unwrap())\n</code></pre> Example <pre><code>mapping = {13: \"nekit\", 42: \"dev\"}\n\niterator = iter(mapping.items())\n\nassert iterator.dict() == mapping\n</code></pre> <p>Returns:</p> Type Description <code>Dict[Q, V]</code> <p>The <code>Dict[Q, V]</code> over the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def dict(self: Iter[Tuple[Q, V]]) -&gt; Dict[Q, V]:\n\"\"\"Collects the iterator into the [`Dict[Q, V]`][dict].\n\n    Warning:\n        The first item in each couple has to be hashable for this method to work.\n\n    This is equivalent to:\n\n    ```python\n    dict(iterator.unwrap())\n    ```\n\n    Example:\n        ```python\n        mapping = {13: \"nekit\", 42: \"dev\"}\n\n        iterator = iter(mapping.items())\n\n        assert iterator.dict() == mapping\n        ```\n\n    Returns:\n        The [`Dict[Q, V]`][dict] over the iterator.\n    \"\"\"\n    return dict(self.iterator)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.join","title":"<code>join(string: AnyStr) -&gt; AnyStr</code>","text":"<p>Joins the iterator using the <code>string</code>.</p> Warning <p>The iterator must contain only string items for this method to work.</p> <p>This is equivalent to:</p> <pre><code>string.join(iterator.unwrap())\n</code></pre> Example <pre><code>result = \"melody, nekit\"\n\nstring = \", \"\n\niterator = iter(result.split(string))\n\nassert iterator.join(string) == result\n</code></pre> <p>Returns:</p> Type Description <code>AnyStr</code> <p>The joined <code>str</code> or <code>bytes</code> depending on the <code>string</code> type.</p> Source code in <code>iters/iters.py</code> <pre><code>def join(self: Iter[AnyStr], string: AnyStr) -&gt; AnyStr:\n\"\"\"Joins the iterator using the `string`.\n\n    Warning:\n        The iterator must contain only string items for this method to work.\n\n    This is equivalent to:\n\n    ```python\n    string.join(iterator.unwrap())\n    ```\n\n    Example:\n        ```python\n        result = \"melody, nekit\"\n\n        string = \", \"\n\n        iterator = iter(result.split(string))\n\n        assert iterator.join(string) == result\n        ```\n\n    Returns:\n        The joined [`str`][str] or [`bytes`][bytes] depending on the `string` type.\n    \"\"\"\n    return string.join(self.iterator)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.string","title":"<code>string() -&gt; str</code>","text":"<p>Joins the iterator into the <code>str</code> string.</p> Warning <p>The iterator must contain only items of type <code>str</code> for this method to work.</p> <p>This is equivalent to:</p> <pre><code>iterator.join(EMPTY_STRING)\n</code></pre> Example <pre><code>strings = (\"x\", \"y\", \"z\")\nstring = \"xyz\"\n\niterator = iter(strings)\n\nassert iterator.string() == string\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>The joined <code>str</code> string.</p> Source code in <code>iters/iters.py</code> <pre><code>def string(self: Iter[str]) -&gt; str:\n\"\"\"Joins the iterator into the [`str`][str] string.\n\n    Warning:\n        The iterator must contain only items of type [`str`][str] for this method to work.\n\n    This is equivalent to:\n\n    ```python\n    iterator.join(EMPTY_STRING)\n    ```\n\n    Example:\n        ```python\n        strings = (\"x\", \"y\", \"z\")\n        string = \"xyz\"\n\n        iterator = iter(strings)\n\n        assert iterator.string() == string\n        ```\n\n    Returns:\n        The joined [`str`][str] string.\n    \"\"\"\n    return self.join(EMPTY_STRING)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.bytes","title":"<code>bytes() -&gt; bytes</code>","text":"<p>Joins the iterator into the <code>bytes</code> string.</p> Warning <p>The iterator must contain only items of type <code>bytes</code> for this method to work.</p> <p>This is equivalent to:</p> <pre><code>iterator.join(EMPTY_BYTES)\n</code></pre> <p>Returns:</p> Type Description <code>bytes</code> <p>The joined <code>bytes</code> string.</p> Source code in <code>iters/iters.py</code> <pre><code>def bytes(self: Iter[bytes]) -&gt; bytes:\n\"\"\"Joins the iterator into the [`bytes`][bytes] string.\n\n    Warning:\n        The iterator must contain only items of type [`bytes`][bytes] for this method to work.\n\n    This is equivalent to:\n\n    ```python\n    iterator.join(EMPTY_BYTES)\n    ```\n\n    Returns:\n        The joined [`bytes`][bytes] string.\n    \"\"\"\n    return self.join(EMPTY_BYTES)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.count_dict","title":"<code>count_dict() -&gt; Counter[Q]</code>","text":"<p>Collects the iterator into the <code>Counter[Q]</code>.</p> Warning <p>The items of the iterator have to be hashable for this method to work.</p> Example <pre><code>bits = (0, 1, 1, 0, 1, 1, 1, 0)\n\nresult = [(1, 5), (0, 3)]\n\niterator = iter(bits)\n\nassert iterator.count_dict().most_common() == result\n</code></pre> <p>Returns:</p> Type Description <code>Counter[Q]</code> <p>The <code>Counter[Q]</code> over the items of the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def count_dict(self: Iter[Q]) -&gt; Counter[Q]:\n\"\"\"Collects the iterator into the [`Counter[Q]`][collections.Counter].\n\n    Warning:\n        The items of the iterator have to be hashable for this method to work.\n\n    Example:\n        ```python\n        bits = (0, 1, 1, 0, 1, 1, 1, 0)\n\n        result = [(1, 5), (0, 3)]\n\n        iterator = iter(bits)\n\n        assert iterator.count_dict().most_common() == result\n        ```\n\n    Returns:\n        The [`Counter[Q]`][collections.Counter] over the items of the iterator.\n    \"\"\"\n    return count_dict(self.iterator)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.count_dict_by","title":"<code>count_dict_by(key: Unary[T, Q]) -&gt; Counter[Q]</code>","text":"<p>Collects the iterator into the <code>Counter[Q]</code> by applying the <code>key</code> function.</p> Example <pre><code>sets = [{}, {0}, {1}, {0, 1}]\n\niterator = iter(sets)\n\nresult = [(1, 2), (2, 1), (0, 1)]\n\nassert iterator.count_dict_by(len).most_common() == result\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Unary[T, Q]</code> <p>The key function.</p> required <p>Returns:</p> Type Description <code>Counter[Q]</code> <p>The <code>Counter[Q]</code> over the keys corresponding to the items of the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def count_dict_by(self, key: Unary[T, Q]) -&gt; Counter[Q]:\n\"\"\"Collects the iterator into the [`Counter[Q]`][collections.Counter]\n    by applying the `key` function.\n\n    Example:\n        ```python\n        sets = [{}, {0}, {1}, {0, 1}]\n\n        iterator = iter(sets)\n\n        result = [(1, 2), (2, 1), (0, 1)]\n\n        assert iterator.count_dict_by(len).most_common() == result\n        ```\n\n    Arguments:\n        key: The key function.\n\n    Returns:\n        The [`Counter[Q]`][collections.Counter] over the keys\n            corresponding to the items of the iterator.\n    \"\"\"\n    return count_dict(self.iterator, key)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.cartesian_power","title":"<code>cartesian_power(power: int) -&gt; Iter[DynamicTuple[T]]</code>","text":"<p>Creates an iterator over the Cartesian power of the iterator.</p> Warning <p>It only makes sense to compute the Cartesian power of finite iterators.</p> Example <pre><code>bits = (0, 1)\nresult = ((0, 0), (0, 1), (1, 0), (1, 1))\n\niterator = iter(bits)\n\nassert iterator.cartesian_power(2).tuple() == result\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>power</code> <code>int</code> <p>The power to \"raise\" the iterator to.</p> required <p>Returns:</p> Type Description <code>Iter[DynamicTuple[T]]</code> <p>An [<code>Iter[Tuple[...]]</code>] over the Cartesian power of the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def cartesian_power(self, power: int) -&gt; Iter[DynamicTuple[T]]:\n\"\"\"Creates an iterator over the\n    [*Cartesian power*](https://en.wikipedia.org/wiki/Cartesian_product) of the iterator.\n\n    Warning:\n        It only makes sense to compute the Cartesian power of finite iterators.\n\n    Example:\n        ```python\n        bits = (0, 1)\n        result = ((0, 0), (0, 1), (1, 0), (1, 1))\n\n        iterator = iter(bits)\n\n        assert iterator.cartesian_power(2).tuple() == result\n        ```\n\n    Arguments:\n        power: The power to \"raise\" the iterator to.\n\n    Returns:\n        An [`Iter[Tuple[...]]`] over the Cartesian power of the iterator.\n    \"\"\"\n    return self.create(cartesian_power(power, self.iterator))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.power_set","title":"<code>power_set() -&gt; Iter[DynamicTuple[T]]</code>","text":"<p>Computes the power set of the iterator.</p> <p>The power set of \\(S\\) contains all subsets of \\(S\\), including the empty set \\(\\varnothing\\) and \\(S\\) itself. The power set is often denoted as \\(2^S\\) since if \\(|S| = n\\), then \\(|2^S| = 2^n\\).</p> <p>Returns:</p> Type Description <code>Iter[DynamicTuple[T]]</code> <p>An iterator over the power set of the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def power_set(self) -&gt; Iter[DynamicTuple[T]]:\n\"\"\"Computes the power set of the iterator.\n\n    The power set of $S$ contains all subsets of $S$, including\n    the empty set $\\\\varnothing$ and $S$ itself.\n    The power set is often denoted as $2^S$ since if $|S| = n$, then $|2^S| = 2^n$.\n\n    Returns:\n        An iterator over the power set of the iterator.\n    \"\"\"\n    return self.create(power_set(self.iterator))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.unique","title":"<code>unique() -&gt; Iter[T]</code>","text":"<p>Creates an iterator over the unique items in the iterator.</p> <p>This function may be slower than <code>unique_fast</code> in case <code>T</code> is not <code>Hashable</code>.</p> <p>To be precise, this function is \\(O(n)\\) for hashable items, and \\(O(n^2)\\) otherwise.</p> Example <pre><code>&gt;&gt;&gt; iterator = iter.of(0, 1, 1, 0, 1, 1, 1, 0)\n&gt;&gt;&gt; iterator.unique().tuple()\n(0, 1)\n</code></pre> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>An iterator over the unique items in the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def unique(self) -&gt; Iter[T]:\n\"\"\"Creates an iterator over the unique items in the iterator.\n\n    This function may be slower than [`unique_fast`][iters.iters.Iter.unique_fast]\n    in case `T` is not [`Hashable`][typing.Hashable].\n\n    To be precise, this function is $O(n)$ for hashable items, and $O(n^2)$ otherwise.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; iterator = iter.of(0, 1, 1, 0, 1, 1, 1, 0)\n        &gt;&gt;&gt; iterator.unique().tuple()\n        (0, 1)\n        ```\n\n    Returns:\n        An iterator over the unique items in the iterator.\n    \"\"\"\n    return self.create(unique(self.iterator))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.unique_by","title":"<code>unique_by(key: Unary[T, V]) -&gt; Iter[T]</code>","text":"<p>Creates an iterator over the unique items in the iterator based on the given <code>key</code>.</p> <p>This function may be slower than <code>unique_fast_by</code> in case <code>V</code> is not <code>Hashable</code>.</p> <p>To be precise, this function is \\(O(n)\\) for hashable items, and \\(O(n^2)\\) otherwise.</p> Example <pre><code>&gt;&gt;&gt; iterator = iter.of(0, 1, -1)\n&gt;&gt;&gt; iterator.unique_by(abs).tuple()\n(0, 1)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Unary[T, V]</code> <p>The key to use in determining uniqueness.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>An iterator over the unique items in the iterator based on the given <code>key</code>.</p> Source code in <code>iters/iters.py</code> <pre><code>def unique_by(self, key: Unary[T, V]) -&gt; Iter[T]:\n\"\"\"Creates an iterator over the unique items in the iterator based on the given `key`.\n\n    This function may be slower than [`unique_fast_by`][iters.iters.Iter.unique_fast_by]\n    in case `V` is not [`Hashable`][typing.Hashable].\n\n    To be precise, this function is $O(n)$ for hashable items, and $O(n^2)$ otherwise.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; iterator = iter.of(0, 1, -1)\n        &gt;&gt;&gt; iterator.unique_by(abs).tuple()\n        (0, 1)\n        ```\n\n    Arguments:\n        key: The key to use in determining uniqueness.\n\n    Returns:\n        An iterator over the unique items in the iterator based on the given `key`.\n    \"\"\"\n    return self.create(unique(self.iterator, key))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.partition","title":"<code>partition(predicate: Optional[Predicate[T]]) -&gt; Pair[Iter[T]]</code>","text":"<p>Partitions the iterator into two iterators safely based on the given <code>predicate</code>, loading all items into memory!</p> <p>See predicates for more information on the <code>predicate</code> argument.</p> Example <p>Suppose we have the following function:</p> <pre><code>def is_positive(z: int) -&gt; bool:\n    return z &gt; 0\n</code></pre> <p>Then</p> <pre><code>&gt;&gt;&gt; iterator = iter.of(-1, 0, 1)\n&gt;&gt;&gt; positive, non_positive = iterator.partition(is_positive)\n&gt;&gt;&gt; positive.list()\n[1]\n&gt;&gt;&gt; non_positive.list()\n[-1, 0]\n</code></pre> Note <p>This method exhausts the underlying iterator.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Optional[Predicate[T]]</code> <p>The predicate to use in partitioning the iterator.</p> required <p>Returns:</p> Type Description <code>Pair[Iter[T]]</code> <p>A tuple of two iterators, the former containing the items that match the predicate,</p> <code>Pair[Iter[T]]</code> <p>and the latter containing items that do not match the predicate.</p> Source code in <code>iters/iters.py</code> <pre><code>def partition(self, predicate: Optional[Predicate[T]]) -&gt; Pair[Iter[T]]:\n\"\"\"Partitions the iterator into two iterators *safely* based on the given `predicate`,\n    loading **all** items into memory!\n\n    See [predicates](/predicates) for more information on the `predicate` argument.\n\n    Example:\n        Suppose we have the following function:\n\n        ```python\n        def is_positive(z: int) -&gt; bool:\n            return z &gt; 0\n        ```\n\n        Then\n\n        ```python\n        &gt;&gt;&gt; iterator = iter.of(-1, 0, 1)\n        &gt;&gt;&gt; positive, non_positive = iterator.partition(is_positive)\n        &gt;&gt;&gt; positive.list()\n        [1]\n        &gt;&gt;&gt; non_positive.list()\n        [-1, 0]\n        ```\n\n    Note:\n        This method exhausts the underlying iterator.\n\n    Arguments:\n        predicate: The predicate to use in partitioning the iterator.\n\n    Returns:\n        A tuple of two iterators, the former containing the items that match the predicate,\n        and the latter containing items that do *not* match the predicate.\n    \"\"\"\n    true, false = partition(predicate, self.iterator)\n\n    return (self.create(true), self.create(false))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.partition_unsafe","title":"<code>partition_unsafe(predicate: Optional[Predicate[T]]) -&gt; Pair[Iter[T]]</code>","text":"<p>Partitions the iterator into two iterators unsafely based on the given <code>predicate</code>.</p> <p>See predicates for more information on the <code>predicate</code> argument.</p> Example <p>Suppose we have the following function:</p> <pre><code>def is_negative(z: int) -&gt; bool:\n    return z &lt; 0\n</code></pre> <p>Then</p> <pre><code>&gt;&gt;&gt; iterator = iter.of(-1, 0, 1)\n&gt;&gt;&gt; negative, non_negative = iterator.partition_unsafe(is_negative)\n&gt;&gt;&gt; non_negative.list()\n[0, 1]\n&gt;&gt;&gt; negative.list()\n[-1]\n</code></pre> Warning <p>This method is not thread-safe!</p> Note <p>This method works on the underlying iterator, so using the original iterator is not recommended after calling this method.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Optional[Predicate[T]]</code> <p>The predicate to use in partitioning the iterator.</p> required <p>Returns:</p> Type Description <code>Pair[Iter[T]]</code> <p>A tuple of two iterators, the former containing the items that match the predicate,</p> <code>Pair[Iter[T]]</code> <p>and the latter containing items that do not match the predicate.</p> Source code in <code>iters/iters.py</code> <pre><code>def partition_unsafe(self, predicate: Optional[Predicate[T]]) -&gt; Pair[Iter[T]]:\n\"\"\"Partitions the iterator into two iterators *unsafely* based on the given `predicate`.\n\n    See [predicates](/predicates) for more information on the `predicate` argument.\n\n    Example:\n        Suppose we have the following function:\n\n        ```python\n        def is_negative(z: int) -&gt; bool:\n            return z &lt; 0\n        ```\n\n        Then\n\n        ```python\n        &gt;&gt;&gt; iterator = iter.of(-1, 0, 1)\n        &gt;&gt;&gt; negative, non_negative = iterator.partition_unsafe(is_negative)\n        &gt;&gt;&gt; non_negative.list()\n        [0, 1]\n        &gt;&gt;&gt; negative.list()\n        [-1]\n        ```\n\n    Warning:\n        This method is not thread-safe!\n\n    Note:\n        This method works on the underlying iterator, so using the original iterator\n        is not recommended after calling this method.\n\n    Arguments:\n        predicate: The predicate to use in partitioning the iterator.\n\n    Returns:\n        A tuple of two iterators, the former containing the items that match the predicate,\n        and the latter containing items that do *not* match the predicate.\n    \"\"\"\n    true, false = partition_unsafe(predicate, self.iterator)\n\n    return (self.create(true), self.create(false))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.copy","title":"<code>copy() -&gt; Iter[T]</code>","text":"<p>Copies the iterator safely, loading all items into memory!</p> Example <pre><code>&gt;&gt;&gt; iterator = iter.of(1, 2, 3)\n&gt;&gt;&gt; copy = iterator.copy()\n&gt;&gt;&gt; iterator.tuple()\n(1, 2, 3)\n&gt;&gt;&gt; copy.tuple()\n(1, 2, 3)\n</code></pre> Note <p>This method replaces the underlying iterator.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>A copy of the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def copy(self) -&gt; Iter[T]:\n\"\"\"Copies the iterator *safely*, loading **all** items into memory!\n\n    Example:\n        ```python\n        &gt;&gt;&gt; iterator = iter.of(1, 2, 3)\n        &gt;&gt;&gt; copy = iterator.copy()\n        &gt;&gt;&gt; iterator.tuple()\n        (1, 2, 3)\n        &gt;&gt;&gt; copy.tuple()\n        (1, 2, 3)\n        ```\n\n    Note:\n        This method replaces the underlying iterator.\n\n    Returns:\n        A copy of the iterator.\n    \"\"\"\n    iterator, copied = copy(self.iterator)\n\n    self._replace(iterator)\n\n    return self.create(copied)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.copy_unsafe","title":"<code>copy_unsafe() -&gt; Iter[T]</code>","text":"<p>Copies the iterator unsafely.</p> Example <pre><code>&gt;&gt;&gt; iterator = iter.of(13, 42, 69)\n&gt;&gt;&gt; copy = iterator.copy_unsafe()\n&gt;&gt;&gt; iterator.zip(copy).tuple()\n((13, 13), (42, 42), (69, 69))\n</code></pre> Warning <p>This method is not thread-safe!</p> Note <p>This method replaces the underlying iterator.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>A copy of the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def copy_unsafe(self) -&gt; Iter[T]:\n\"\"\"Copies the iterator *unsafely*.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; iterator = iter.of(13, 42, 69)\n        &gt;&gt;&gt; copy = iterator.copy_unsafe()\n        &gt;&gt;&gt; iterator.zip(copy).tuple()\n        ((13, 13), (42, 42), (69, 69))\n        ```\n\n    Warning:\n        This method is not thread-safe!\n\n    Note:\n        This method replaces the underlying iterator.\n\n    Returns:\n        A copy of the iterator.\n    \"\"\"\n    iterator, copied = copy_unsafe(self.iterator)\n\n    self._replace(iterator)\n\n    return self.create(copied)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.spy","title":"<code>spy(size: int) -&gt; List[T]</code>","text":"<p>Spies on at most <code>size</code> next items of the iterator, without consuming them.</p> Example <pre><code>&gt;&gt;&gt; iterator = iter.of(13, 34, 42)\n&gt;&gt;&gt; iterator.spy(2)\n[13, 34]\n&gt;&gt;&gt; iterator.spy(4)\n[13, 34, 42]\n&gt;&gt;&gt; iterator.next()\nSome(13)\n</code></pre> Note <p>This method replaces the underlying iterator.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The amount of items to spy on.</p> required <p>Returns:</p> Type Description <code>List[T]</code> <p>Up to <code>size</code> next items of the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def spy(self, size: int) -&gt; List[T]:\n\"\"\"Spies on at most `size` next items of the iterator, without consuming them.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; iterator = iter.of(13, 34, 42)\n        &gt;&gt;&gt; iterator.spy(2)\n        [13, 34]\n        &gt;&gt;&gt; iterator.spy(4)\n        [13, 34, 42]\n        &gt;&gt;&gt; iterator.next()\n        Some(13)\n        ```\n\n    Note:\n        This method replaces the underlying iterator.\n\n    Arguments:\n        size: The amount of items to spy on.\n\n    Returns:\n        Up to `size` next items of the iterator.\n    \"\"\"\n    result, iterator = spy(size, self.iterator)\n\n    self._replace(iterator)\n\n    return result\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.peek","title":"<code>peek() -&gt; Option[T]</code>","text":"<p>Peeks at the next item in the iterator, without consuming it.</p> Example <pre><code>&gt;&gt;&gt; iterator = iter.of(13, 34, 42)\n&gt;&gt;&gt; iterator.peek()\nSome(13)\n&gt;&gt;&gt; iterator.next()\nSome(13)\n</code></pre> Note <p>This method replaces the underlying iterator.</p> <p>Returns:</p> Type Description <code>Option[T]</code> <p>The next item in the iterator, if one exists.</p> Source code in <code>iters/iters.py</code> <pre><code>def peek(self) -&gt; Option[T]:\n\"\"\"Peeks at the next item in the iterator, without consuming it.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; iterator = iter.of(13, 34, 42)\n        &gt;&gt;&gt; iterator.peek()\n        Some(13)\n        &gt;&gt;&gt; iterator.next()\n        Some(13)\n        ```\n\n    Note:\n        This method replaces the underlying iterator.\n\n    Returns:\n        The next item in the iterator, if one exists.\n    \"\"\"\n    item, iterator = peek(self.iterator, marker)\n\n    self._replace(iterator)\n\n    return wrap_marked(item)\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.has_next","title":"<code>has_next() -&gt; bool</code>","text":"<p>Checks if the iterator has a next item (i.e. is non-empty).</p> Example <pre><code>&gt;&gt;&gt; assert iter.once(1).has_next()\n&gt;&gt;&gt; assert not iter.empty().has_next()\n</code></pre> Note <p>This method replaces the underlying iterator.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the iterator has a next item.</p> Source code in <code>iters/iters.py</code> <pre><code>def has_next(self) -&gt; bool:\n\"\"\"Checks if the iterator has a next item (i.e. is non-empty).\n\n    Example:\n        ```python\n        &gt;&gt;&gt; assert iter.once(1).has_next()\n        &gt;&gt;&gt; assert not iter.empty().has_next()\n        ```\n\n    Note:\n        This method replaces the underlying iterator.\n\n    Returns:\n        Whether the iterator has a next item.\n    \"\"\"\n    result, iterator = has_next(self.iterator)\n\n    self._replace(iterator)\n\n    return result\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.is_empty","title":"<code>is_empty() -&gt; bool</code>","text":"<p>Checks if the iterator is empty.</p> Example <pre><code>&gt;&gt;&gt; assert iter.empty().is_empty()\n&gt;&gt;&gt; assert not iter.once(0).is_empty()\n</code></pre> Note <p>This method replaces the underlying iterator.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the iterator is empty.</p> Source code in <code>iters/iters.py</code> <pre><code>def is_empty(self) -&gt; bool:\n\"\"\"Checks if the iterator is empty.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; assert iter.empty().is_empty()\n        &gt;&gt;&gt; assert not iter.once(0).is_empty()\n        ```\n\n    Note:\n        This method replaces the underlying iterator.\n\n    Returns:\n        Whether the iterator is empty.\n    \"\"\"\n    result, iterator = is_empty(self.iterator)\n\n    self._replace(iterator)\n\n    return result\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.repeat_last","title":"<code>repeat_last() -&gt; Iter[T]</code>","text":"<p>Repeats the last item of the iterator indefinitely.</p> Example <pre><code>&gt;&gt;&gt; iterator = iter.of(0, 1)\n&gt;&gt;&gt; iterator.next()\nSome(0)\n&gt;&gt;&gt; iterator.next()\nSome(1)\n&gt;&gt;&gt; iterator.next()\nSome(1)  # now repeating the last item\n</code></pre> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>The iterator with the last item repeated indefinitely.</p> Source code in <code>iters/iters.py</code> <pre><code>def repeat_last(self) -&gt; Iter[T]:\n\"\"\"Repeats the last item of the iterator indefinitely.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; iterator = iter.of(0, 1)\n        &gt;&gt;&gt; iterator.next()\n        Some(0)\n        &gt;&gt;&gt; iterator.next()\n        Some(1)\n        &gt;&gt;&gt; iterator.next()\n        Some(1)  # now repeating the last item\n        ```\n\n    Returns:\n        The iterator with the last item repeated indefinitely.\n    \"\"\"\n    return self.create(repeat_last(self.iterator))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.repeat_each","title":"<code>repeat_each(count: int) -&gt; Iter[T]</code>","text":"<p>Repeat each item of the iterator <code>count</code> times.</p> Example <pre><code>&gt;&gt;&gt; iter.of(0, 1).repeat_each(2).tuple()\n(0, 0, 1, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; iter.once(0).repeat_each(0).tuple()\n()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The amount of times to repeat each item.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>The iterator with each item repeated <code>count</code> times.</p> Source code in <code>iters/iters.py</code> <pre><code>def repeat_each(self, count: int) -&gt; Iter[T]:\n\"\"\"Repeat each item of the iterator `count` times.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; iter.of(0, 1).repeat_each(2).tuple()\n        (0, 0, 1, 1)\n        ```\n\n        ```python\n        &gt;&gt;&gt; iter.once(0).repeat_each(0).tuple()\n        ()\n        ```\n\n    Arguments:\n        count: The amount of times to repeat each item.\n\n    Returns:\n        The iterator with each item repeated `count` times.\n    \"\"\"\n    return self.create(repeat_each(count, self.iterator))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.inspect","title":"<code>inspect(function: Inspect[T]) -&gt; Iter[T]</code>","text":"<p>Inspects each item of the iterator with the given <code>function</code>.</p> Example <pre><code>&gt;&gt;&gt; iter.of(1, 2, 3).inspect(print).consume()\n1\n2\n3\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Inspect[T]</code> <p>The inspecting function.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>The original iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def inspect(self, function: Inspect[T]) -&gt; Iter[T]:\n\"\"\"Inspects each item of the iterator with the given `function`.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; iter.of(1, 2, 3).inspect(print).consume()\n        1\n        2\n        3\n        ```\n\n    Arguments:\n        function: The inspecting function.\n\n    Returns:\n        The original iterator.\n    \"\"\"\n    return self.create(inspect(function, self.iterator))\n</code></pre>"},{"location":"reference/iters/#iters.iters.Iter.into_async_iter","title":"<code>into_async_iter() -&gt; AsyncIter[T]</code>","text":"<p>Converts an <code>Iter[T]</code> into an <code>AsyncIter[T]</code>.</p> Example <pre><code>&gt;&gt;&gt; async_iterator = iter.of(13, 34, 42).into_async_iter()\n&gt;&gt;&gt; await async_iterator.tuple()\n(13, 34, 42)\n</code></pre> <p>Returns:</p> Type Description <code>AsyncIter[T]</code> <p>The async iterator created from the iterator.</p> Source code in <code>iters/iters.py</code> <pre><code>def into_async_iter(self) -&gt; AsyncIter[T]:\n\"\"\"Converts an [`Iter[T]`][iters.iters.Iter] into\n    an [`AsyncIter[T]`][iters.async_iters.AsyncIter].\n\n    Example:\n        ```python\n        &gt;&gt;&gt; async_iterator = iter.of(13, 34, 42).into_async_iter()\n        &gt;&gt;&gt; await async_iterator.tuple()\n        (13, 34, 42)\n        ```\n\n    Returns:\n        The async iterator created from the iterator.\n    \"\"\"\n    return async_iter(self.iterator)\n</code></pre>"},{"location":"reference/iters/#iters.iters.wrap_iter","title":"<code>wrap_iter(function: Callable[PS, Iterable[T]]) -&gt; Callable[PS, Iter[T]]</code>","text":"<p>Wraps the <code>function</code> returning <code>Iterable[T]</code> to return <code>Iter[T]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[PS, Iterable[T]]</code> <p>The function to wrap.</p> required <p>Returns:</p> Type Description <code>Callable[PS, Iter[T]]</code> <p>The wrapping function.</p> Source code in <code>iters/iters.py</code> <pre><code>def wrap_iter(function: Callable[PS, Iterable[T]]) -&gt; Callable[PS, Iter[T]]:\n\"\"\"Wraps the `function` returning [`Iterable[T]`][typing.Iterable]\n    to return [`Iter[T]`][iters.iters.Iter].\n\n    Arguments:\n        function: The function to wrap.\n\n    Returns:\n        The wrapping function.\n    \"\"\"\n\n    @wraps(function)\n    def wrap(*args: PS.args, **kwargs: PS.kwargs) -&gt; Iter[T]:\n        return iter(function(*args, **kwargs))\n\n    return wrap\n</code></pre>"},{"location":"reference/mappings/","title":"Mappings","text":""},{"location":"reference/mappings/#iters.mappings.merge","title":"<code>merge(*mappings: Mapping[Any, Any], **keywords: Any) -&gt; Dict[Any, Any]</code>","text":"<p>Merges multiple <code>mappings</code> and <code>keywords</code> into one dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>*mappings</code> <code>Mapping[Any, Any]</code> <p>Mappings to merge.</p> <code>()</code> <code>**keywords</code> <code>Any</code> <p>Keywords to add to the merged dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[Any, Any]</code> <p>The merged dictionary.</p> Source code in <code>iters/mappings.py</code> <pre><code>def merge(*mappings: Mapping[Any, Any], **keywords: Any) -&gt; Dict[Any, Any]:\n\"\"\"Merges multiple `mappings` and `keywords` into one dictionary.\n\n    Arguments:\n        *mappings: Mappings to merge.\n        **keywords: Keywords to add to the merged dictionary.\n\n    Returns:\n        The merged dictionary.\n    \"\"\"\n    merged: Dict[Any, Any] = {}\n\n    for mapping in mappings:\n        merged.update(mapping)\n\n    merged.update(keywords)\n\n    return merged\n</code></pre>"},{"location":"reference/ordered_set/","title":"Ordered Set","text":""},{"location":"reference/ordered_set/#iters.ordered_set.LAST","title":"<code>LAST = ~0</code>  <code>module-attribute</code>","text":"<p>The last index.</p>"},{"location":"reference/ordered_set/#iters.ordered_set.ordered_set","title":"<code>ordered_set = OrderedSet</code>  <code>module-attribute</code>","text":"<p>An alias of <code>OrderedSet</code>.</p>"},{"location":"reference/ordered_set/#iters.ordered_set.ordered_set_unchecked","title":"<code>ordered_set_unchecked = ordered_set.create_unchecked</code>  <code>module-attribute</code>","text":"<p>An alias of <code>ordered_set.create_unchecked</code>.</p>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet","title":"<code>OrderedSet</code>","text":"<p>         Bases: <code>MutableSet[Q]</code>, <code>Sequence[Q]</code></p> <p>Represents ordered sets, i.e. mutable hash sets that preserve insertion order.</p> <p>The implementation is rather simple: it uses an array to store the items and a hash map to store the indices of the items in the array along with ensuring uniqueness.</p> <p>The complexity of the operations assumes that hash maps have \\(O(1)\\) insertion, lookup, deletion, and clearing as well as that arrays have \\(O(1)\\) by-index lookup, length-checking and clearing.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>class OrderedSet(MutableSet[Q], Sequence[Q]):\n\"\"\"Represents ordered sets, i.e. mutable hash sets that preserve insertion order.\n\n    The implementation is rather simple: it uses an *array* to store the items\n    and a *hash map* to store the indices of the items in the array along with ensuring uniqueness.\n\n    The complexity of the operations assumes that *hash maps*\n    have $O(1)$ *insertion*, *lookup*, *deletion*, and *clearing* as well\n    as that *arrays* have $O(1)$ *by-index lookup*, *length-checking* and *clearing*.\n    \"\"\"\n\n    def __init__(self, iterable: Iterable[Q] = ()) -&gt; None:\n        self._items: List[Q] = []\n        self._item_to_index: Dict[Q, int] = {}\n\n        self.update(iterable)\n\n    @classmethod\n    def create(cls, iterable: Iterable[R] = ()) -&gt; OrderedSet[R]:\n\"\"\"Creates an ordered set from an iterable.\n\n        Complexity:\n            $O(n)$, where $n$ is the length of the iterable.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; array = [0, 1, 1, 0, 1, 1, 1, 0]\n            &gt;&gt;&gt; order_set = ordered_set.create(array)\n            &gt;&gt;&gt; order_set\n            OrderedSet([0, 1])\n            ```\n\n        Arguments:\n            iterable: The iterable to create the ordered set from.\n\n        Returns:\n            The created ordered set.\n        \"\"\"\n        return cls(iterable)  # type: ignore\n\n    @classmethod\n    def create_unchecked(cls, iterable: Iterable[R] = ()) -&gt; OrderedSet[R]:\n\"\"\"Creates an ordered set from an iterable without checking if the items are unique.\n\n        This method is useful when constructing an ordered set from an iterable that is known to\n        contain unique items only.\n\n        Complexity:\n            $O(n)$, where $n$ is the length of the iterable.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; array = [1, 2, 3]  # we know that the items are unique\n            &gt;&gt;&gt; order_set = ordered_set.create_unchecked(array)\n            &gt;&gt;&gt; order_set\n            OrderedSet([1, 2, 3])\n            ```\n\n        Arguments:\n            iterable: The iterable to create the ordered set from.\n\n        Returns:\n            The created ordered set.\n        \"\"\"\n        self: OrderedSet[R] = cls.create()\n\n        items = self._items\n        item_to_index = self._item_to_index\n\n        items.extend(iterable)\n\n        for index, item in enumerate(items):\n            item_to_index[item] = index\n\n        return self\n\n    @classmethod\n    def create_union(cls, *iterables: Iterable[R]) -&gt; OrderedSet[R]:\n\"\"\"Creates an ordered set that is the union of given iterables.\n\n        Arguments:\n            *iterables: The iterables to create the ordered set union from.\n\n        Returns:\n            The ordered set union.\n        \"\"\"\n        return cls.create(chain(*iterables))\n\n    @classmethod\n    def create_intersection(cls, *iterables: Iterable[R]) -&gt; OrderedSet[R]:\n\"\"\"Creates an ordered set that is the intersection of given iterables.\n\n        The order is determined by the first iterable.\n\n        Arguments:\n            *iterables: The iterables to create the ordered set intersection from.\n\n        Returns:\n            The ordered set intersection.\n        \"\"\"\n        if iterables:\n            head, *tail = iterables\n\n            return cls.create(head).apply_intersection(*tail)\n\n        return cls.create()\n\n    @classmethod\n    def create_difference(cls, *iterables: Iterable[R]) -&gt; OrderedSet[R]:\n\"\"\"Creates an ordered set that is the difference of given iterables.\n\n        The order is determined by the first iterable.\n\n        Arguments:\n            *iterables: The iterables to create the orderd set difference from.\n\n        Returns:\n            The ordered set difference.\n        \"\"\"\n        if iterables:\n            head, *tail = iterables\n\n            return cls.create(head).apply_difference(*tail)\n\n        return cls.create()\n\n    @classmethod\n    def create_symmetric_difference(cls, *iterables: Iterable[R]) -&gt; OrderedSet[R]:\n\"\"\"Creates an ordered set that is the symmetric difference of given iterables.\n\n        The order is determined by the first iterable.\n\n        Arguments:\n            *iterables: The iterables to create the ordered set symmetric difference from.\n\n        Returns:\n            The ordered set symmetric difference.\n        \"\"\"\n        if iterables:\n            head, *tail = iterables\n\n            return cls.create(head).apply_symmetric_difference(*tail)\n\n        return cls.create()\n\n    def __len__(self) -&gt; int:\n        return len(self._items)\n\n    @overload\n    def __getitem__(self, index: int) -&gt; Q:\n        ...\n\n    @overload\n    def __getitem__(self, index: slice) -&gt; OrderedSet[Q]:\n        ...\n\n    def __getitem__(self, index: Union[int, slice]) -&gt; Union[Q, OrderedSet[Q]]:\n        if is_slice(index):\n            if index == SLICE_ALL:\n                return self.copy()\n\n            return self.create_unchecked(self._items[index])\n\n        return self._items[index]  # type: ignore\n\n    def copy(self) -&gt; OrderedSet[Q]:\n\"\"\"Copies the ordered set.\n\n        This is equivalent to:\n\n        ```python\n        order_set.create_unchecked(order_set)\n        ```\n\n        Complexity:\n            $O(n)$, where $n$ is the length of the ordered set.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; order_set = ordered_set([1, 2, 3])\n            &gt;&gt;&gt; order_set\n            OrderedSet([1, 2, 3])\n            &gt;&gt;&gt; order_set.copy()\n            OrderedSet([1, 2, 3])\n            ```\n\n        Returns:\n            The copied ordered set.\n        \"\"\"\n        return self.create_unchecked(self)\n\n    def __contains__(self, item: Any) -&gt; bool:\n        return item in self._item_to_index\n\n    def add(self, item: Q) -&gt; None:\n\"\"\"Adds an item to the ordered set.\n\n        Complexity:\n            $O(1)$.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; order_set = ordered_set()\n            &gt;&gt;&gt; order_set\n            OrderedSet()\n            &gt;&gt;&gt; order_set.add(0)\n            &gt;&gt;&gt; order_set.add(1)\n            &gt;&gt;&gt; order_set.add(0)\n            &gt;&gt;&gt; order_set\n            OrderedSet([0, 1])\n            ```\n\n        Arguments:\n            item: The item to add.\n        \"\"\"\n        item_to_index = self._item_to_index\n\n        if item not in item_to_index:\n            items = self._items\n\n            item_to_index[item] = len(items)\n\n            items.append(item)\n\n    append = add\n\"\"\"An alias of [`add`][iters.ordered_set.OrderedSet.add].\"\"\"\n\n    def update(self, iterable: Iterable[Q]) -&gt; None:\n\"\"\"Updates the ordered set with the items from an iterable.\n\n        This is equivalent to:\n\n        ```python\n        for item in iterable:\n            ordered_set.add(item)\n        ```\n\n        Complexity:\n            $O(n)$, where $n$ is the length of the iterable.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; order_set = ordered_set()\n            &gt;&gt;&gt; order_set.update([0, 1])\n            &gt;&gt;&gt; order_set.update([1, 2, 3])\n            &gt;&gt;&gt; order_set\n            OrderedSet([0, 1, 2, 3])\n            ```\n\n        Arguments:\n            iterable: The iterable to update the ordered set with.\n        \"\"\"\n        for item in iterable:\n            self.add(item)\n\n    extend = update\n\"\"\"An alias of [`update`][iters.ordered_set.OrderedSet.update].\"\"\"\n\n    def index(self, item: Q, start: Optional[int] = None, stop: Optional[int] = None) -&gt; int:\n\"\"\"Gets the index of an item in the ordered set.\n\n        Complexity:\n            $O(1)$.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; order_set = ordered_set([1, 2, 3])\n            &gt;&gt;&gt; order_set.index(1)\n            0\n            &gt;&gt;&gt; order_set.index(5)\n            Traceback (most recent call last):\n              ...\n            ValueError: 5 is not in the ordered set\n            ```\n\n        Arguments:\n            item: The item to get the index of.\n            start: The index to start searching from.\n            stop: The index to stop searching at.\n\n        Raises:\n            ValueError: The item is not in the ordered set.\n\n        Returns:\n            The index of the item.\n        \"\"\"\n        index = self._item_to_index.get(item)\n        error = item_not_in_ordered_set(item)\n\n        if index is None:\n            raise error\n\n        if start is not None:\n            if index &lt; start:\n                raise error\n\n        if stop is not None:\n            if index &gt;= stop:\n                raise error\n\n        return index\n\n    get_index = wrap_option(index)\n\"\"\"An alias of [`index`][iters.ordered_set.OrderedSet.index] wrapped to return\n    [`Option[int]`][wraps.option.Option] instead of erroring.\n    \"\"\"\n\n    def count(self, item: Q) -&gt; int:\n\"\"\"Returns `1` if an item is in the ordered set, `0` otherwise.\n\n        Complexity:\n            $O(1)$.\n\n        Arguments:\n            item: The item to count.\n\n        Returns:\n            `1` if the `item` is in the ordered set, `0` otherwise.\n        \"\"\"\n        return int(item in self._item_to_index)\n\n    def pop(self, index: int = LAST) -&gt; Q:\n\"\"\"Pops an item from the ordered set at `index`.\n\n        Complexity:\n            $O(n)$, see [`discard`][iters.ordered_set.OrderedSet.discard].\n\n        Example:\n            ```python\n            &gt;&gt;&gt; order_set = ordered_set([0, 1])\n            &gt;&gt;&gt; order_set.pop()\n            1\n            &gt;&gt;&gt; order_set.pop(0)\n            0\n            &gt;&gt;&gt; order_set.pop()\n            Traceback (most recent call last):\n              ...\n            IndexError: list index out of range\n            ```\n\n        Arguments:\n            index: The index to pop the item from.\n\n        Raises:\n            IndexError: The index is out of range.\n\n        Returns:\n            The popped item.\n        \"\"\"\n        items = self._items\n\n        item = items[index]\n\n        self.discard(item)\n\n        return item\n\n    get_pop = wrap_option(pop)\n\"\"\"An alias of [`pop`][iters.ordered_set.OrderedSet.pop] wrapped to return\n    [`Option[Q]`][wraps.option.Option] instead of erroring.\n    \"\"\"\n\n    def discard(self, item: Q) -&gt; None:\n\"\"\"Discards an item from the ordered set.\n\n        Complexity:\n            $O(n)$, where $n$ is the length of the ordered set.\n            This is because all indices after the removed index must be decremented.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; order_set = ordered_set([0, 1])\n            &gt;&gt;&gt; order_set.discard(1)\n            &gt;&gt;&gt; order_set\n            OrderedSet([0])\n            &gt;&gt;&gt; order_set.discard(1)\n            &gt;&gt;&gt; order_set.discard(0)\n            &gt;&gt;&gt; order_set\n            OrderedSet()\n            ```\n\n        Arguments:\n            item: The item to discard.\n        \"\"\"\n        item_to_index = self._item_to_index\n\n        if item in item_to_index:\n            index = item_to_index[item]\n\n            del self._items[index]\n\n            for item_in, index_in in item_to_index.items():\n                if index_in &gt;= index:\n                    item_to_index[item_in] -= 1\n\n    def remove(self, item: Q) -&gt; None:\n\"\"\"A checked version of [`discard`][iters.ordered_set.OrderedSet.discard].\n\n        Complexity: $O(n)$, see [`discard`][iters.ordered_set.OrderedSet.discard].\n\n        Example:\n            ```python\n            &gt;&gt;&gt; order_set = ordered_set([0, 1])\n            &gt;&gt;&gt; order_set.remove(1)\n            &gt;&gt;&gt; order_set\n            OrderedSet([0])\n            &gt;&gt;&gt; order_set.remove(1)\n            Traceback (most recent call last):\n              ...\n            ValueError: 1 is not in the ordered set\n            &gt;&gt;&gt; order_set.remove(0)\n            &gt;&gt;&gt; order_set\n            OrderedSet()\n            ```\n\n        Arguments:\n            item: The item to remove.\n\n        Raises:\n            ValueError: The item is not in the ordered set.\n        \"\"\"\n        if item in self:\n            self.discard(item)\n\n        else:\n            raise ValueError(ITEM_NOT_IN_ORDERED_SET.format(item))\n\n    def insert(self, index: int, item: Q) -&gt; None:\n\"\"\"Inserts an item into the ordered set at `index`.\n\n        Complexity:\n            $O(n)$, where $n$ is the length of the ordered set.\n            This is because all indices after the inserted index must be incremented.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; order_set = ordered_set([1, 3])\n            &gt;&gt;&gt; order_set.insert(1, 2)\n            &gt;&gt;&gt; order_set\n            OrderedSet([1, 2, 3])\n            ```\n\n        Arguments:\n            index: The index to insert the item at.\n            item: The item to insert.\n        \"\"\"\n        item_to_index = self._item_to_index\n\n        if item in item_to_index:\n            return\n\n        items = self._items\n\n        if index &lt; len(items):\n            items.insert(index, item)\n\n            for item_in, index_in in item_to_index.items():\n                if index_in &gt;= index:\n                    item_to_index[item_in] += 1\n\n            item_to_index[item] = index\n\n        else:\n            self.append(item)\n\n    def clear(self) -&gt; None:\n\"\"\"Clears the ordered set.\n\n        Complexity:\n            $O(1)$.\n        \"\"\"\n        self._items.clear()\n        self._item_to_index.clear()\n\n    def __iter__(self) -&gt; Iterator[Q]:\n        return iter(self._items)\n\n    def __reversed__(self) -&gt; Iterator[Q]:\n        return reversed(self._items)\n\n    def __repr__(self) -&gt; str:\n        name = get_type_name(self)\n\n        items = self._items\n\n        if not items:\n            return EMPTY_REPRESENTATION.format(name)\n\n        return ITEMS_REPRESENTATION.format(name, items)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if is_instance(other, Iterable):\n            if is_instance(other, Sequence):\n                return self._items == list(other)\n\n            return set(self._item_to_index) == set(other)\n\n        return False\n\n    def apply_union(self, *iterables: Iterable[Q]) -&gt; OrderedSet[Q]:\n\"\"\"Returns the union of the ordered set and `iterables`.\n\n        Arguments:\n            *iterables: The iterables to find the union with.\n\n        Returns:\n            The union of the ordered set and `iterables`.\n        \"\"\"\n        if iterables:\n            return self.create_union(self, *iterables)\n\n        return self.copy()\n\n    union = mixed_method(create_union, apply_union)\n\"\"\"Mixes [`create_union`][iters.ordered_set.OrderedSet.create_union]\n    and [`apply_union`][iters.ordered_set.OrderedSet.apply_union].\n    \"\"\"\n\n    def apply_intersection(self, *iterables: Iterable[Q]) -&gt; OrderedSet[Q]:\n\"\"\"Returns the intersection of the ordered set and `iterables`.\n\n        Arguments:\n            *iterables: The iterables to find the intersection with.\n\n        Returns:\n            The intersection of the ordered set and `iterables`.\n        \"\"\"\n        if iterables:\n            intersection = set.intersection(*map(set, iterables))  # type: ignore\n\n            iterator = (item for item in self if item in intersection)\n\n            return self.create_unchecked(iterator)\n\n        return self.copy()\n\n    intersection = mixed_method(create_intersection, apply_intersection)\n\"\"\"Mixes [`create_intersection`][iters.ordered_set.OrderedSet.create_intersection]\n    and [`apply_intersection`][iters.ordered_set.OrderedSet.apply_intersection].\n    \"\"\"\n\n    def intersection_update(self, *iterables: Iterable[Q]) -&gt; None:\n\"\"\"Updates the ordered set to be the intersection of itself and `iterables`.\n\n        Arguments:\n            *iterables: The iterables to find the intersection with.\n        \"\"\"\n        if iterables:\n            intersection = self.intersection(*iterables)\n\n            self.clear()\n\n            self.update(intersection)\n\n    def apply_difference(self, *iterables: Iterable[Q]) -&gt; OrderedSet[Q]:\n\"\"\"Returns the difference of the ordered set and `iterables`.\n\n        Arguments:\n            *iterables: The iterables to find the difference with.\n\n        Returns:\n            The difference of the ordered set and `iterables`.\n        \"\"\"\n        if iterables:\n            union = set.union(*map(set, iterables))  # type: ignore\n            iterator = (item for item in self if item not in union)\n\n            return self.create_unchecked(iterator)\n\n        return self.copy()\n\n    difference = mixed_method(create_difference, apply_difference)\n\"\"\"Mixes [`create_difference`][iters.ordered_set.OrderedSet.create_difference]\n    and [`apply_difference`][iters.ordered_set.OrderedSet.apply_difference].\n    \"\"\"\n\n    def difference_update(self, *iterables: Iterable[Q]) -&gt; None:\n\"\"\"Updates the ordered set to be the difference of itself and `iterables`.\n\n        Arguments:\n            *iterables: The iterables to find the difference with.\n        \"\"\"\n        if iterables:\n            difference = self.difference(*iterables)\n\n            self.clear()\n\n            self.update(difference)\n\n    def single_symmetric_difference(self, other: Iterable[Q]) -&gt; OrderedSet[Q]:\n        ordered = self.create(other)\n\n        return self.difference(ordered).union(ordered.difference(self))\n\n    def apply_symmetric_difference(self, *iterables: Iterable[Q]) -&gt; OrderedSet[Q]:\n\"\"\"Returns the symmetric difference of the ordered set and `iterables`.\n\n        Arguments:\n            *iterables: The iterables to find the symmetric difference with.\n\n        Returns:\n            The symmetric difference of the ordered set and `iterables`.\n        \"\"\"\n        if iterables:\n            result = self\n\n            for iterable in iterables:\n                result = result.single_symmetric_difference(iterable)\n\n            return result\n\n        return self.copy()\n\n    symmetric_difference = mixed_method(create_symmetric_difference, apply_symmetric_difference)\n\"\"\"Mixes\n    [`create_symmetric_difference`][iters.ordered_set.OrderedSet.create_symmetric_difference] and\n    [`apply_symmetric_difference`][iters.ordered_set.OrderedSet.apply_symmetric_difference].\n    \"\"\"\n\n    def symmetric_difference_update(self, *iterables: Iterable[Q]) -&gt; None:\n\"\"\"Updates the ordered set to be the symmetric difference of itself and `iterables`.\n\n        Arguments:\n            *iterables: The iterables to find the symmetric difference with.\n        \"\"\"\n        if iterables:\n            symmetric_difference = self.symmetric_difference(*iterables)\n\n            self.clear()\n\n            self.update(symmetric_difference)\n\n    def is_subset(self, other: Iterable[Q]) -&gt; bool:\n\"\"\"Checks if the ordered set is a subset of `other`.\n\n        Arguments:\n            other: The iterable to check if the ordered set is a subset of.\n\n        Returns:\n            Whether the ordered set is a subset of `other`.\n        \"\"\"\n        if is_instance(other, Sized):  # cover obvious cases\n            if len(self) &gt; len(other):\n                return False\n\n        if is_instance(other, AnySet):  # speedup for sets\n            return all(item in other for item in self)\n\n        other_set = set(other)\n\n        return len(self) &lt;= len(other_set) and all(item in other_set for item in self)\n\n    def is_strict_subset(self, other: Iterable[Q]) -&gt; bool:\n\"\"\"Checks if the ordered set is a strict subset of `other`.\n\n        Arguments:\n            other: The iterable to check if the ordered set is a strict subset of.\n\n        Returns:\n            Whether the ordered set is a strict subset of `other`.\n        \"\"\"\n        if is_instance(other, Sized):  # cover obvious cases\n            if len(self) &gt;= len(other):\n                return False\n\n        if is_instance(other, AnySet):  # speedup for sets\n            return all(item in other for item in self)\n\n        other_set = set(other)  # default case\n\n        return len(self) &lt; len(other_set) and all(item in other_set for item in self)\n\n    def is_superset(self, other: Iterable[Q]) -&gt; bool:\n\"\"\"Checks if the ordered set is a superset of `other`.\n\n        Arguments:\n            other: The iterable to check if the ordered set is a superset of.\n\n        Returns:\n            Whether the ordered set is a superset of `other`.\n        \"\"\"\n        if is_instance(other, Sized):  # speedup for sized iterables\n            return len(self) &gt;= len(other) and all(item in self for item in other)\n\n        return all(item in self for item in other)  # default case\n\n    def is_strict_superset(self, other: Iterable[Q]) -&gt; bool:\n\"\"\"Checks if the ordered set is a strict superset of `other`.\n\n        Arguments:\n            other: The iterable to check if the ordered set is a strict superset of.\n\n        Returns:\n            Whether the ordered set is a strict superset of `other`.\n        \"\"\"\n        if is_instance(other, Sized):  # speedup for sized iterables\n            return len(self) &gt; len(other) and all(item in self for item in other)\n\n        array = list(other)  # default case\n\n        return len(self) &gt; len(array) and all(item in self for item in array)\n\n    def is_disjoint(self, other: Iterable[Q]) -&gt; bool:\n\"\"\"Checks if the ordered set is disjoint with `other`.\n\n        Arguments:\n            other: The iterable to check if the ordered set is disjoint with.\n\n        Returns:\n            Whether the ordered set is disjoint with `other`.\n        \"\"\"\n        return none(item in self for item in other)\n\n    # I honestly hate these names ~ nekit\n\n    issubset = is_subset\n    issuperset = is_superset\n    isdisjoint = is_disjoint\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.append","title":"<code>append = add</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An alias of <code>add</code>.</p>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.extend","title":"<code>extend = update</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An alias of <code>update</code>.</p>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.get_index","title":"<code>get_index = wrap_option(index)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An alias of <code>index</code> wrapped to return <code>Option[int]</code> instead of erroring.</p>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.get_pop","title":"<code>get_pop = wrap_option(pop)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An alias of <code>pop</code> wrapped to return <code>Option[Q]</code> instead of erroring.</p>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.union","title":"<code>union = mixed_method(create_union, apply_union)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mixes <code>create_union</code> and <code>apply_union</code>.</p>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.intersection","title":"<code>intersection = mixed_method(create_intersection, apply_intersection)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mixes <code>create_intersection</code> and <code>apply_intersection</code>.</p>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.difference","title":"<code>difference = mixed_method(create_difference, apply_difference)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mixes <code>create_difference</code> and <code>apply_difference</code>.</p>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.symmetric_difference","title":"<code>symmetric_difference = mixed_method(create_symmetric_difference, apply_symmetric_difference)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mixes <code>create_symmetric_difference</code> and <code>apply_symmetric_difference</code>.</p>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.create","title":"<code>create(iterable: Iterable[R] = ()) -&gt; OrderedSet[R]</code>  <code>classmethod</code>","text":"<p>Creates an ordered set from an iterable.</p> Complexity <p>\\(O(n)\\), where \\(n\\) is the length of the iterable.</p> Example <pre><code>&gt;&gt;&gt; array = [0, 1, 1, 0, 1, 1, 1, 0]\n&gt;&gt;&gt; order_set = ordered_set.create(array)\n&gt;&gt;&gt; order_set\nOrderedSet([0, 1])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[R]</code> <p>The iterable to create the ordered set from.</p> <code>()</code> <p>Returns:</p> Type Description <code>OrderedSet[R]</code> <p>The created ordered set.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>@classmethod\ndef create(cls, iterable: Iterable[R] = ()) -&gt; OrderedSet[R]:\n\"\"\"Creates an ordered set from an iterable.\n\n    Complexity:\n        $O(n)$, where $n$ is the length of the iterable.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; array = [0, 1, 1, 0, 1, 1, 1, 0]\n        &gt;&gt;&gt; order_set = ordered_set.create(array)\n        &gt;&gt;&gt; order_set\n        OrderedSet([0, 1])\n        ```\n\n    Arguments:\n        iterable: The iterable to create the ordered set from.\n\n    Returns:\n        The created ordered set.\n    \"\"\"\n    return cls(iterable)  # type: ignore\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.create_unchecked","title":"<code>create_unchecked(iterable: Iterable[R] = ()) -&gt; OrderedSet[R]</code>  <code>classmethod</code>","text":"<p>Creates an ordered set from an iterable without checking if the items are unique.</p> <p>This method is useful when constructing an ordered set from an iterable that is known to contain unique items only.</p> Complexity <p>\\(O(n)\\), where \\(n\\) is the length of the iterable.</p> Example <pre><code>&gt;&gt;&gt; array = [1, 2, 3]  # we know that the items are unique\n&gt;&gt;&gt; order_set = ordered_set.create_unchecked(array)\n&gt;&gt;&gt; order_set\nOrderedSet([1, 2, 3])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[R]</code> <p>The iterable to create the ordered set from.</p> <code>()</code> <p>Returns:</p> Type Description <code>OrderedSet[R]</code> <p>The created ordered set.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>@classmethod\ndef create_unchecked(cls, iterable: Iterable[R] = ()) -&gt; OrderedSet[R]:\n\"\"\"Creates an ordered set from an iterable without checking if the items are unique.\n\n    This method is useful when constructing an ordered set from an iterable that is known to\n    contain unique items only.\n\n    Complexity:\n        $O(n)$, where $n$ is the length of the iterable.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; array = [1, 2, 3]  # we know that the items are unique\n        &gt;&gt;&gt; order_set = ordered_set.create_unchecked(array)\n        &gt;&gt;&gt; order_set\n        OrderedSet([1, 2, 3])\n        ```\n\n    Arguments:\n        iterable: The iterable to create the ordered set from.\n\n    Returns:\n        The created ordered set.\n    \"\"\"\n    self: OrderedSet[R] = cls.create()\n\n    items = self._items\n    item_to_index = self._item_to_index\n\n    items.extend(iterable)\n\n    for index, item in enumerate(items):\n        item_to_index[item] = index\n\n    return self\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.create_union","title":"<code>create_union(*iterables: Iterable[R]) -&gt; OrderedSet[R]</code>  <code>classmethod</code>","text":"<p>Creates an ordered set that is the union of given iterables.</p> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[R]</code> <p>The iterables to create the ordered set union from.</p> <code>()</code> <p>Returns:</p> Type Description <code>OrderedSet[R]</code> <p>The ordered set union.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>@classmethod\ndef create_union(cls, *iterables: Iterable[R]) -&gt; OrderedSet[R]:\n\"\"\"Creates an ordered set that is the union of given iterables.\n\n    Arguments:\n        *iterables: The iterables to create the ordered set union from.\n\n    Returns:\n        The ordered set union.\n    \"\"\"\n    return cls.create(chain(*iterables))\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.create_intersection","title":"<code>create_intersection(*iterables: Iterable[R]) -&gt; OrderedSet[R]</code>  <code>classmethod</code>","text":"<p>Creates an ordered set that is the intersection of given iterables.</p> <p>The order is determined by the first iterable.</p> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[R]</code> <p>The iterables to create the ordered set intersection from.</p> <code>()</code> <p>Returns:</p> Type Description <code>OrderedSet[R]</code> <p>The ordered set intersection.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>@classmethod\ndef create_intersection(cls, *iterables: Iterable[R]) -&gt; OrderedSet[R]:\n\"\"\"Creates an ordered set that is the intersection of given iterables.\n\n    The order is determined by the first iterable.\n\n    Arguments:\n        *iterables: The iterables to create the ordered set intersection from.\n\n    Returns:\n        The ordered set intersection.\n    \"\"\"\n    if iterables:\n        head, *tail = iterables\n\n        return cls.create(head).apply_intersection(*tail)\n\n    return cls.create()\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.create_difference","title":"<code>create_difference(*iterables: Iterable[R]) -&gt; OrderedSet[R]</code>  <code>classmethod</code>","text":"<p>Creates an ordered set that is the difference of given iterables.</p> <p>The order is determined by the first iterable.</p> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[R]</code> <p>The iterables to create the orderd set difference from.</p> <code>()</code> <p>Returns:</p> Type Description <code>OrderedSet[R]</code> <p>The ordered set difference.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>@classmethod\ndef create_difference(cls, *iterables: Iterable[R]) -&gt; OrderedSet[R]:\n\"\"\"Creates an ordered set that is the difference of given iterables.\n\n    The order is determined by the first iterable.\n\n    Arguments:\n        *iterables: The iterables to create the orderd set difference from.\n\n    Returns:\n        The ordered set difference.\n    \"\"\"\n    if iterables:\n        head, *tail = iterables\n\n        return cls.create(head).apply_difference(*tail)\n\n    return cls.create()\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.create_symmetric_difference","title":"<code>create_symmetric_difference(*iterables: Iterable[R]) -&gt; OrderedSet[R]</code>  <code>classmethod</code>","text":"<p>Creates an ordered set that is the symmetric difference of given iterables.</p> <p>The order is determined by the first iterable.</p> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[R]</code> <p>The iterables to create the ordered set symmetric difference from.</p> <code>()</code> <p>Returns:</p> Type Description <code>OrderedSet[R]</code> <p>The ordered set symmetric difference.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>@classmethod\ndef create_symmetric_difference(cls, *iterables: Iterable[R]) -&gt; OrderedSet[R]:\n\"\"\"Creates an ordered set that is the symmetric difference of given iterables.\n\n    The order is determined by the first iterable.\n\n    Arguments:\n        *iterables: The iterables to create the ordered set symmetric difference from.\n\n    Returns:\n        The ordered set symmetric difference.\n    \"\"\"\n    if iterables:\n        head, *tail = iterables\n\n        return cls.create(head).apply_symmetric_difference(*tail)\n\n    return cls.create()\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.copy","title":"<code>copy() -&gt; OrderedSet[Q]</code>","text":"<p>Copies the ordered set.</p> <p>This is equivalent to:</p> <pre><code>order_set.create_unchecked(order_set)\n</code></pre> Complexity <p>\\(O(n)\\), where \\(n\\) is the length of the ordered set.</p> Example <pre><code>&gt;&gt;&gt; order_set = ordered_set([1, 2, 3])\n&gt;&gt;&gt; order_set\nOrderedSet([1, 2, 3])\n&gt;&gt;&gt; order_set.copy()\nOrderedSet([1, 2, 3])\n</code></pre> <p>Returns:</p> Type Description <code>OrderedSet[Q]</code> <p>The copied ordered set.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def copy(self) -&gt; OrderedSet[Q]:\n\"\"\"Copies the ordered set.\n\n    This is equivalent to:\n\n    ```python\n    order_set.create_unchecked(order_set)\n    ```\n\n    Complexity:\n        $O(n)$, where $n$ is the length of the ordered set.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; order_set = ordered_set([1, 2, 3])\n        &gt;&gt;&gt; order_set\n        OrderedSet([1, 2, 3])\n        &gt;&gt;&gt; order_set.copy()\n        OrderedSet([1, 2, 3])\n        ```\n\n    Returns:\n        The copied ordered set.\n    \"\"\"\n    return self.create_unchecked(self)\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.add","title":"<code>add(item: Q) -&gt; None</code>","text":"<p>Adds an item to the ordered set.</p> Complexity <p>\\(O(1)\\).</p> Example <pre><code>&gt;&gt;&gt; order_set = ordered_set()\n&gt;&gt;&gt; order_set\nOrderedSet()\n&gt;&gt;&gt; order_set.add(0)\n&gt;&gt;&gt; order_set.add(1)\n&gt;&gt;&gt; order_set.add(0)\n&gt;&gt;&gt; order_set\nOrderedSet([0, 1])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Q</code> <p>The item to add.</p> required Source code in <code>iters/ordered_set.py</code> <pre><code>def add(self, item: Q) -&gt; None:\n\"\"\"Adds an item to the ordered set.\n\n    Complexity:\n        $O(1)$.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; order_set = ordered_set()\n        &gt;&gt;&gt; order_set\n        OrderedSet()\n        &gt;&gt;&gt; order_set.add(0)\n        &gt;&gt;&gt; order_set.add(1)\n        &gt;&gt;&gt; order_set.add(0)\n        &gt;&gt;&gt; order_set\n        OrderedSet([0, 1])\n        ```\n\n    Arguments:\n        item: The item to add.\n    \"\"\"\n    item_to_index = self._item_to_index\n\n    if item not in item_to_index:\n        items = self._items\n\n        item_to_index[item] = len(items)\n\n        items.append(item)\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.update","title":"<code>update(iterable: Iterable[Q]) -&gt; None</code>","text":"<p>Updates the ordered set with the items from an iterable.</p> <p>This is equivalent to:</p> <pre><code>for item in iterable:\n    ordered_set.add(item)\n</code></pre> Complexity <p>\\(O(n)\\), where \\(n\\) is the length of the iterable.</p> Example <pre><code>&gt;&gt;&gt; order_set = ordered_set()\n&gt;&gt;&gt; order_set.update([0, 1])\n&gt;&gt;&gt; order_set.update([1, 2, 3])\n&gt;&gt;&gt; order_set\nOrderedSet([0, 1, 2, 3])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[Q]</code> <p>The iterable to update the ordered set with.</p> required Source code in <code>iters/ordered_set.py</code> <pre><code>def update(self, iterable: Iterable[Q]) -&gt; None:\n\"\"\"Updates the ordered set with the items from an iterable.\n\n    This is equivalent to:\n\n    ```python\n    for item in iterable:\n        ordered_set.add(item)\n    ```\n\n    Complexity:\n        $O(n)$, where $n$ is the length of the iterable.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; order_set = ordered_set()\n        &gt;&gt;&gt; order_set.update([0, 1])\n        &gt;&gt;&gt; order_set.update([1, 2, 3])\n        &gt;&gt;&gt; order_set\n        OrderedSet([0, 1, 2, 3])\n        ```\n\n    Arguments:\n        iterable: The iterable to update the ordered set with.\n    \"\"\"\n    for item in iterable:\n        self.add(item)\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.index","title":"<code>index(item: Q, start: Optional[int] = None, stop: Optional[int] = None) -&gt; int</code>","text":"<p>Gets the index of an item in the ordered set.</p> Complexity <p>\\(O(1)\\).</p> Example <pre><code>&gt;&gt;&gt; order_set = ordered_set([1, 2, 3])\n&gt;&gt;&gt; order_set.index(1)\n0\n&gt;&gt;&gt; order_set.index(5)\nTraceback (most recent call last):\n  ...\nValueError: 5 is not in the ordered set\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Q</code> <p>The item to get the index of.</p> required <code>start</code> <code>Optional[int]</code> <p>The index to start searching from.</p> <code>None</code> <code>stop</code> <code>Optional[int]</code> <p>The index to stop searching at.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>The item is not in the ordered set.</p> <p>Returns:</p> Type Description <code>int</code> <p>The index of the item.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def index(self, item: Q, start: Optional[int] = None, stop: Optional[int] = None) -&gt; int:\n\"\"\"Gets the index of an item in the ordered set.\n\n    Complexity:\n        $O(1)$.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; order_set = ordered_set([1, 2, 3])\n        &gt;&gt;&gt; order_set.index(1)\n        0\n        &gt;&gt;&gt; order_set.index(5)\n        Traceback (most recent call last):\n          ...\n        ValueError: 5 is not in the ordered set\n        ```\n\n    Arguments:\n        item: The item to get the index of.\n        start: The index to start searching from.\n        stop: The index to stop searching at.\n\n    Raises:\n        ValueError: The item is not in the ordered set.\n\n    Returns:\n        The index of the item.\n    \"\"\"\n    index = self._item_to_index.get(item)\n    error = item_not_in_ordered_set(item)\n\n    if index is None:\n        raise error\n\n    if start is not None:\n        if index &lt; start:\n            raise error\n\n    if stop is not None:\n        if index &gt;= stop:\n            raise error\n\n    return index\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.count","title":"<code>count(item: Q) -&gt; int</code>","text":"<p>Returns <code>1</code> if an item is in the ordered set, <code>0</code> otherwise.</p> Complexity <p>\\(O(1)\\).</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Q</code> <p>The item to count.</p> required <p>Returns:</p> Type Description <code>int</code> <p><code>1</code> if the <code>item</code> is in the ordered set, <code>0</code> otherwise.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def count(self, item: Q) -&gt; int:\n\"\"\"Returns `1` if an item is in the ordered set, `0` otherwise.\n\n    Complexity:\n        $O(1)$.\n\n    Arguments:\n        item: The item to count.\n\n    Returns:\n        `1` if the `item` is in the ordered set, `0` otherwise.\n    \"\"\"\n    return int(item in self._item_to_index)\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.pop","title":"<code>pop(index: int = LAST) -&gt; Q</code>","text":"<p>Pops an item from the ordered set at <code>index</code>.</p> Complexity <p>\\(O(n)\\), see <code>discard</code>.</p> Example <pre><code>&gt;&gt;&gt; order_set = ordered_set([0, 1])\n&gt;&gt;&gt; order_set.pop()\n1\n&gt;&gt;&gt; order_set.pop(0)\n0\n&gt;&gt;&gt; order_set.pop()\nTraceback (most recent call last):\n  ...\nIndexError: list index out of range\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to pop the item from.</p> <code>LAST</code> <p>Raises:</p> Type Description <code>IndexError</code> <p>The index is out of range.</p> <p>Returns:</p> Type Description <code>Q</code> <p>The popped item.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def pop(self, index: int = LAST) -&gt; Q:\n\"\"\"Pops an item from the ordered set at `index`.\n\n    Complexity:\n        $O(n)$, see [`discard`][iters.ordered_set.OrderedSet.discard].\n\n    Example:\n        ```python\n        &gt;&gt;&gt; order_set = ordered_set([0, 1])\n        &gt;&gt;&gt; order_set.pop()\n        1\n        &gt;&gt;&gt; order_set.pop(0)\n        0\n        &gt;&gt;&gt; order_set.pop()\n        Traceback (most recent call last):\n          ...\n        IndexError: list index out of range\n        ```\n\n    Arguments:\n        index: The index to pop the item from.\n\n    Raises:\n        IndexError: The index is out of range.\n\n    Returns:\n        The popped item.\n    \"\"\"\n    items = self._items\n\n    item = items[index]\n\n    self.discard(item)\n\n    return item\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.discard","title":"<code>discard(item: Q) -&gt; None</code>","text":"<p>Discards an item from the ordered set.</p> Complexity <p>\\(O(n)\\), where \\(n\\) is the length of the ordered set. This is because all indices after the removed index must be decremented.</p> Example <pre><code>&gt;&gt;&gt; order_set = ordered_set([0, 1])\n&gt;&gt;&gt; order_set.discard(1)\n&gt;&gt;&gt; order_set\nOrderedSet([0])\n&gt;&gt;&gt; order_set.discard(1)\n&gt;&gt;&gt; order_set.discard(0)\n&gt;&gt;&gt; order_set\nOrderedSet()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Q</code> <p>The item to discard.</p> required Source code in <code>iters/ordered_set.py</code> <pre><code>def discard(self, item: Q) -&gt; None:\n\"\"\"Discards an item from the ordered set.\n\n    Complexity:\n        $O(n)$, where $n$ is the length of the ordered set.\n        This is because all indices after the removed index must be decremented.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; order_set = ordered_set([0, 1])\n        &gt;&gt;&gt; order_set.discard(1)\n        &gt;&gt;&gt; order_set\n        OrderedSet([0])\n        &gt;&gt;&gt; order_set.discard(1)\n        &gt;&gt;&gt; order_set.discard(0)\n        &gt;&gt;&gt; order_set\n        OrderedSet()\n        ```\n\n    Arguments:\n        item: The item to discard.\n    \"\"\"\n    item_to_index = self._item_to_index\n\n    if item in item_to_index:\n        index = item_to_index[item]\n\n        del self._items[index]\n\n        for item_in, index_in in item_to_index.items():\n            if index_in &gt;= index:\n                item_to_index[item_in] -= 1\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.remove","title":"<code>remove(item: Q) -&gt; None</code>","text":"<p>A checked version of <code>discard</code>.</p> <p>Complexity: \\(O(n)\\), see <code>discard</code>.</p> Example <pre><code>&gt;&gt;&gt; order_set = ordered_set([0, 1])\n&gt;&gt;&gt; order_set.remove(1)\n&gt;&gt;&gt; order_set\nOrderedSet([0])\n&gt;&gt;&gt; order_set.remove(1)\nTraceback (most recent call last):\n  ...\nValueError: 1 is not in the ordered set\n&gt;&gt;&gt; order_set.remove(0)\n&gt;&gt;&gt; order_set\nOrderedSet()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Q</code> <p>The item to remove.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>The item is not in the ordered set.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def remove(self, item: Q) -&gt; None:\n\"\"\"A checked version of [`discard`][iters.ordered_set.OrderedSet.discard].\n\n    Complexity: $O(n)$, see [`discard`][iters.ordered_set.OrderedSet.discard].\n\n    Example:\n        ```python\n        &gt;&gt;&gt; order_set = ordered_set([0, 1])\n        &gt;&gt;&gt; order_set.remove(1)\n        &gt;&gt;&gt; order_set\n        OrderedSet([0])\n        &gt;&gt;&gt; order_set.remove(1)\n        Traceback (most recent call last):\n          ...\n        ValueError: 1 is not in the ordered set\n        &gt;&gt;&gt; order_set.remove(0)\n        &gt;&gt;&gt; order_set\n        OrderedSet()\n        ```\n\n    Arguments:\n        item: The item to remove.\n\n    Raises:\n        ValueError: The item is not in the ordered set.\n    \"\"\"\n    if item in self:\n        self.discard(item)\n\n    else:\n        raise ValueError(ITEM_NOT_IN_ORDERED_SET.format(item))\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.insert","title":"<code>insert(index: int, item: Q) -&gt; None</code>","text":"<p>Inserts an item into the ordered set at <code>index</code>.</p> Complexity <p>\\(O(n)\\), where \\(n\\) is the length of the ordered set. This is because all indices after the inserted index must be incremented.</p> Example <pre><code>&gt;&gt;&gt; order_set = ordered_set([1, 3])\n&gt;&gt;&gt; order_set.insert(1, 2)\n&gt;&gt;&gt; order_set\nOrderedSet([1, 2, 3])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to insert the item at.</p> required <code>item</code> <code>Q</code> <p>The item to insert.</p> required Source code in <code>iters/ordered_set.py</code> <pre><code>def insert(self, index: int, item: Q) -&gt; None:\n\"\"\"Inserts an item into the ordered set at `index`.\n\n    Complexity:\n        $O(n)$, where $n$ is the length of the ordered set.\n        This is because all indices after the inserted index must be incremented.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; order_set = ordered_set([1, 3])\n        &gt;&gt;&gt; order_set.insert(1, 2)\n        &gt;&gt;&gt; order_set\n        OrderedSet([1, 2, 3])\n        ```\n\n    Arguments:\n        index: The index to insert the item at.\n        item: The item to insert.\n    \"\"\"\n    item_to_index = self._item_to_index\n\n    if item in item_to_index:\n        return\n\n    items = self._items\n\n    if index &lt; len(items):\n        items.insert(index, item)\n\n        for item_in, index_in in item_to_index.items():\n            if index_in &gt;= index:\n                item_to_index[item_in] += 1\n\n        item_to_index[item] = index\n\n    else:\n        self.append(item)\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Clears the ordered set.</p> Complexity <p>\\(O(1)\\).</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def clear(self) -&gt; None:\n\"\"\"Clears the ordered set.\n\n    Complexity:\n        $O(1)$.\n    \"\"\"\n    self._items.clear()\n    self._item_to_index.clear()\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.apply_union","title":"<code>apply_union(*iterables: Iterable[Q]) -&gt; OrderedSet[Q]</code>","text":"<p>Returns the union of the ordered set and <code>iterables</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[Q]</code> <p>The iterables to find the union with.</p> <code>()</code> <p>Returns:</p> Type Description <code>OrderedSet[Q]</code> <p>The union of the ordered set and <code>iterables</code>.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def apply_union(self, *iterables: Iterable[Q]) -&gt; OrderedSet[Q]:\n\"\"\"Returns the union of the ordered set and `iterables`.\n\n    Arguments:\n        *iterables: The iterables to find the union with.\n\n    Returns:\n        The union of the ordered set and `iterables`.\n    \"\"\"\n    if iterables:\n        return self.create_union(self, *iterables)\n\n    return self.copy()\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.apply_intersection","title":"<code>apply_intersection(*iterables: Iterable[Q]) -&gt; OrderedSet[Q]</code>","text":"<p>Returns the intersection of the ordered set and <code>iterables</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[Q]</code> <p>The iterables to find the intersection with.</p> <code>()</code> <p>Returns:</p> Type Description <code>OrderedSet[Q]</code> <p>The intersection of the ordered set and <code>iterables</code>.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def apply_intersection(self, *iterables: Iterable[Q]) -&gt; OrderedSet[Q]:\n\"\"\"Returns the intersection of the ordered set and `iterables`.\n\n    Arguments:\n        *iterables: The iterables to find the intersection with.\n\n    Returns:\n        The intersection of the ordered set and `iterables`.\n    \"\"\"\n    if iterables:\n        intersection = set.intersection(*map(set, iterables))  # type: ignore\n\n        iterator = (item for item in self if item in intersection)\n\n        return self.create_unchecked(iterator)\n\n    return self.copy()\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.intersection_update","title":"<code>intersection_update(*iterables: Iterable[Q]) -&gt; None</code>","text":"<p>Updates the ordered set to be the intersection of itself and <code>iterables</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[Q]</code> <p>The iterables to find the intersection with.</p> <code>()</code> Source code in <code>iters/ordered_set.py</code> <pre><code>def intersection_update(self, *iterables: Iterable[Q]) -&gt; None:\n\"\"\"Updates the ordered set to be the intersection of itself and `iterables`.\n\n    Arguments:\n        *iterables: The iterables to find the intersection with.\n    \"\"\"\n    if iterables:\n        intersection = self.intersection(*iterables)\n\n        self.clear()\n\n        self.update(intersection)\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.apply_difference","title":"<code>apply_difference(*iterables: Iterable[Q]) -&gt; OrderedSet[Q]</code>","text":"<p>Returns the difference of the ordered set and <code>iterables</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[Q]</code> <p>The iterables to find the difference with.</p> <code>()</code> <p>Returns:</p> Type Description <code>OrderedSet[Q]</code> <p>The difference of the ordered set and <code>iterables</code>.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def apply_difference(self, *iterables: Iterable[Q]) -&gt; OrderedSet[Q]:\n\"\"\"Returns the difference of the ordered set and `iterables`.\n\n    Arguments:\n        *iterables: The iterables to find the difference with.\n\n    Returns:\n        The difference of the ordered set and `iterables`.\n    \"\"\"\n    if iterables:\n        union = set.union(*map(set, iterables))  # type: ignore\n        iterator = (item for item in self if item not in union)\n\n        return self.create_unchecked(iterator)\n\n    return self.copy()\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.difference_update","title":"<code>difference_update(*iterables: Iterable[Q]) -&gt; None</code>","text":"<p>Updates the ordered set to be the difference of itself and <code>iterables</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[Q]</code> <p>The iterables to find the difference with.</p> <code>()</code> Source code in <code>iters/ordered_set.py</code> <pre><code>def difference_update(self, *iterables: Iterable[Q]) -&gt; None:\n\"\"\"Updates the ordered set to be the difference of itself and `iterables`.\n\n    Arguments:\n        *iterables: The iterables to find the difference with.\n    \"\"\"\n    if iterables:\n        difference = self.difference(*iterables)\n\n        self.clear()\n\n        self.update(difference)\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.apply_symmetric_difference","title":"<code>apply_symmetric_difference(*iterables: Iterable[Q]) -&gt; OrderedSet[Q]</code>","text":"<p>Returns the symmetric difference of the ordered set and <code>iterables</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[Q]</code> <p>The iterables to find the symmetric difference with.</p> <code>()</code> <p>Returns:</p> Type Description <code>OrderedSet[Q]</code> <p>The symmetric difference of the ordered set and <code>iterables</code>.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def apply_symmetric_difference(self, *iterables: Iterable[Q]) -&gt; OrderedSet[Q]:\n\"\"\"Returns the symmetric difference of the ordered set and `iterables`.\n\n    Arguments:\n        *iterables: The iterables to find the symmetric difference with.\n\n    Returns:\n        The symmetric difference of the ordered set and `iterables`.\n    \"\"\"\n    if iterables:\n        result = self\n\n        for iterable in iterables:\n            result = result.single_symmetric_difference(iterable)\n\n        return result\n\n    return self.copy()\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.symmetric_difference_update","title":"<code>symmetric_difference_update(*iterables: Iterable[Q]) -&gt; None</code>","text":"<p>Updates the ordered set to be the symmetric difference of itself and <code>iterables</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*iterables</code> <code>Iterable[Q]</code> <p>The iterables to find the symmetric difference with.</p> <code>()</code> Source code in <code>iters/ordered_set.py</code> <pre><code>def symmetric_difference_update(self, *iterables: Iterable[Q]) -&gt; None:\n\"\"\"Updates the ordered set to be the symmetric difference of itself and `iterables`.\n\n    Arguments:\n        *iterables: The iterables to find the symmetric difference with.\n    \"\"\"\n    if iterables:\n        symmetric_difference = self.symmetric_difference(*iterables)\n\n        self.clear()\n\n        self.update(symmetric_difference)\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.is_subset","title":"<code>is_subset(other: Iterable[Q]) -&gt; bool</code>","text":"<p>Checks if the ordered set is a subset of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[Q]</code> <p>The iterable to check if the ordered set is a subset of.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the ordered set is a subset of <code>other</code>.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def is_subset(self, other: Iterable[Q]) -&gt; bool:\n\"\"\"Checks if the ordered set is a subset of `other`.\n\n    Arguments:\n        other: The iterable to check if the ordered set is a subset of.\n\n    Returns:\n        Whether the ordered set is a subset of `other`.\n    \"\"\"\n    if is_instance(other, Sized):  # cover obvious cases\n        if len(self) &gt; len(other):\n            return False\n\n    if is_instance(other, AnySet):  # speedup for sets\n        return all(item in other for item in self)\n\n    other_set = set(other)\n\n    return len(self) &lt;= len(other_set) and all(item in other_set for item in self)\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.is_strict_subset","title":"<code>is_strict_subset(other: Iterable[Q]) -&gt; bool</code>","text":"<p>Checks if the ordered set is a strict subset of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[Q]</code> <p>The iterable to check if the ordered set is a strict subset of.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the ordered set is a strict subset of <code>other</code>.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def is_strict_subset(self, other: Iterable[Q]) -&gt; bool:\n\"\"\"Checks if the ordered set is a strict subset of `other`.\n\n    Arguments:\n        other: The iterable to check if the ordered set is a strict subset of.\n\n    Returns:\n        Whether the ordered set is a strict subset of `other`.\n    \"\"\"\n    if is_instance(other, Sized):  # cover obvious cases\n        if len(self) &gt;= len(other):\n            return False\n\n    if is_instance(other, AnySet):  # speedup for sets\n        return all(item in other for item in self)\n\n    other_set = set(other)  # default case\n\n    return len(self) &lt; len(other_set) and all(item in other_set for item in self)\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.is_superset","title":"<code>is_superset(other: Iterable[Q]) -&gt; bool</code>","text":"<p>Checks if the ordered set is a superset of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[Q]</code> <p>The iterable to check if the ordered set is a superset of.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the ordered set is a superset of <code>other</code>.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def is_superset(self, other: Iterable[Q]) -&gt; bool:\n\"\"\"Checks if the ordered set is a superset of `other`.\n\n    Arguments:\n        other: The iterable to check if the ordered set is a superset of.\n\n    Returns:\n        Whether the ordered set is a superset of `other`.\n    \"\"\"\n    if is_instance(other, Sized):  # speedup for sized iterables\n        return len(self) &gt;= len(other) and all(item in self for item in other)\n\n    return all(item in self for item in other)  # default case\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.is_strict_superset","title":"<code>is_strict_superset(other: Iterable[Q]) -&gt; bool</code>","text":"<p>Checks if the ordered set is a strict superset of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[Q]</code> <p>The iterable to check if the ordered set is a strict superset of.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the ordered set is a strict superset of <code>other</code>.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def is_strict_superset(self, other: Iterable[Q]) -&gt; bool:\n\"\"\"Checks if the ordered set is a strict superset of `other`.\n\n    Arguments:\n        other: The iterable to check if the ordered set is a strict superset of.\n\n    Returns:\n        Whether the ordered set is a strict superset of `other`.\n    \"\"\"\n    if is_instance(other, Sized):  # speedup for sized iterables\n        return len(self) &gt; len(other) and all(item in self for item in other)\n\n    array = list(other)  # default case\n\n    return len(self) &gt; len(array) and all(item in self for item in array)\n</code></pre>"},{"location":"reference/ordered_set/#iters.ordered_set.OrderedSet.is_disjoint","title":"<code>is_disjoint(other: Iterable[Q]) -&gt; bool</code>","text":"<p>Checks if the ordered set is disjoint with <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[Q]</code> <p>The iterable to check if the ordered set is disjoint with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the ordered set is disjoint with <code>other</code>.</p> Source code in <code>iters/ordered_set.py</code> <pre><code>def is_disjoint(self, other: Iterable[Q]) -&gt; bool:\n\"\"\"Checks if the ordered set is disjoint with `other`.\n\n    Arguments:\n        other: The iterable to check if the ordered set is disjoint with.\n\n    Returns:\n        Whether the ordered set is disjoint with `other`.\n    \"\"\"\n    return none(item in self for item in other)\n</code></pre>"},{"location":"reference/types/","title":"Types","text":""},{"location":"reference/types/#iters.types.no_default","title":"<code>no_default = NoDefault()</code>  <code>module-attribute</code>","text":"<p>The instance of <code>NoDefault</code>.</p>"},{"location":"reference/types/#iters.types.marker","title":"<code>marker = Marker()</code>  <code>module-attribute</code>","text":"<p>The instance of <code>Marker</code>.</p>"},{"location":"reference/types/#iters.types.NoDefault","title":"<code>NoDefault</code>","text":"<p>         Bases: <code>Singleton</code></p> <p>Represents the absence of default values.</p> Source code in <code>iters/types.py</code> <pre><code>class NoDefault(Singleton):\n\"\"\"Represents the absence of default values.\"\"\"\n</code></pre>"},{"location":"reference/types/#iters.types.Marker","title":"<code>Marker</code>","text":"<p>         Bases: <code>Singleton</code></p> <p>Represents markers used for various checks.</p> Source code in <code>iters/types.py</code> <pre><code>class Marker(Singleton):\n\"\"\"Represents markers used for various checks.\"\"\"\n</code></pre>"},{"location":"reference/types/#iters.types.is_no_default","title":"<code>is_no_default(item: Any) -&gt; TypeGuard[NoDefault]</code>","text":"<p>Checks if the <code>item</code> is <code>NoDefault</code>.</p> <p>Returns:</p> Type Description <code>TypeGuard[NoDefault]</code> <p>Whether the <code>item</code> is <code>NoDefault</code>.</p> Source code in <code>iters/types.py</code> <pre><code>def is_no_default(item: Any) -&gt; TypeGuard[NoDefault]:\n\"\"\"Checks if the `item` is [`NoDefault`][iters.types.NoDefault].\n\n    Returns:\n        Whether the `item` is [`NoDefault`][iters.types.NoDefault].\n    \"\"\"\n    return item is no_default\n</code></pre>"},{"location":"reference/types/#iters.types.is_not_no_default","title":"<code>is_not_no_default(item: NoDefaultOr[T]) -&gt; TypeGuard[T]</code>","text":"<p>Checks if the <code>item</code> is not <code>NoDefault</code>.</p> <p>Returns:</p> Type Description <code>TypeGuard[T]</code> <p>Whether the <code>item</code> is not <code>NoDefault</code>.</p> Source code in <code>iters/types.py</code> <pre><code>def is_not_no_default(item: NoDefaultOr[T]) -&gt; TypeGuard[T]:\n\"\"\"Checks if the `item` is not [`NoDefault`][iters.types.NoDefault].\n\n    Returns:\n        Whether the `item` is not [`NoDefault`][iters.types.NoDefault].\n    \"\"\"\n    return item is not no_default\n</code></pre>"},{"location":"reference/types/#iters.types.is_marker","title":"<code>is_marker(item: Any) -&gt; TypeGuard[Marker]</code>","text":"<p>Checks if the <code>item</code> is <code>Marker</code>.</p> <p>Returns:</p> Type Description <code>TypeGuard[Marker]</code> <p>Whether the <code>item</code> is <code>Marker</code>.</p> Source code in <code>iters/types.py</code> <pre><code>def is_marker(item: Any) -&gt; TypeGuard[Marker]:\n\"\"\"Checks if the `item` is [`Marker`][iters.types.Marker].\n\n    Returns:\n        Whether the `item` is [`Marker`][iters.types.Marker].\n    \"\"\"\n    return item is marker\n</code></pre>"},{"location":"reference/types/#iters.types.is_not_marker","title":"<code>is_not_marker(item: MarkerOr[T]) -&gt; TypeGuard[T]</code>","text":"<p>Checks if the <code>item</code> is not <code>Marker</code>.</p> <p>Returns:</p> Type Description <code>TypeGuard[T]</code> <p>Whether the <code>item</code> is not <code>Marker</code>.</p> Source code in <code>iters/types.py</code> <pre><code>def is_not_marker(item: MarkerOr[T]) -&gt; TypeGuard[T]:\n\"\"\"Checks if the `item` is not [`Marker`][iters.types.Marker].\n\n    Returns:\n        Whether the `item` is not [`Marker`][iters.types.Marker].\n    \"\"\"\n    return item is not marker\n</code></pre>"},{"location":"reference/typing/","title":"Typing","text":""},{"location":"reference/typing/#iters.typing.Sum","title":"<code>Sum</code>","text":"<p>         Bases: <code>Protocol</code></p> <p>Represents types for which adding <code>self: S</code> to <code>other: S</code> returns <code>S</code>.</p> Source code in <code>iters/typing.py</code> <pre><code>@runtime_checkable\nclass Sum(Protocol):\n\"\"\"Represents types for which adding `self: S` to `other: S` returns `S`.\"\"\"\n\n    @required\n    def __add__(self: S, __other: S) -&gt; S:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/typing/#iters.typing.Product","title":"<code>Product</code>","text":"<p>         Bases: <code>Protocol</code></p> <p>Represents types for which multiplying <code>self: P</code> with <code>other: P</code> returns <code>P</code>.</p> Source code in <code>iters/typing.py</code> <pre><code>@runtime_checkable\nclass Product(Protocol):\n\"\"\"Represents types for which multiplying `self: P` with `other: P` returns `P`.\"\"\"\n\n    @required\n    def __mul__(self: P, __other: P) -&gt; P:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/utils/","title":"Utilities","text":""}]}